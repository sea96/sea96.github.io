{"meta":{"title":"清逸","subtitle":null,"description":"知者不言，言者不知。","author":"清逸","url":"https://sea96.github.io"},"pages":[{"title":"关于","date":"2017-02-21T12:18:24.000Z","updated":"2017-05-13T14:13:27.187Z","comments":false,"path":"about/index.html","permalink":"https://sea96.github.io/about/index.html","excerpt":"","text":"欢迎访问我的博客"},{"title":"标签云","date":"2017-02-21T12:08:14.000Z","updated":"2017-05-13T08:33:07.710Z","comments":false,"path":"tags/index.html","permalink":"https://sea96.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-02-21T12:16:31.000Z","updated":"2017-05-13T08:35:13.021Z","comments":false,"path":"categories/index.html","permalink":"https://sea96.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Cocos2d-x 学习随记","slug":"Cocos2d-x-学习随记","date":"2017-06-24T14:41:32.000Z","updated":"2017-06-27T09:00:38.448Z","comments":true,"path":"2017/06/24/Cocos2d-x-学习随记/","link":"","permalink":"https://sea96.github.io/2017/06/24/Cocos2d-x-学习随记/","excerpt":"","text":"Cocos2D-C++在Windows上搭建Cocos2d-x win32开发环境-v3.x工具准备 Cocos2d-x Cocos Studio Microsoft Visual Studio 2013 python 2.7.3 创建项目方法一方法二【教程】使用Cocos构建一个完整项目 Cocos2D-JavaScript跳动的小球js代码12345678910111213ballJumpAction:function()&#123; //向上跳动 var jumpUp = cc.moveBy(this.jumpDuration,cc.p(0,this.jumpHeight)).easing(cc.easeCubicActionOut()); //下落 var jumpDown = cc.moveBy(this.jumpDuration,cc.p(0,-this.jumpHeight)).easing(cc.easeCubicActionIn()); //不断重复 return cc.repeatForever(cc.sequence(jumpUp ,jumpDown));&#125;,// use this for initializationonLoad: function () &#123; this.jumpAction = this.ballJumpAction(); this.node.runAction(this.jumpAction);&#125;, 效果展示 场景切换js代码123456onLoad: function () &#123; //点击按钮转换场景 this.node.on('mousedown', function()&#123; cc.director.loadScene('Scene2'); &#125;)&#125;, 倒计时游戏js代码123456789101112131415161718properties: &#123; timeLabel: &#123; default:null, type:cc.Label &#125;,&#125;,// use this for initializationonLoad: function () &#123; var time=5; this.schedule(function()&#123; time--; this.timeLabel.string=time; if(time===0)&#123; cc.director.loadScene('Scene3'); &#125; &#125;,1);&#125;, 效果展示","categories":[{"name":"游戏开发","slug":"游戏开发","permalink":"https://sea96.github.io/categories/游戏开发/"}],"tags":[{"name":"Cocos","slug":"Cocos","permalink":"https://sea96.github.io/tags/Cocos/"}]},{"title":"字典树","slug":"字典树","date":"2017-06-16T08:39:35.000Z","updated":"2017-06-17T08:22:29.041Z","comments":true,"path":"2017/06/16/字典树/","link":"","permalink":"https://sea96.github.io/2017/06/16/字典树/","excerpt":"","text":"应用 求解计数类问题 贪心问题如位运算（异或有奇效） 加速动态规划问题 题目UVA 11488 Hyper Prefix Sets题意给定一个字符串集合 $S$，定义 $P(S)$ 为所有字符串的公共前缀长度与 $S$ 中字符串个数的乘积。给$n$ 个$01$串，从中选出一个集合 $S$，使得 $P(S)$ 最大。数据$ n \\leq 50000$题解把字符串插入到 $01$ 字典树里，记录每个节点字符串的数量，遍历树同时更新最大值。code UVALive 3942 Remember the Word题意给出一个由 $S$ 个不同单词组成的字典和一个长度为 $L$ 的长字符串。问把该字符串分解为若干个单词连接，有多少种方案（mod $20071027$）。数据$L \\leq 300000$, $1\\leq S \\leq 4000$, 单词长度不超过 $100$题解递推法：令 $d(i)$ 表示从 $i$ 开始的字符串的方案数，则 $d(i)=\\sum{d(i+len(x))}$ | 单词 $x$ 是字符串 $[i,L]$ 的前缀。如果依次枚举单词，时间无法承受。那么把单词放进Trie中，树上遍历时每经过一个单词结点，就能找到转移方程中的 $x$。code UVA 11732 “strcmp()” Anyone?题意输入 $n$ 个字符串，两两调用一次strcmp()，问字符比较的总次数（for循环内的比较也算）。数据$1 \\leq n \\leq 4000$，字符串长度不超过 $1000$，输入文件大小约为 $23$MB题解把所有字符串插入到一颗字典树里，记录每个节点字符的数量，那么再遍历一次字典树就可以把比较次数累加起来了。因为数据量很大，使用左儿子-右兄弟的动态建树方法。code UVALive 5913 Dictionary Size 题意给出 $n$ 个字符串组成的字典，现在要添加新的单词，从已有单词中选出非空前缀和非空后缀，组成新单词，问能组成多少个单词。数据$1 \\leq n \\leq 10000$题解建立一棵前缀树和一棵后缀树，有多少节点即为有多少个前缀。但是直接相乘并不是答案，考虑可能有重复的，比如”XAY”，可以由”X”和”AY”组成，也可以由”XA”和“Y”组成，一共计算了两次，所以要减去一次（注意字符串是单个字符的时候要特殊处理）。code UVALive 7192 Chip Factory题意从 $n$ 个数中选出不同的三个数$a、b、c$，使得 $(a+b)$ ^ $c$ 最大。数据$1 ≤ T ≤ 1000$，$3 ≤ n ≤ 1000$，$0 ≤ s_i ≤ 10^9$There are at most $10$ testcases with $n &gt; 100$题解先将所有数字按位插入到字典树上，然后删除两个数字，树上二分贪心询问与剩下的数字最大异或值。code HDOJ 5715 XOR游戏题意有一个长度为 $N$ 的数组，度度熊可以任意添加分割线，将数组划分为 $M$ 段，且每段长度小于等于 $L$。求所有分组内异或和的最小值的最大值。数据$1≤T≤300$，$1≤N≤10^4$，$1≤M≤10$，$1≤L≤N $，$1≤A_i≤10^9$题解显然答案满足二分性质，那么问题转化为判断值是否可行。$dp[i][j]$ 表示前 $i$ 个数字分为 $j$ 组，且所有分组异或和最小值大于等于 $val$ 是否可行，$A_i$ 先转变为前缀异或和，假设当前判断的值为 $val$，那么状态转移方程为：$dp[i][j]$ |= ($dp[k][j-1]$ &amp;&amp; $A_i$ ^ $A_k \\geq val$)。时间复杂度：$O(TN^2M)$，显然无法承受。注意到异或的特殊性，考虑生成M棵字典树，把所有 $dp[k][j-1]=true$ 的 $A_k$ 插入到第 $j-1$ 棵字典树里，当 $A_i$ 在第 $j-1$ 棵字典树使用上题的方法求得的最大异或和大于等于 $val$ 时，$dp[i][j]=true$，同时把 $A_i$ 插入到第 $j$ 棵树。注意每棵字典树只保存前一个分组的信息，分组的长度也有限制，所以还需要动态删点。code","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"}]},{"title":"精选优秀网站","slug":"精选优秀网站","date":"2017-06-14T03:42:02.000Z","updated":"2017-07-15T03:29:27.825Z","comments":true,"path":"2017/06/14/精选优秀网站/","link":"","permalink":"https://sea96.github.io/2017/06/14/精选优秀网站/","excerpt":"","text":"图片 别样图 无版权免费大尺寸图片共享平台 极简图床 不限流量，支持粘贴上传、拖放上传 FaceYourManga DIY头像","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://sea96.github.io/categories/开发工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://sea96.github.io/tags/工具/"}]},{"title":"特殊图","slug":"特殊图","date":"2017-06-03T00:44:41.000Z","updated":"2017-06-14T03:38:47.006Z","comments":true,"path":"2017/06/03/特殊图/","link":"","permalink":"https://sea96.github.io/2017/06/03/特殊图/","excerpt":"","text":"欧拉图定义通过图（无向图或有向图）中所有边且每边仅通过一次通路称为欧拉通路，相应的回路称为欧拉回路。具有欧拉回路的图称为欧拉图（Euler Graph），具有欧拉通路而无欧拉回路的图称为半欧拉图。 定理欧拉道路 无向图：当且仅当该图为连通图且所有顶点的度数为偶数，或者除了两个度数为奇数外其余的全是偶数。 有向图：当且仅当该图为连通图（忽略边的方向）且所有顶点 出度等于入度 或者一个顶点 入度比出度小1（把它当作起点） ，另一个顶点 入度比出度大1（把它当作终点），其他顶点 出度等于入度。 欧拉回路 无向图：当且仅当该图为连通图且每个顶点的度数都是偶数。 有向图：当且仅当该图为连通图且每个顶点的入度等于出度。","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"}]},{"title":"第k短路","slug":"第k短路","date":"2017-06-02T12:08:06.000Z","updated":"2017-09-01T11:10:14.508Z","comments":true,"path":"2017/06/02/第k短路/","link":"","permalink":"https://sea96.github.io/2017/06/02/第k短路/","excerpt":"","text":"第k短路A star 算法：通过一个估价函数 $f(n)=g(n)+h(n)$ 来估计图中的当前点 $n$ 到终点的距离，并由此决定它的搜索方向。首先在反图上使用Spfa或Dijkstra求出所有点到终点的最短路径。估价函数：当前走过的距离 + 该点到终点的最短路长度。用堆（优先队列）维护，每次取出估价函数最小的一个点扩展。第 $k$ 次从堆中取出点 $T$，就是找到了 $T$ 的第 $k$ 短路。算法模板","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"}]},{"title":"平方分割","slug":"平方分割","date":"2017-05-21T02:00:00.000Z","updated":"2017-06-14T03:34:26.728Z","comments":true,"path":"2017/05/21/平方分割/","link":"","permalink":"https://sea96.github.io/2017/05/21/平方分割/","excerpt":"","text":"概述平方分割又叫做分桶法或者分块法，把排成一排的 $N$ 个元素每 $√N$ 分在一个块（桶）里，这样的分割方法可以把对区间的操作的复杂度降至 $O(√N)$。 对序列平方分割一般的做法是预设一个整数 $S$（$S$=$⌈√N⌉$），将序列分成 $B$（$B$=$⌈NS⌉$）块，每块 $S$ 个元素。对于一个区间的操作分为块内操作和块间操作，块内的暴力求解，块间的高效求解（排序后二分，lazy标记，预处理，数据结构维护等）。 123456//定义块号和块边界for (int i=0; i&lt;n; ++i) &#123; belong[i] = i / S; L[i] = belong[i]*S; R[i] = min(n, L[i]+S)&#125; 12345678910//区间询问或区间修改for (int i=l; i&lt;=r; ) &#123; if (i == L[i] &amp;&amp; R[i] &lt; r) &#123; //need efficient algorithm i = R[i]; &#125; else &#123; //just use brute force i++; &#125;&#125; 题目POJ 2104 K-th Number题意有 $n$ 个数字，$m$ 次询问，询问$[l,r]$区间里第 $k$ 大的数字。题解这题是主席树的经典题目，在本文中尝试用分块的方法求解。对元素的位置分块，每块分别排好序，二分第 $k$ 大的数字 $v$ ，对于一个区间 $[l,r]$ 查询小于 $v$ 的个数分为块内查询和块间查询，块内元素一个一个判断是否小于 $v$ ；块间用二分查找来统计小于 $v$ 的个数。二分复杂度：$O(logN)$，单次查询复杂度：$O(S+BlogS)$总时间复杂度：$O(M(logN(S+BlogS)))$code UVA 12003 Array Transformer题意有一个数组 $A[1,…,n]$ 和 $m$ 条指令和一个数字 $u$ ，每条指令形如 $(l,r,v,p)$ ，统计出 $A[l],A[l+1],…,A[r]$ 中严格小于 $v$ 的元素的个数为 $k$ ，然后把 $A[p]$ 改为$\\frac {uk}{r-l+1}$。问变换后的最终数组。 题解 对元素的位置分块，每块分别排序。询问的操作同POJ 2104，修改的操作则在 $p$ 所在的块里进行，因为修改后块内元素基本有序，所以用 插入排序 的方法使得被修改的元素移动到正确的位置。单次修改的复杂度： $O(logS+S)$ ，单次查询的复杂度：$O(S+BlogS)$ 总时间复杂度：$O(M(S+BlogS))$ 类题：SPOJ RACETIME Race Against Timecode 拓展若本题修改不是单点修改，而是区间修改，那么也没有必要重新全部排序： 本来数组是有序的，现在把其中一部分加上了一个数，那么可以将原数组分为修改后的和没修改的两部分，每部分都是一个有序数组，可以在 $O(S)$ 的时间内 归并排序。 ——《非常规大小分块算法初探》 徐明宽 BZOJ 2957 楼房重建题意一个人在坐标 $(0,0)$ 看楼房，楼房定义为 $(xi,yi)$ 表示位置在 $x_i$ ，高度为 $y_i$ 。如果这栋楼房上任何一个高度大于0的点与 $(0,0)$ 的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。起初所有楼房的高度都为0，有 $M$ 次操作，每次修改某个楼房的高度，问每次操作结束后能从 $(0,0)$ 看到多少栋楼房。题解如果一栋楼房可见，那么最高点 $(xi,yi)$ 和 $(0,0)$ 在x轴上的斜率一定大于前面所有的楼房，也就是要求斜率单调递增的序列的长度。对楼房的位置分块，每个块维护斜率递增的序列。修改操作直接在某个块上重新计算斜率递增的序列（可以使用插入排序算法），查询操作在每个块里二分查找大于前一个块里的最大斜率的斜率，并更新当前最大斜率。单次修改复杂度：$O(S)$，单次查询复杂度：$O(BlogS)$总时间复杂度：$O(M(BlogS+S))$code HDOJ 4366 Successor题意有 $n$ 个人，编号为0的是老板，编号1到 $n−1$ 是员工，每个员工只有一个上司，除老板为每个人有他的忠诚值和能力值。每次要解雇一个人的时候，从他的下属中选取能力值大于他的且忠诚值最高的一个，若不存在则输出-1。共 $m$ 次询问，每次询问解雇编号为 $i$ 的员工会选择哪个编号的员工顶替他。（所有询问都不相互影响）题解显然是一棵树，用DFS序得到编号的序列，每个点能知道子树在序列上对应的区间。对序列分块，每块的元素按照能力值排序，简单的dp求得能力值更大的后缀里忠诚值的最大值。块内查询逐个遍历，块间查询二分查找大于解雇员工的能力值的位置，从而得到最大的忠诚值，又因为忠诚值互不相同，所以能用map对应到员工的编号。单次查询复杂度：$O(BlogS)$总时间复杂度：$O(M(BlogS))$code BZOJ 2002 Bounce 弹飞绵羊题意有 $n$ 个弹力装置，每个装置有一个弹力系数$ k_i$ ，如果绵羊到达第 $i$ 个装置，它会被弹到第 $i+k_i$ 个装置。有 $m$ 个操作，修改某个装置的弹力系数，或者询问从某个装置出发弹几次后会被弹飞。题解对装置的位置分块，预处理出每个块维护从块里每个位置出发要弹几次后弹出该块，以及弹出后到达的位置。修改操作直接在某个块上重新计算要维护的信息，查询操作利用每个块的信息可以 $O(1)$ 跳出该块，累计次数和即可。单次修改复杂度：$O(S)$，单次查询复杂度：$O(B)$总时间复杂度：$O(M(S+B))$code拓展本题的加强版：CodeForces 13E Holes增加单点修改的操作以及询问最后被弹飞的位置。做法类似，预处理中增加从块里每个位置出发最后弹出该块的位置code CodeForces 551E GukiZ and GukiZiana题意有 $n$ 个数字，$m$ 次操作：1. $[l,r]$ 区间里的所有数字都增加 $x$ ；2. 询问 $[1,n]$ 里的最远点对 $(i,j)$ 满足 $a_i=a_j=y$ 。题解类似线段树的区间修改，对每一个块添加lazy标记表示该块统一增加的总和。每块分别把 $pair(a[i],i)$排好序，若块内元素被修改则重新排序，询问时只要对所有的块二分 $(y−lazy[b])$ 求出最近左端点和最远右端点即可。单次修改复杂度：$O(SlogS+B)$，单次查询复杂度：$O(BlogS)$总时间复杂度：$O(M(SlogS+BlogS))$code CodeForces 444C DZY Loves Colors题意有 $n$ 个数字，第 $i$ 个数字$a[i]=i$ ，有 $m$ 次操作：1. 修改 $[l,r]$ 区间的数字为 $x$ ，设原来的值为 $y$ ，那么该位置改变量累加 $|x−y|$；2. 询问 $[l,r]$ 区间的改变量的总和。题解对每一个块设置lazy标记表示该块的相同的值（如果不相同则标记为0），$sum[i]$ 表示第i个数字非lazy修改（即直接单点修改）的改变量和，$sumlazy[b]$ 表示第 $b$ 块里每一个数字经lazy修改的改变量和，$sumblock[b]$ 表示第 $b$ 块经lazy修改的所有数字的改变量总和。每次区间修改最多出现两个没有lazy标记的块，所以需要暴力单点更新的块不会很多。块内询问每个数字的贡献值总和：$∑(sum[i]+sumlazy[b])$；块间询问每个块的贡献值总和：$∑sumblock[b]$。单次修改复杂度：$O(S+B)$，单次查询复杂度：$O(S+B)$总时间复杂度：$O(M(S+B))$code CodeChef QCHEF Chef and Problems题意有 $N$ 个数字，第 $i$ 个数字 $A[i]≤M$ ，$K$ 次询问：问在 $[L,R]$ 中相同数字的位置的最大间隔。题解由于没有修改操作，可以预处理一些信息来辅助求解。对序列分块之后进行预处理：块间预处理：$ans[i][j]$ 表示第 $i$ 块到第 $j$ 块区间里的最大间隔，通过prepre数组记录每个数字最早出现的位置实现。然后就可以 $O(1)$ 得到块间最大值。块内预处理：$pos0[b][v]$ 表示第 $b$ 块里 $v$ 最后出现的位置，然后转为前 $b$ 块的最后出现的位置；同理可得 $pos1[b][v]$ 表示第 $b$ 块之后 $v$ 最早出现的位置。然后暴力求解即可，求解方法和块间预处理相同。块间预处理复杂度：$O(BN)$，块内预处理复杂度：$O(N+BM)$总时间复杂度：$O(BN+BM+KS)$code类题：SPOJ ZQUERY Zero Query（提示：求前缀和） LYOI 147 「分块」区间众数题意给一个长度为 $n$ 的序列，$m$ 次询问，每次查询一个区间 $[l,r]$ 内的众数（如果有多个众数，取最小的一个），强制在线。题解同样没有修改操作，类似上题预处理一些信息。对序列离散化，分块之后进行预处理：块间预处理：$ans[i][j]$ 表示第 $i$ 块到第 $j$ 块区间的众数，通过 $cnt$ 数组记录每个数字出现次数实现。然后就可以 $O(1)$ 得到块间最大值。块内预处理：$sum[b][v]$ 表示第 $b$ 块里 $v$ 出现的次数，然后转为前 $b$ 块的出现的次数。然后暴力求解即可，求解方法和块间预处理相同。块间预处理复杂度：$O(BN)$，块内预处理复杂度：$O(N+BN)$总时间复杂度：$O(BN+S)$code拓展带修改操作：区间众数解题报告 - 陈立杰 CodeForces 455D Serega and Fun题意有 $n$ 个数字，$q$ 次操作，1. 序列循环向右移动一位；2. 询问 $[l,r]$ 里 $k$ 的个数。强制在线。题解使用块状链表解决：用deque或者list存储每块的元素，移位操作在每块 $O(1)$ 地插入或删除。预处理出每块中每个元素的个数，移位时也可以 $O(1)$ 修改。总时间复杂度：$O(Q(B+S))$code HDU 4391 Paint The Wall题意有 $n$ 个数字，$q$ 次操作，1. 将 $[l,r]$ 里的所有元素涂成颜色 $z$；2. 询问 $[l,r]$ 里 颜色 $z$ 的个数。题解颜色范围很大，如果使用朴素的线段树空间上无法承受。线段树套分块哈希：考虑线段树维护的不是单个元素，而是整块元素，每块用 map 维护每种颜色的数量，再加上懒惰标记后可以通过此题。总时间复杂度：$O(Q(B+SlogS)$code 对集合平方分割通常在图中使用，具体做法是预设一个整数$S$（$S$=$√E$），将度数超过 $S$ 的点记为重点，其余的点记为轻点。重新建图：重点只与相邻的重点连边，重点与相邻的轻点的边的信息使用预处理或者数据结构等手段高效维护，使得对点的遍历和边的修改的复杂度降至 $O(√E)$ 。 题目HDU 4858 项目管理题意有 $n$ 个点，$m$ 条边的无向无环图，两个节点可能有多条边，每条点有权值，有 $q$ 次操作，1. 节点 $u$ 的权值加上 $v$；2. 问节点 $u$ 相邻点的权值和。题解根据重点和轻点的定义，将原图重新建图，若 $u$ 是重点，$sum[u]$ 保存与 $u$ 相邻的 重点 的权值和。修改 重点 的话更新该点和与该点相邻的 重点 的 $sum$（单次修改复杂度：$O(S)$；单次查询复杂度：$O(1)$），否则在原图遍历所有相邻点的 $sum$（单次修改复杂度：$O(S)$；单次查询复杂度：$O(S)$）。总时间复杂度：$O(QS)$code HDU 4467 Graph题意有 $n$ 个点，$m$ 条边的无向无环图，每条边有权值 $w$，每个点有颜色 $(0/1)$，有 $q$ 次操作，1. 第 $x$ 个点的颜色反转；2. 问端点的颜色是 $(A,B)$ 的边的权值和。（$A(B)=0/1$）题解根据重点和轻点的定义，将原图重新建图，预处理若干信息，若 $u$ 是 重点，$sum[u][0/1]$ 保存与 $u$ 相邻的 重点（轻）点 的边权和，$ans[k]$ ($k=0$: 0-0; $k=1$: 0-1; $k=2$: 1-1) 保存统一类型的边权总和，修改只要交换信息即可，查询能 $O(1)$ 得到答案。code ZOJ 3749 Chameleon题意有 $n$ 个集合，第 $i$ 个集合有 $m_i$ 个数字，所有数字都不相同，$q$ 次操作，每次选取第 $i$ 个集合和第 $j$ 个集合，按照数字大小归并排序，问排序后相邻数字之间所属集合不同的个数。题解按照朴素的方法，复杂度是 $O(QN)$ 。按照集合的大小以 $S=√N$ 分类，两个集合都小于 $S$ 的询问按照朴素的方法解决，复杂度为 $O(QS)$ ；如果大于 $S$ ，考虑离线询问，对于一个大于 $S$ 的集合，$O(N)$ 处理出其他所有集合和它的答案，那么复杂度为 $O(NS)$。总时间复杂度：$O((N+Q)S)$code CodeForces 348C Subset Sums题意有 $n$ 个元素，第 $i$ 个元素的值为 $a[i]$ ；有 $m$ 个集合，每个集合存有若干个元素的下标（一个元素可能在多个集合出现）。$q$ 次操作，1. 询问某个集合元素值的总和；2. 第 $k$ 个集合内所有元素的值加上 $x$。题解按照集合的大小以 $S=√N$ 分类，预处理大于 $S$ 的集合内元素值的总和以及大集合之间重合的元素的个数，修改时用lazy标记记录；查询根据lazy标记集合之间重合元素个数转移来求得。对于小于 $S$ 的集合的操作暴力计算或者和上述做法类似。总时间复杂度：$O(QS)$code CodeForces 398D Instant Messanger题意作为一个聊天房间的管理员，需要支持用户登录，退出，添加朋友，删除朋友，统计在线朋友的数量这四种操作。题解对用户的朋友数量动态分割，不再按照某一个固定的值来分隔。对于比当前用户朋友数少的用户用数组维护个数，比当前多的用户遍历统计。code CodeForces 576C Points on Plane题意给出 $n$ 个点，要求排序后，相邻两点的曼哈顿距离之和小于等于 $2.5×10^9$。题解按照 $x$ 坐标每1000长度分块，块内按照 $y$ 坐标排序，那么可以构造出距离上限是 $2×10^9$ 的方案，满足题意。code 对询问平方分割莫队算法用到了分块的思想，一般是给 $Q$ 个区间 $[l,r]$ 来进行的一些操作和询问。将序列分成 $√N$ 块，每块的大小为 $√N$ 。离线处理 $Q$ 个区间：首先对左端点 $l$ 所在的块号从小到大排序，如果块号相同则按右端点 $r$ 从小到大排序。然后用双指针移动到当前区间位置，每次移动更新对结果的贡献。 1234567for (int i=1; i&lt;=Q; ++i) &#123; while (L &lt; q[i].l) sub(L++); //删除 while (L &gt; q[i].l) add(--L); //增加 while (R &lt; q[i].r) add(++R); while (R &gt; q[i].r) sub(R--); ans[q[i].id] = sum; //答案&#125; CF 86D Powerful array CodeForces 351D Jeff and Removing Periods 莫队HDU 4638 Group 莫队CodeForces 103D Time to Raid Cowavans 莫队CodeForces 375D Tree and Queries 莫队CodeForces 617E XOR and Favorite Number 莫队SPOJ DQUERY D-query 莫队CodeChef GERALD07 Chef and Graph Queries 莫队，并查集，LCTCodeChef IITI15 Sherlock and Inversions 莫队，区间逆序对","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"}]},{"title":"精选优秀软件","slug":"精选优秀软件","date":"2017-05-13T13:09:41.000Z","updated":"2017-07-15T03:29:15.723Z","comments":true,"path":"2017/05/13/精选优秀软件/","link":"","permalink":"https://sea96.github.io/2017/05/13/精选优秀软件/","excerpt":"","text":"网络浏览器 Google Chrome 最好用的浏览器 翻墙软件 赛风 免费翻墙软件 加速精灵 限时免费 下载软件 IDM 支持HTTP、HTTPS、FTP等协议 破解工具 笔记软件 myBase 一款用于分类管理自由格式资料的数据库软件 编程软件 Code::Blocks 开放源码的全功能的跨平台C/C++集成开发环境 Eclipse 开放源代码的、基于Java的可扩展开发平台 IntelliJ IDEA 在业界被公认为最好的java开发工具之一 Sublime Text 神级代码编辑器 gVim 编辑器之神 Typora 极致简洁的Markdown编辑器","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://sea96.github.io/categories/开发工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://sea96.github.io/tags/工具/"}]},{"title":"快速傅里叶变换","slug":"快速傅里叶变换","date":"2017-05-13T00:59:46.000Z","updated":"2017-06-14T03:38:54.334Z","comments":true,"path":"2017/05/13/快速傅里叶变换/","link":"","permalink":"https://sea96.github.io/2017/05/13/快速傅里叶变换/","excerpt":"","text":"","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://sea96.github.io/tags/数学/"}]},{"title":"后缀数组","slug":"后缀数组","date":"2017-05-05T09:05:53.000Z","updated":"2017-07-15T03:21:27.346Z","comments":true,"path":"2017/05/05/后缀数组/","link":"","permalink":"https://sea96.github.io/2017/05/05/后缀数组/","excerpt":"","text":"后缀数组是处理字符串的有力工具。后缀数组是后缀树的一个非常精巧的替代品，它比后缀树容易编程实现，能够实现后缀树的很多功能，而时间复杂度也并不逊色，而且它比后缀树所占用的内存空间小很多。 概念 后缀：设一个字符串为S[0 ~ |S|-1]，后缀i表示S[i ~ |S|-1]。举例：有一个字符串BANANA，后缀3就是ANA。 后缀数组：后缀数组sa保存的是所有后缀按字典序从小到大排序的结果（在字符串S的下标）。 举例：BANANA的后缀数组sa[]={5,3,1,0,4,2}，更详细点就是后缀5（A），后缀3（ANA），后缀1（ANANA）。。。 名次数组：名次数组rank[i]表示++后缀i在后缀数组里的名次（在sa数组的下标）。++ 容易看出，后缀数组和名次数组为互逆运算。举例：一个字符串BANANA，rank[3]（后缀3为ANA）等于1（结合上文），逆运算：sa[1]=3。 高度数组：高度数组height[i]表示sa[i]和sa[i-1]的LCP（最长公共前缀）。 求法后缀数组 DA算法：倍增思想+基数排序（双关键字排序），复杂度 $O(nlogn)$ 12345678910111213141516171819202122232425void build_sa(int m = 128) &#123; int i, j, p, *x = tmp_one, *y = tmp_two; //对于单字符S[i~i]的基数排序 for (i=0; i&lt;m; ++i) c[i] = 0; for (i=0; i&lt;n; ++i) c[x[i]=s[i]]++; for (i=1; i&lt;m; ++i) c[i] += c[i-1]; for (i=n-1; i&gt;=0; --i) sa[--c[x[i]]] = i; //对于长度j，关键字为(S[i~(i+j-1)],S[(i+j)~(i+j+j-1)])进行基数排序 for (j=1, p=0; j&lt;=n; j&lt;&lt;=1) &#123; //直接利用sa数组排序第二关键字 for (p=0, i=n-j; i&lt;n; ++i) y[p++] = i; for (i=0; i&lt;n; ++i) if (sa[i] &gt;= j) y[p++] = sa[i] - j; //基数排序第一关键字 for (i=0; i&lt;m; ++i) c[i] = 0; for (i=0; i&lt;n; ++i) c[x[y[i]]]++; for (i=1; i&lt;m; ++i) c[i] += c[i-1]; for (i=n-1; i&gt;=0; --i) sa[--c[x[y[i]]]] = y[i]; swap(x, y); //根据sa和y数组计算新的x数组 for (p=1, x[sa[0]]=0, i=1; i&lt;n; ++i) &#123; x[sa[i]] = (y[sa[i-1]] == y[sa[i]] &amp;&amp; y[sa[i-1]+j] == y[sa[i]+j] ? p-1 : p++); &#125; if ((m=p) &gt;= n) break; &#125;&#125; 代码解释：参数m表示不同字符的个数（会增大），数组s是字符串转换成数字数组。用到三个辅助数组，x数组记录当前长度j下后缀i的排名，y数组记录第二关键字排序的结果，c数组用来计数和定位。 DC3算法 时间复杂度 $O(n)$ 代码链接 参考资料 后缀数组（入门经典学习笔记） 数据结构之后缀数组 后缀数组(suffix array)详解 后缀数组的应用单个字符串的相关问题连续重复子串POJ 3693 Maximum repetition substring给定一个字符串，求重复次数最多的连续重复子串。枚举长度 $L$，将字符串按照长度 $L$ 分块。记重复子串为$S$，$S$一定包括字符 $s[0]$，$s[L]$，$s[2L]$，… 中的某相邻两个。所以枚举两个相邻的点，往前和往后分别匹配到多远，设总长度为 $K$，那么连续出现 $K/L+1$ 次。最后求最大值即可。总时间复杂度：$O(NlogN)$","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://sea96.github.io/tags/字符串/"}]},{"title":"单调栈","slug":"单调栈","date":"2017-04-20T11:05:29.000Z","updated":"2017-06-14T03:39:21.718Z","comments":true,"path":"2017/04/20/单调栈/","link":"","permalink":"https://sea96.github.io/2017/04/20/单调栈/","excerpt":"","text":"定义 单调递减栈：元素从栈顶到栈底单调递减的栈 单调递减栈：元素从栈顶到栈底单调递减的栈 应用单调栈最常用的功能是可以求出一个元素向左（或向右）所能扩展到的最大长度，并不是说在这一段区间内是单调的，而是保证在该区间内该元素一定是最大或最小。 题目POJ 3250 Bad Hair Day题意有$n$个人，问每一个人向右看能看到人的数量的总和（能看到的人身高比当前的人矮）。 题解从后往前，维护一个单调递减栈来求每一个人右边的高度比它小的最近的位置即可。code POJ 2796 Feel Good题意有$n$个元素，问一个区间长度乘以区间最小值的最大值。 题解也就是求每一个元素往左（右）值比它小的最近的位置。维护两次单调递减栈。code SCU 1773 Largest Rectangle in a Histogram题意给$n$个宽度为1的矩形，求最大连续矩形面积。 题解矩形的面积等于区间长度乘以区间最小高度，做法和POJ 2796一样。","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"}]},{"title":"初等数论","slug":"初等数论","date":"2017-04-09T01:37:58.000Z","updated":"2017-08-16T11:56:29.050Z","comments":true,"path":"2017/04/09/初等数论/","link":"","permalink":"https://sea96.github.io/2017/04/09/初等数论/","excerpt":"","text":"素数运算 素数的定义质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个因数的数） 素数的性质和定理 欧拉证明：素数在数量上是无限的（不存在最大的素数） 存在任意长的一段连续数，其中的所有数都是合数（相邻素数之间的间隔任意大） 所有大于2的素数都可以唯一地表示成两个平方数之差。 当$n$为大于2的整数时，$2^n+1$和$2^n-1$两个数中，如果其中一个数是素数，那么另一个数一定是合数。 哥德巴赫猜想：每个大于4的偶数可以写成两个奇素数的和（陈景润证明：偶数为一个素数及一个不超过两个素数的乘积之和，简称“1+2”） 唯一分解定理：每个正整数都可以唯一地表示成素数的乘积，即有唯一的分解质因数的方案：$n=p_1^{e_1}p_2^{e_2}…p_k^{e_k}$根据上面的式子，可以推知$n$共有 $(e_{1}+1)(e_{2}+1)…(e_{k}+1)$个约数。 素数的判定试除法试用2…$\\lfloor \\sqrt{n} \\rfloor$去除$n$（更好的做法是筛选出[2..$\\sqrt{n}$]里的所有素数），$n$是素数当且仅当没有一个试用的除数能被$n$整除。时间复杂度：$O(\\sqrt{n})$ Miller_Rabin方法米勒-拉宾素性检验是一种素数判定法则，利用随机化算法判断一个数是合数还是可能是素数。测试大素数的Miller_Rabin方法基于下述定理： 费马小定理：如果$n$是素数，$a$是整数，则 $a^n \\equiv a\\pmod{n}$如果 $a$ 不是 $n$ 的倍数，也可以写成 $a^{n-1} \\equiv 1\\pmod{n}$ 二次探测定理：如果$n$是奇素数，则$a^2 ≡ 1\\pmod n$的解为$a ≡ 1\\pmod n$或$a ≡ n-1\\pmod n$ 重复$k$次计算，每次在$[1,n-1]$范围内随机选取一个$a$，若$a^{n-1} \\neq 1\\pmod{n}$，则$n$是合数。若随机选取的$k$个$a$都使得$a^{n-1} \\equiv 1\\pmod{n}$，则$n$是素数或伪素数。若使用模指数运算的快速算法，这个算法的运行时间是：$O(klog_{2}^3n)$经验结论： if n &lt; 3,215,031,751, it is enough to test a = 2, 3, 5, and 7; if n &lt; 4,759,123,141, it is enough to test a = 2, 7, and 61; if n &lt; 18,446,744,073,709,551,616 = $2^{64}$, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37. if n &lt; 318,665,857,834,031,151,167,461, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37. if n &lt; 3,317,044,064,679,887,385,961,981, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, and 41. 素数的筛法筛选[2..$n$]中的所有素数 埃拉托斯特尼筛法按递增顺序搜索筛中的最小数，将其倍数从筛中筛去，最终筛中留下的数即为素数。时间复杂度：$O(nloglogn)$ 欧拉筛法在埃式筛法上改进：每个合数仅被它最小的质因数筛去。时间复杂度：$O(n)$此方法可以求积性函数$f(x)$，即在$O(n)$时间复杂度内预处理$f(1)$,$f(2)$ … $f(n)$的值，典型的用途是求欧拉函数。 公约数问题 最大公约数和最小公倍数若$x=p_1^{k_1}p_2^{k_2}…p_r^{k_r}$$y=p_1^{n_1}p_2^{n_2}…p_r^{n_r}$则$GCD(x,y)=p_1^{min(k_1,n_1)}p_2^{min(k_2,n_2)}…p_r^{min(k_r,n_r)}$$LCM(x,y)=p_1^{max(k_1,n_1)}p_2^{max(k_2,n_2)}…p_r^{max(k_r,n_r)}$同时可以得到$x×y=GCD(x,y)×LCM(x,y)$ 若$x=p×GCD(x,y)$$y=q×GCD(x,y)$则$x+y=(p+q)×GCD(x,y)$那么 $GCD(x,y)=GCD(x,x+y)$同理可得 $GCD(x,y)=GCD(x+y,LCM(x,y))$ 欧几里得算法$$GCD(a,b)=\\begin{cases}b&amp; \\text{a = 0}\\\\GCD(b,a\\mod b)&amp; \\text{a $\\neq$ 0}\\end{cases}$$简单证明：设$g=GCD(a,b)$将$a \\mod b$化成$a$与$b$的线性组合，即$a \\mod b=a-\\lfloor{\\frac{a}{b}}\\rfloor *b$。由于$g$能整除$a$和$b$，那么$g$一定能整除$a$与$b$的线性组合，即$g$能整除$(a \\% b)$，所以$GCD(a,b)=GCD(b,a\\% b)$.时间复杂度：$O(log \\max(a,b))$ 扩展欧几里得算法已知整数$a$、$b$，扩展欧几里得算法可以在求得$a$、$b$的最大公约数的同时，能找到整数$x$、$y$（其中一个很可能是负数）满足$ax+by=GCD(a,b)$.若$b=0$，则$GCD(a,b)=a$，$x=1$，$y=0$；若$b\\neq 0$，首先递归求解满足$bx’+(a\\mod b)y’=GCD(b,a\\mod b)$的$x’$、$y’$，因为$GCD(a,b)=GCD(b,a\\% b)$，所以有以下等式成立：$$bx’+(a- \\lfloor{\\frac{a}{b}}\\rfloor b)y’=ay’+b(x’- \\lfloor{\\frac{a}{b}}\\rfloor y’)=ax+by$$选择$x=y’$，$y=x’- \\lfloor{\\frac{a}{b}}\\rfloor y’$就可以满足等式。 应用扩展欧几里得算法，可以求解如下形式的二元一次不定方程：$$ax+by=c$$首先先求解$ax+by=GCD(a,b)$的$x$和$y$，记$g=GCD(a,b)$.若$c$不能被$g$整除，则无整数解；否则初始解：$x_{0}=x\\frac{c}{g}$，$y_{0}=y\\frac{c}{g}$.不定方程的通解形式为：$$\\begin{cases}x_{k}=x_{0}+k\\frac{b}{g} &amp; \\\\y_{k}=y_{0}-k\\frac{a}{g} &amp; \\text{k $\\in $ Z}\\end{cases}$$ 同余问题同余关系式 威尔逊定理：$(p-1)! \\equiv -1 ({\\mbox{mod}} p)$ 费马小定理：${\\displaystyle a^{p}\\equiv a{\\pmod {p}}}$ 欧拉定理：$a^{\\varphi (n)}\\equiv 1{\\pmod {n}}$ 卡迈克尔函数：$a^{\\lambda (n)}\\equiv 1{\\pmod {n}}$ 阶乘幂：$(x)_{k}\\equiv x(x-1)(x-2)\\cdots (x-k+1)\\equiv 0{\\pmod {k!}}$ 其它定理 若 $ac\\equiv bc\\pmod n$ 且 $GCD(c,n)=d$，则$a \\equiv b \\pmod{ \\frac {n}{d}}$ 若 $d \\neq 0$ 且 $ad \\equiv bd \\pmod {nd}$，则 $a \\equiv b \\pmod n$ 若 $n$ 和 $a$ 互质，则一次同余方程 $ax+b\\equiv 0 \\pmod n$ 有解模运算满足交换律（除了除法） 同余方程 求解一次同余方程 $ax\\equiv b\\pmod n$也就是要求解二元一次方程 $ax-my=b$，使用扩展欧几里得算法求解。令 $g=GCD(a,m)$，如果$b$不能被$g$整除，那么同余方程无解；否则有$g$个解，即$x_k=x_0+k \\frac{m}{g}(0\\leq k &lt; g)$ 求解同余方程 $a^x\\equiv b\\pmod n$ 求解一元线性同余方程组$$ \\begin{cases} x≡a_1 \\pmod {m_1} &amp; \\\\x≡a_2 \\pmod {m_2} &amp; \\... \\ x≡a_n \\pmod {m_n} &amp;\\\\\\end{cases} $$ 中国剩余定理 若$m_1$、$m_2$ …. $m_n$ 两两互质，则对任意整数 $a_1$、$a_2$ …. $a_n$ 方程组有解。令$M=m_1m_2m_3…m_n$$w_i=\\frac{M}{m_i}$$w_i’$ 为 $w_i$ 模 $m_i$ 下的逆元，即 $w_iw_i’≡1 \\pmod {m_i}$则$x=(a_1w_1w_1’+a_2w_2w_2’+…+a_nw_nw_n’) \\pmod M$ 模逆元在求解除法取模问题 $(a / b) \\% n$ 时，我们可以转化为 $(a \\% (b \\cdot n))/b$。但是 $b$ 范围很大时，$bn$ 可能存不下，所以我们使用乘法逆元将除法转换为乘法。在模 $n$ 的意义下，把 $a$ 的模逆元写作 $a^{-1}$，满足$aa^{-1}\\equiv 1{\\pmod {n}}$，那么 $\\frac {a}{b}=ab^{-1} \\pmod n$*$a$ 对模数 $n$ 之模逆元存在的充分必要条件是 $a$ 和 $n$ 互质。求解模逆元的几种方法： 使用扩展欧几里得算法求解 $ax \\equiv 1 \\pmod n$，即 $ax-ny=1$。若 $g=GCD(a,n)=1$，该模逆元存在，且有无穷个解，选取最小正整数解即可。 使用欧拉定理当 $a$ 和 $n$ 互质时，有 $a^{\\varphi (n)}\\equiv 1{\\pmod n}$。那么分解为 $a^{\\varphi (n)}=a\\cdot a^{\\varphi (n)-1}\\equiv 1{\\pmod {n}}$，其中的 $a^{\\varphi (n)-1}$ 即为 $a$ 关于模 $n$ 之模逆元。特别地，若 $n$ 为素数时，$a$ 的模逆元为 $a^{n-2}$（费马小定理） 使用线性递推法$n$为奇素数时，记 $i$ 的逆元为 $inv[i]$，有递推式：$$ inv[i]=\\begin{cases}1&amp; \\text{i = 1}\\(n-\\frac{n}{i}) \\cdot inv[n \\% i]\\% n &amp; \\text{i $&gt;$ 1}\\end{cases} $$证明（略，公式移项）此方法以在 $O(n)$ 时间复杂度求解小于 $n$ 的所有模逆元。 Lucas定理 在数论中，Lucas定理用于计算二项式系数 $\\tbinom {m}{n}$ 被质数 $p$ 除的所得的余数。 公式对于非负整数m和n和素数p，同余式：$$ \\binom {m}{n}\\equiv \\prod _{i=0}^{k}{\\binom {m_{i}}{n_{i}}}{\\pmod {p}} $$成立。其中：$$ m=m_{k}p^{k}+m_{k-1}p^{k-1}+\\cdots +m_{1}p+m_{0}$$,并且$$ n=n_{k}p^{k}+n_{k-1}p^{k-1}+\\cdots +n_{1}p+n_{0} $$是 $m$ 和 $n$ 的 $p$ 进制展开。当 $m$ &lt; $n$ 时，二项式系数 $\\tbinom {m}{n}=0$。 证明略，详见参考资料。 扩展如果 $p$ 不是质数，对其进行质因子分解，然后对于每个质因子 $p_{i}^{e_{i}}$ 都得到一个同余方程 $x≡a_{i}(\\mod p_{i}^{e_{i}})$，然后用中国剩余定理。 链接link1link2link3link4 积性函数在数论中，积性函数是指一个定义域为正整数 $n$ 的算术函数 $f(n)$，有如下性质：$f(1) = 1$，且当 $a$ 和 $b$ 互质时，$f(ab) = f(a) f(b)$若对于任意两个正整数 $a$ 和 $b$ ，都有 $f(ab)=f(a)f(b)$，则称此函数 $f$ 为完全积性函数。显然，对于任意积性函数，$f(1)=1$$GCD(a,b)$ 也是积性函数（当一个数字固定的情况下） 欧拉函数定义欧拉函数$φ(n)$，表示小于等于 $n$ 且与 $n$ 互质的正整数的个数。例如：$φ(1)=φ(2)=1$，$φ(3)=φ(4)=2$欧拉函数是积性函数，即当 $n$、$m$ 互质时，$φ(nm)=φ(n)φ(m)$。但不是完全积性函数。 欧拉函数的值 当 $n$ 是素数时，$φ(n)=n-1$ 当 $n$ 是合数时，$φ(n)&lt;n-1$，且 $φ(n) \\leq n- \\sqrt n$ 若 $n$ 是素数 $p$ 的 $k$ 次幂，$φ(n)=φ(p^{k})=p^{k}-p^{k-1}=(p-1)p^{k-1}$，因为除了 $p$ 的倍数外，其他数都跟 $n$ 互质。 一般地，设 $n=p_1^{k_1}p_2^{k_2}…p_r^{k_r}$则$$φ(n)=\\prod_{i=1}^{r}p_{i}^{k_{i}-1}(p_{i}-1)=n \\prod_{p|n} \\left(1-{\\frac {1}{p}} \\right)$$ 欧拉定理若两个正整数 $n$ 和 $a$ 互质，则 $a^{φ(n)} \\equiv 1 \\pmod n$推论：$a^{φ(n)+1} \\equiv a \\pmod n$欧拉定理的一个特例是费马小定理（若 $n$ 是素数，则 $φ(n)=n-1$）。 欧拉函数的性质 $n$ 的欧拉函数 $\\varphi (n)$ 也是循环群 $C_n$ 的生成元的个数，即$$ \\sum_{d \\mid n} \\varphi (d)=n $$其中的 $d$ 为 $n$ 的正约数。运用莫比乌斯反演来“翻转”这个和，就可以得到另一个关于 $\\varphi (n)$ 的公式：$$ \\varphi (n)=\\sum _{d \\mid n} {d\\cdot \\mu (n/d)}$$其中 $μ$ 是所谓的莫比乌斯函数，定义在正整数上。 当 $n&gt;1$ 时，$1…n$ 中与 $n$ 互质的整数和为 $\\frac{n\\varphi (n)}{2}$ 当 $n$ 为奇数时，有 $\\varphi (2n)= \\varphi (n)$ 莫比乌斯函数定义莫比乌斯函数$μ(n)$，表示非平方数 $n$ 的质因子个数，$μ(n)$ 是 $φ(n)$ 的反演函数。 参考资料 Matrix67 Blog维基百科 质数维基百科 辗转相除法维基百科 扩展欧几里得算法模逆元维基魔杖 卢卡斯定理维基百科 同余维基百科 积性函数","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://sea96.github.io/tags/数论/"}]},{"title":"最长公共子序列","slug":"最长公共子序列","date":"2017-02-27T06:38:08.000Z","updated":"2017-06-14T03:38:37.359Z","comments":true,"path":"2017/02/27/最长公共子序列/","link":"","permalink":"https://sea96.github.io/2017/02/27/最长公共子序列/","excerpt":"","text":"问题描述求两个字符串的最长公共子序列（Longest Common Subsequence ( LCS )）。 算法分别记两个字符串为$S_1$和$S_2$，它们的最长公共子序列为$LCS(S_1,S_2)$。 朴素的做法枚举出$S_1$所有的子序列和$S_2$比较，时间复杂度：$O(2^{|S_1|}|S_2|)$。 动态规划的做法记$S_1$和$S_2$最后的字符分别是$S_1$和$S_2$，即：$$S_1=S_1’+e_1$$ $$S_2=S_2’+e_2$$有四种情况： $LCS$包含$e_1$ 不含$e_2$ $LCS$包含$e_2$ 不含$e_1$ $LCS$不含$e_1$，$e_2$ $LCS$包含$e_1$，$e_2$ 对于第一种情况，$e_2$没有用处，$LCS(S_1,S_2)=LCS(S_1,S_2’)$。对于第二种同理，$LCS(S_1,S_2)=LCS(S_1’,S_2)$对于第三种同理，$LCS(S_1,S_2)=LCS(S_1’,S_2’)$对于第四种同理，$LCS(S_1,S_2)=LCS(S_1’,S_2’)+e_1$如果使用非递归的做法，要保存前缀串的$LCS$，可以用动态规划实现。定义$dp[i][j]$表示$S_1$的前$i$个字符和$S_2$的前$j$个字符的$LCS$的长度，状态转移方程：$$dp[i][j]=max \\left \\{ dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1 (S_{1_{i}}=S_{2_{j}}) \\right \\}$$如果要求得到一个最长公共子序列，用一个二维数组记录状态是从哪一个转移来的即可，递归打印。时间复杂度：$O(|S_1||S_2|)$ 优化如果用滚动数组优化，空间复杂度降至：$O(2|S|)$ 基于位运算的算法压位最长公共子序列（论文，代码） Hunt-Szymanski Algorithm转换为二维LIS问题 从两序列中找出对应的相同元素，以位置数对表示。这些位置数对可以排出的最长严格递增序列，即是两序列的$LCS $。首先將所有数对排序，规则是第一个维度由小到大排序，当第一个维度相等时，第二个維度由大到小排序。排序之后，第二个维度的$1D$ $LIS$，就对应到原数对们的$2D$ $LIS$。 记数对的总数目为$K$，时间复杂度：$O(Klog |S|)$如果出现类似于：$S_1=aaaa$，$S_2=aaaaaa$，时间复杂度退化成：$O(|S|^2log |S|)$ 代码12345678//DPfor (int i=1; i&lt;=n; ++i) &#123; now ^= 1; for (int j=1; j&lt;=m; ++j) &#123; dp[now][j] = max(dp[now^1][j], dp[now][j-1]); if (s[i] == t[j]) dp[now][j] = max(dp[now][j], dp[now^1][j-1]+1); &#125;&#125; //lcs = dp[now][m]; 123456789101112131415161718//2D LISint LCS(char *s, char &amp;t) &#123; int n = strlen(s+1), m = strlen(t+1); vector&lt;int&gt; pos[128]; for (int i=1; i&lt;=m; ++i) &#123; pos[t[i]].push_back(i); &#125; vector&lt;int&gt; lcs; for (int i=1; i&lt;=n; ++i) &#123; for (int j=(int)pos[s[i]].size()-1; j&gt;=0; --j) &#123; int p = pos[s[i]][j]; if (lcs.empty()) lcs.push_back(p); else if (p &gt; lcs.back()) lcs.push_back(p); else *lower_bound(lcs.begin(), lcs.end(), p) = p; &#125; &#125; return lcs.size();&#125; 习题UVA 111（简单题）POJ 2250（打印LCS）POJ 1159（滚动数组优化）UVA 10635 UVA 10949（2D LIS）玲珑学院OJ 1097 （2D LIS） 拓展最长公共上升子序列最长回文子序列最长公共子串 参考资料演算法笔记 - Longest Common Subsequence","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"LCS","slug":"LCS","permalink":"https://sea96.github.io/tags/LCS/"}]},{"title":"动态规划的各种类型","slug":"动态规划的各种类型","date":"2017-02-27T06:22:00.000Z","updated":"2017-06-15T13:57:39.107Z","comments":true,"path":"2017/02/27/动态规划的各种类型/","link":"","permalink":"https://sea96.github.io/2017/02/27/动态规划的各种类型/","excerpt":"","text":"子序列DP最长公共子序列http://m.blog.csdn.net/article/details?id=6918848 树形DP区间DP状压DP概率DP数位DP 在信息学竞赛中，有一类与数位有关的区间统计问题。这类问题往往具有比较浓厚的数学味道，无法暴力求解，需要在数位上进行递推等操作。在信息学竞赛中，有这样一类问题：求给定区间中，满足给定条件的某个 $D$ 进制数或此类数的数量。所求的限定条件往往与数位有关，例如数位之和、指定数码个数、数的大小顺序分组等等。题目给定的区间往往很大，无法采用朴素的方法求解。此时，我们就需要利用数位的性质，设计 $log(n)$ 级别复杂度的算法。解决这类问题最基本的思想就是逐位确定的方法。 HDOJ 4722 Good Numbers题意如果一个数字的每个数位和能被10整除，那么它是good number，问 $[A,B]$ 区间里good number的数量。数据$0 \\leq A,B \\leq 10^{18}$题解$dp[pos][mod]$表示前 $pos$ 位，数位和取模10为 $mod$ ，后面数字任意且满足总数位和取模10为0的数量。记忆化深搜，基础入门题。code HDOJ 5642 King’s Order题意问长度为 $n$ 的字符串，由26个小写字母组成，满足相同的字母相邻出现不超过3个，问满足条件的方案数（mod 1000000007）。数据$0 \\leq n \\leq 2×10^{3}$题解$dp[pos][pre][mod]$表示前 $pos$ 位，当前位的字母是 $pre$，相同出现的个数为 $cnt$ 的方案数。code URAL 1057 Amount of Degrees题意求给定区间 $[X,Y]$ 中满足下列条件的整数个数：这个数恰好等于 $K$ 个互不相等的 $B$ 的整数次幂之和。数据$1 ≤ X ≤ Y ≤ 2^{31}−1$，$1 ≤ K ≤ 20$， $2 ≤ B ≤ 10$题解所求的数为互不相等的幂之和，亦即其 $B$ 进制表示的各位数字都只能是 $0$ 和 $1$。因此，我们只需讨论二进制的情况，其他进制都可以转化为二进制求解。那么问题和上题几乎一样，$dp[pos][mod]$表示前 $pos$ 位，相同出现 $1$ 的个数为 $cnt$ 的方案数。code SPOJ SQRTBIT Sorted bit squence题意将区间 $[m,n]$ 内的所有整数按照其二进制表示中 $1$ 的数量从小到大排序。如果 $1$ 的数量相同，则按照数的大小排序。求这个序列中的第 $k$ 个数。数据$m × n ≥ 0$， $-2^{31} ≤ m ≤ n ≤ 2^{31}-1$，$1 ≤ k ≤ min(n − m + 1, 2147473547)$题解我们首先考虑 $m,n&gt;0$ 的情况。由于排序的第一关键字是 $1$ 的数量，第二关键字是数的大小，因此我们很容易确定答案中 $1$ 的个数：依次统计区间 $[m,n]$ 内二进制表示中含 $1$ 的数量为$0,1,2,…$的数，直到累加的答案超过 $k$ ，则当前值就是答案含 $1$ 的个数，假设是 $s$ 。利用上题的方法处理。同时，我们也求出了答案是第几个 $[m,n]$ 中含 $s$ 个 $1$ 的数。因此，只需二分答案，求出$[m,ans]$ 中含 $s$ 个 $1$ 的数的个数进行判断即可。$m&lt;0$的情况也不难处理，直接将负数视为32位无符号数（或者直接使用 long long 数据类型），采用同正数一样的处理方法（需特殊处理$n=0$ 的情况）。code SPOJ BIGSEQ Sequence题意给定所有 $K$ 位二进制数：$0,1,…,2^{K}-1$。你需要将它们分成恰好 $M$ 组，每组都是原序列中连续的一些数。设 $S_i$($1 ≤ i ≤ M$)表示第 $i$ 组中所有数的二进制表示中 $1$ 的个数，$S$ 等于所有$S_i$中的最大值。你的任务是令 $S$ 最小。数据$1 ≤ K ≤ 100$, $1 ≤ M ≤ 100$, $M ≤ 2^K$题解代码解释：$d[i]=2^i$，$f[i]$ 表示高度为i的左子树中所有数的二进制表示中 $1$ 的个数（叶子结点高度为0）。code 背包DP动态规划总结与题目分类","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"}]},{"title":"动态规划的各种优化","slug":"动态规划的各种优化","date":"2017-02-25T07:03:05.000Z","updated":"2017-06-14T03:39:07.520Z","comments":true,"path":"2017/02/25/动态规划的各种优化/","link":"","permalink":"https://sea96.github.io/2017/02/25/动态规划的各种优化/","excerpt":"","text":"用单调性优化动态规划 单调性优化Vijos 1243 生产产品题意：产品的生产需要$m(\\leq 10^5)$个步骤，每个步骤可以在$n(\\leq 5)$个机器中任何一台完成，机器$i$完成第$j$个步骤的时间为$a_{i,j}$。把半成品从一台机器上搬到另一台机器上也需要一定的时间$k$，每台机器最多只能连续完成产品的$l(\\leq 5*10^4)$个步骤，问最短需要多长时间。 题解：朴素的动态规划的算法：定义$dp[i][j]$表示前i个步骤，最后一段步骤用第$j$个机器完成，$sum[i][j]$表示前$i$个步骤用第$j$个机器完成的时间。状态转移方程：$$dp[i][j]=min\\left \\{ dp[t][p]+(sum[i][j]-sum[t][j])+k \\right \\},(j\\neq p,i-t\\leq l)$$时间复杂度：$O(n^2ml)$。把方程式变形得：$$dp[i][j]=min\\left \\{ dp[t][p]-sum[t][j] \\right \\}+sum[i][j]+k,(j\\neq p,i-t\\leq l)$$发现括号内的式子是根据$t$决定的（枚举$p$和$j$），所以可以用单调队列维护一个单调递增的序列进行优化，时间复杂度：$O(n^2m)$。code POJ 3017 Cut the Sequence题意：给定一个有$n$个非负整数的数列$a(a_i\\leq 10^5)$，要求将其划分为若干个部分，使得每部分的和不超过给定的常数$m$，并且所有部分的最大值的和最小。 题解：朴素的动态规划的算法：定义$dp[i]$表示前$i$个数字划分后所有部分最大值的和，$m(l,r)$表示区间$[l,r]$的最大值，$sum(l,r)$表示区间$[l,r]$的和，状态转移方程：$$dp[i]=min\\left \\{ dp[t]+m(t+1,i) \\right \\},sum(t+1,i)\\leq m$$因为是非负整数，dp的值显然是递增的，但是并没有可维护单调的序列，决策点也没有单调性，需要挖掘出单调性，引用kuangbin的做法： 首先假如不考虑m的限制，那么最优决策的$j$点，一定满足$a[j] &gt; max(a[j+1~i])$就是$j$点的值要大于$j+1$到$j$点的值。很明显的结论，因为假如不成立，那么可以把$j$点也划分到后面去，得到更优的所以用单调队列维护一个递减数列，这样的话最优决策点只能出现在这些点中。现在加了$m$的限制，假如上面那个递减数列只有后面一部分是满足$m$限制的。那么决策点就是上面这些点再加上满足$m$条件的那个边界，所以可以用平衡二叉树维护二叉树里面的值只要随着队列进行维护就好了，可以用multiset实现。 code 斜率优化BZOJ 1010 玩具装箱toy题意：$n$个玩具装到若干个容器内，问制作容器费用的最小值。题解：一份写的不错的题解 这里面详细的证明了决策点的单调性，在这前提下利用斜率的单调性，维护单调队列，侧重于“数”。 POJ 1180 Batch Scheduling（批量任务）题意：有$n(n\\leq 10^4)$个任务，要求依次执行，从时刻$0$开始，任务被分批加工。在每批任务开始前，机器需要启动时间$s$。每个任务有相应的执行时间T和影响因素F。一批任务完成时间就是各个任务的完成时间总和，每个任务完成的费用是任务完成时刻*该任务费用系数。确定一个方案使得总费用最小。 题解：这题要倒推，只有后面任务的分配确定后才有意义。$f(i)$表示完成$i$~$n$任务的最小费用，$T[i,j]$，$F[i,j]$分别表示完成任务$i$~任务$j$所需要的时间和费用。假设新增批次任务$i$~任务$j-1$，那么在$f(j)$的基础上，新增加的完成$i$~$j-1$任务的费用：$(s+T[i,j-1])F[i,j-1]$，延时造成的费用：$(s+T[i,j-1])F[i,j-1]$。所以$f(i)=min(f(j)+(s+T[i,j-1])*F[i,n])$，时间复杂度$O(n^2)$。 利用最优决策点的凸性优化（侧重“形”）：记$x(i)=T[i,n]，y(i)=f(i)，a[i]=s+T[i,n]，b[i]=F[i,n]$。上面的状态转移方程式等价于：$f(i)=min(y(j)+(a[i]-x[j])b[i])$，即$minp=f(i)=-b[i]x(j)+y(j)+a[i]b[i]$，即$y(j)=b[i]x(j)+(p-a[i]*b[i])$。随着$i$递减，$x(i)$递增，斜率$b[i]$递增，所以用单调队列维护一个下凸壳，时间复杂度降为$O(n)$。code HDOJ 5956 The Elder（长者的王国）题意：给出一个n个点的有根树，每条边上有权值，两个点的距离定义为路上边权和，给出另一个参数p。令$f_i=max(f_j+dis(i,j)^2+p)$，求f_i的最大值。 题解：树上的斜率优化DP，DFS遍历时，记录下当前单调队列的两个指针，以及队尾哪些被pop掉，递归结束后恢复即可。code 斜率单调暴力移指针斜率不单调二分找答案x坐标单调开单调队列x坐标不单调开平衡树|cdq分治 四边形不等式优化百度文库CSDNchino瀚清Aireen Ye 滚动数组优化（空间）二进制优化（时间）矩阵优化（时间）数据结构优化（时间）斜率优化四边形优化[dp优化]个人对dp优化的理解 夜深人静写算法（二） - 动态规划","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"}]}]}