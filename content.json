{"meta":{"title":"清逸","subtitle":null,"description":"知者不言，言者不知。","author":"清逸","url":"https://sea96.github.io"},"pages":[{"title":"关于","date":"2017-02-21T12:18:24.000Z","updated":"2017-05-13T14:13:27.187Z","comments":false,"path":"about/index.html","permalink":"https://sea96.github.io/about/index.html","excerpt":"","text":"欢迎访问我的博客"},{"title":"分类","date":"2017-02-21T12:16:31.000Z","updated":"2017-05-13T08:35:13.021Z","comments":false,"path":"categories/index.html","permalink":"https://sea96.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2017-02-21T12:08:14.000Z","updated":"2017-05-13T08:33:07.710Z","comments":false,"path":"tags/index.html","permalink":"https://sea96.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"精选优秀网站","slug":"精选优秀网站","date":"2017-06-14T03:42:02.000Z","updated":"2017-06-14T03:45:51.403Z","comments":true,"path":"2017/06/14/精选优秀网站/","link":"","permalink":"https://sea96.github.io/2017/06/14/精选优秀网站/","excerpt":"","text":"图片 别样图 无版权免费大尺寸图片共享平台 极简图床 不限流量，支持粘贴上传、拖放上传 FaceYourManga DIY头像","categories":[{"name":"日常生活","slug":"日常生活","permalink":"https://sea96.github.io/categories/日常生活/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://sea96.github.io/tags/工具/"}]},{"title":"HDOJ 5644 King's Pilots","slug":"HDOJ-5644-King-s-Pilots","date":"2017-06-13T12:12:24.000Z","updated":"2017-06-13T14:09:48.284Z","comments":true,"path":"2017/06/13/HDOJ-5644-King-s-Pilots/","link":"","permalink":"https://sea96.github.io/2017/06/13/HDOJ-5644-King-s-Pilots/","excerpt":"","text":"题意国王阅兵式会持续 $n$ 天，每天都有一场飞机表演，第 $i$ 天的飞行表演需要 $P_i$ 个飞行员。由于每个飞行员都不愿意无偿的连续工作，这个国家出台了 $m$ 个休假办法，当某个飞行员当天工作后，如果支付他 $S_j$ 的酬劳，他会在上次工作 $T_j$ 天后重新回来工作 ($1\\le j\\le m$)。如果飞行员在第 $r$ 天工作且此时 $T_j = 1$，那么他会就在 $r+1$ 天继续工作。一开始有 $k$ 名飞行员，但当然还可以招募新的飞行员，但是，招募需要 $P$ 天的时间，并且招募来的每个飞行员需要支付 $Q$ 作为酬劳。(也就意味着到第 $P$ 天你才可能用到新招募来的飞行员) 。现在国王把安排飞行表演的任务交给了你，你需要合理的安排这次飞行表演使得每天的飞行员都是充足的，并且让总费用最低。最后请输出总费用。 补充说明：招募新的飞行员可以在第 $P$ 天之后的时间工作一天。 数据$ T \\le 5 $$ n \\le 200 $$ m \\le 5 $$ 0 \\le S_i, T_i \\le 200 $ 题解 首先忽略 $X_i$，$Y_i$ 向 $T$ 的流量表示第 $i$ 天有多少人参加表演（第2条）。$S$ 向 $Y_1$ 的流量表示有多少人可以参加第一天的表演（第3条），并且可以累积到后几天来参加表演（第6条）。$S$ 向 $Y_i$ 的流量表示招募得到的飞行员（第4条）。接下来考虑 $X_i$，$X_i$ 是用来解决休假问题的。$X_i$ 向 $Y_j$ 的流量表示到第 $i$ 天已完成表演的的飞行员休假后从第 $j$ 天开始可参加表演（第7条）。$S$ 向 $X_i$ 的流量保证了休假的飞行员一定是已参加过表演的（第1条），并且开始休假的时间可以是任意的（第5条）。 如果没有休假归来的话，就是简单的费用流。加上休假的设定使得情况复杂，而拆点能使得问题得到简化。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/************************************************* Author :RunningTime* Created Time :2017/6/13 19:17:11* File Name :HDOJ_5644.cpp ************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int N = 400 + 5;const int INF = 0x3f3f3f3f;const int MOD = 1e9 + 7;struct MinCostMaxFlow &#123; struct Edge &#123; int from, to; int cap, flow, cost; &#125;; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[N]; bool vis[N]; int p[N]; //上一条弧的序号 int d[N], a[N]; int n, m, s, t; void init(int n) &#123; this-&gt;n = n; for(int i=0; i&lt;=n; ++i) G[i].clear(); edges.clear(); &#125; void add_edge(int from, int to, int cap, int cost) &#123; edges.push_back((Edge)&#123;from, to, cap, 0, cost&#125;); edges.push_back((Edge)&#123;to, from, 0, 0, -cost&#125;); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool SPFA(int &amp;flow, int &amp;cost) &#123; fill(d, d+n+1, INF); memset(vis, false, sizeof(vis)); memset(p, -1, sizeof(p)); d[s] = 0; vis[s] = true; p[s] = 0; a[s] = INF; queue&lt;int&gt; que; que.push(s); while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i=0; i&lt;G[u].size(); ++i) &#123; Edge &amp;e = edges[G[u][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost) &#123; d[e.to] = d[u] + e.cost; p[e.to] = G[u][i]; a[e.to] = min(a[u], e.cap - e.flow); if (!vis[e.to]) &#123; vis[e.to] = true; que.push(e.to); &#125; &#125; &#125; &#125; if (d[t] == INF) &#123; return false; &#125; flow += a[t]; cost += d[t] * a[t]; int u = t; while (u != s) &#123; edges[p[u]].flow += a[t]; edges[p[u]^1].flow -= a[t]; u = edges[p[u]].from; &#125; return true; &#125; void run(int s, int t, int &amp;flow, int &amp;cost) &#123; this-&gt;s = s; this-&gt;t = t; flow = cost = 0; while (SPFA(flow, cost)); &#125; &#125;mcmf;int n, k, m, P, Q;int S, T;int p[205];int all;int s[10], t[10];bool solve() &#123; int flow, cost; mcmf.run(S, T, flow, cost); if (flow != all) return false; printf(\"%d\\n\", cost); return true;&#125;int main() &#123; int Test; scanf(\"%d\", &amp;Test); while (Test--) &#123; scanf(\"%d%d\", &amp;n, &amp;k); S = 0; T = 2*n+1; mcmf.init(2*n+1); all = 0; mcmf.add_edge(S, n+1, k, 0); //3 for (int i=1; i&lt;=n; ++i) &#123; scanf(\"%d\", &amp;p[i]); all += p[i]; mcmf.add_edge(S, i, p[i], 0); //1 mcmf.add_edge(i+n, T, p[i], 0); //2 &#125; for (int i=1; i&lt;n; ++i) &#123; mcmf.add_edge(i+n, i+n+1, INF, 0); //6 &#125; scanf(\"%d%d%d\", &amp;m, &amp;P, &amp;Q); for (int i=P; i&lt;=n; ++i) &#123; mcmf.add_edge(S, i+n, INF, Q); //4 &#125; for (int i=1; i&lt;=m; ++i) &#123; scanf(\"%d%d\", &amp;s[i], &amp;t[i]); for (int j=1; j+t[i]&lt;=n; ++j) &#123; mcmf.add_edge(j, n+j+t[i], INF, s[i]); //7 &#125; &#125; if (!solve()) puts(\"No solution\"); &#125; return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"https://sea96.github.io/tags/网络流/"}]},{"title":"特殊图","slug":"特殊图","date":"2017-06-03T00:44:41.000Z","updated":"2017-06-14T03:38:47.006Z","comments":true,"path":"2017/06/03/特殊图/","link":"","permalink":"https://sea96.github.io/2017/06/03/特殊图/","excerpt":"","text":"欧拉图定义通过图（无向图或有向图）中所有边且每边仅通过一次通路称为欧拉通路，相应的回路称为欧拉回路。具有欧拉回路的图称为欧拉图（Euler Graph），具有欧拉通路而无欧拉回路的图称为半欧拉图。 定理欧拉道路 无向图：当且仅当该图为连通图且所有顶点的度数为偶数，或者除了两个度数为奇数外其余的全是偶数。 有向图：当且仅当该图为连通图（忽略边的方向）且所有顶点 出度等于入度 或者一个顶点 入度比出度小1（把它当作起点） ，另一个顶点 入度比出度大1（把它当作终点），其他顶点 出度等于入度。 欧拉回路 无向图：当且仅当该图为连通图且每个顶点的度数都是偶数。 有向图：当且仅当该图为连通图且每个顶点的入度等于出度。","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"}]},{"title":"第k短路","slug":"第k短路","date":"2017-06-02T12:08:06.000Z","updated":"2017-06-14T03:39:16.865Z","comments":true,"path":"2017/06/02/第k短路/","link":"","permalink":"https://sea96.github.io/2017/06/02/第k短路/","excerpt":"","text":"第k短路A star 算法：通过一个估价函数 $f(n)=g(n)+h(n)$ 来估计图中的当前点 $n$ 到终点的距离，并由此决定它的搜索方向。首先在反图上使用Spfa或Dijkstra求出所有点到终点的最短路径。估价函数：当前走过的距离 + 该点到终点的最短路长度。用堆（优先队列）维护，每次取出估价函数最小的一个点扩展。第 $k$ 次从堆中取出点 $T$，就是找到了 $T$ 的第 $k$ 短路。 12345678910111213struct Node &#123; int f, g, v; //f,g函数，v节点 bool operator &lt; (const Node &amp;rhs) const &#123; if (f == rhs.f) return !(g &lt; rhs.g); else return !(f &lt; rhs.f); &#125;&#125;;priority_queue&lt;Node&gt; pque;void Astar() &#123; //只列出重要语句 auto it = pque.top(); if (it.v == T &amp;&amp; ++cnt == k) return it.g; //此时的g为S到T的第k短距离 pque.push(Node&#123;it.g+d[v], it.g+w, v&#125;);&#125;","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"}]},{"title":"2-SAT","slug":"2-SAT","date":"2017-06-02T10:22:47.000Z","updated":"2017-06-02T12:35:01.426Z","comments":true,"path":"2017/06/02/2-SAT/","link":"","permalink":"https://sea96.github.io/2017/06/02/2-SAT/","excerpt":"","text":"问题有 $n$ 个布尔变量 $x_i$，有 $m$ 个需要满足的条件，每个条件的形式是“ $x_i$ 为真/假或者 $x_j$ 为真/假”，问每一个变量的赋值。 算法一构造一张有向图G，每个变量拆成两个节点 $2i$ 和 $2i+1$，分别表示 $x_i$ 为假和 $x_i$ 为真。对于“ $x_i$ 为假或者 $x_j$ 为假”的条件，连一条有向边$2i+1$-&gt;$2j$（如果标记了 $x_i$ 为真，那么 $x_j$ 必须为假）。同理，还需要连一条有向边 $2j+1$-&gt;$2i$。然后对于每个没有赋值的变量，假定 $x_i$ 是假的，沿着有向边去标记节点。如果引起矛盾则改成 $x_i$ 是真的，重新标记。如果当前变量赋哪个值都会引起矛盾，证明这个2-SAT问题无解。 12345678910111213141516171819202122232425void add_edge(int x, int xVal, int y, int yVal) &#123; //x*2+xVal=true or y*2+yVal=true x = x * 2 + xVal; y = y * 2 + yVal; edge[x^1].push_back(y); edge[y^1].push_back(x);&#125;bool DFS(int x) &#123; if (mark[x^1]) return false; if (mark[x]) return true; mark[x] = true; sta[top++] = x; for (int y: edge[x]) if (!DFS(y)) return false; return true;&#125;bool judge() &#123; for (int i=0; i&lt;n*2; i+=2) if (!mark[i] &amp;&amp; !mark[i+1]) &#123; top = 0; if (!DFS(i)) &#123; while (top &gt; 0) mark[sta[--top]] = false; if (!DFS(i+1)) return false; &#125; &#125; return true;&#125;","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"}]},{"title":"平方分割","slug":"平方分割","date":"2017-05-21T02:00:00.000Z","updated":"2017-06-14T03:34:26.728Z","comments":true,"path":"2017/05/21/平方分割/","link":"","permalink":"https://sea96.github.io/2017/05/21/平方分割/","excerpt":"","text":"概述平方分割又叫做分桶法或者分块法，把排成一排的 $N$ 个元素每 $√N$ 分在一个块（桶）里，这样的分割方法可以把对区间的操作的复杂度降至 $O(√N)$。 对序列平方分割一般的做法是预设一个整数 $S$（$S$=$⌈√N⌉$），将序列分成 $B$（$B$=$⌈NS⌉$）块，每块 $S$ 个元素。对于一个区间的操作分为块内操作和块间操作，块内的暴力求解，块间的高效求解（排序后二分，lazy标记，预处理，数据结构维护等）。 123456//定义块号和块边界for (int i=0; i&lt;n; ++i) &#123; belong[i] = i / S; L[i] = belong[i]*S; R[i] = min(n, L[i]+S)&#125; 12345678910//区间询问或区间修改for (int i=l; i&lt;=r; ) &#123; if (i == L[i] &amp;&amp; R[i] &lt; r) &#123; //need efficient algorithm i = R[i]; &#125; else &#123; //just use brute force i++; &#125;&#125; 题目POJ 2104 K-th Number题意有 $n$ 个数字，$m$ 次询问，询问$[l,r]$区间里第 $k$ 大的数字。题解这题是主席树的经典题目，在本文中尝试用分块的方法求解。对元素的位置分块，每块分别排好序，二分第 $k$ 大的数字 $v$ ，对于一个区间 $[l,r]$ 查询小于 $v$ 的个数分为块内查询和块间查询，块内元素一个一个判断是否小于 $v$ ；块间用二分查找来统计小于 $v$ 的个数。二分复杂度：$O(logN)$，单次查询复杂度：$O(S+BlogS)$总时间复杂度：$O(M(logN(S+BlogS)))$code UVA 12003 Array Transformer题意有一个数组 $A[1,…,n]$ 和 $m$ 条指令和一个数字 $u$ ，每条指令形如 $(l,r,v,p)$ ，统计出 $A[l],A[l+1],…,A[r]$ 中严格小于 $v$ 的元素的个数为 $k$ ，然后把 $A[p]$ 改为$\\frac {uk}{r-l+1}$。问变换后的最终数组。 题解 对元素的位置分块，每块分别排序。询问的操作同POJ 2104，修改的操作则在 $p$ 所在的块里进行，因为修改后块内元素基本有序，所以用 插入排序 的方法使得被修改的元素移动到正确的位置。单次修改的复杂度： $O(logS+S)$ ，单次查询的复杂度：$O(S+BlogS)$ 总时间复杂度：$O(M(S+BlogS))$ 类题：SPOJ RACETIME Race Against Timecode 拓展若本题修改不是单点修改，而是区间修改，那么也没有必要重新全部排序： 本来数组是有序的，现在把其中一部分加上了一个数，那么可以将原数组分为修改后的和没修改的两部分，每部分都是一个有序数组，可以在 $O(S)$ 的时间内 归并排序。 ——《非常规大小分块算法初探》 徐明宽 BZOJ 2957 楼房重建题意一个人在坐标 $(0,0)$ 看楼房，楼房定义为 $(xi,yi)$ 表示位置在 $x_i$ ，高度为 $y_i$ 。如果这栋楼房上任何一个高度大于0的点与 $(0,0)$ 的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。起初所有楼房的高度都为0，有 $M$ 次操作，每次修改某个楼房的高度，问每次操作结束后能从 $(0,0)$ 看到多少栋楼房。题解如果一栋楼房可见，那么最高点 $(xi,yi)$ 和 $(0,0)$ 在x轴上的斜率一定大于前面所有的楼房，也就是要求斜率单调递增的序列的长度。对楼房的位置分块，每个块维护斜率递增的序列。修改操作直接在某个块上重新计算斜率递增的序列（可以使用插入排序算法），查询操作在每个块里二分查找大于前一个块里的最大斜率的斜率，并更新当前最大斜率。单次修改复杂度：$O(S)$，单次查询复杂度：$O(BlogS)$总时间复杂度：$O(M(BlogS+S))$code HDOJ 4366 Successor题意有 $n$ 个人，编号为0的是老板，编号1到 $n−1$ 是员工，每个员工只有一个上司，除老板为每个人有他的忠诚值和能力值。每次要解雇一个人的时候，从他的下属中选取能力值大于他的且忠诚值最高的一个，若不存在则输出-1。共 $m$ 次询问，每次询问解雇编号为 $i$ 的员工会选择哪个编号的员工顶替他。（所有询问都不相互影响）题解显然是一棵树，用DFS序得到编号的序列，每个点能知道子树在序列上对应的区间。对序列分块，每块的元素按照能力值排序，简单的dp求得能力值更大的后缀里忠诚值的最大值。块内查询逐个遍历，块间查询二分查找大于解雇员工的能力值的位置，从而得到最大的忠诚值，又因为忠诚值互不相同，所以能用map对应到员工的编号。单次查询复杂度：$O(BlogS)$总时间复杂度：$O(M(BlogS))$code BZOJ 2002 Bounce 弹飞绵羊题意有 $n$ 个弹力装置，每个装置有一个弹力系数$ k_i$ ，如果绵羊到达第 $i$ 个装置，它会被弹到第 $i+k_i$ 个装置。有 $m$ 个操作，修改某个装置的弹力系数，或者询问从某个装置出发弹几次后会被弹飞。题解对装置的位置分块，预处理出每个块维护从块里每个位置出发要弹几次后弹出该块，以及弹出后到达的位置。修改操作直接在某个块上重新计算要维护的信息，查询操作利用每个块的信息可以 $O(1)$ 跳出该块，累计次数和即可。单次修改复杂度：$O(S)$，单次查询复杂度：$O(B)$总时间复杂度：$O(M(S+B))$code拓展本题的加强版：CodeForces 13E Holes增加单点修改的操作以及询问最后被弹飞的位置。做法类似，预处理中增加从块里每个位置出发最后弹出该块的位置code CodeForces 551E GukiZ and GukiZiana题意有 $n$ 个数字，$m$ 次操作：1. $[l,r]$ 区间里的所有数字都增加 $x$ ；2. 询问 $[1,n]$ 里的最远点对 $(i,j)$ 满足 $a_i=a_j=y$ 。题解类似线段树的区间修改，对每一个块添加lazy标记表示该块统一增加的总和。每块分别把 $pair(a[i],i)$排好序，若块内元素被修改则重新排序，询问时只要对所有的块二分 $(y−lazy[b])$ 求出最近左端点和最远右端点即可。单次修改复杂度：$O(SlogS+B)$，单次查询复杂度：$O(BlogS)$总时间复杂度：$O(M(SlogS+BlogS))$code CodeForces 444C DZY Loves Colors题意有 $n$ 个数字，第 $i$ 个数字$a[i]=i$ ，有 $m$ 次操作：1. 修改 $[l,r]$ 区间的数字为 $x$ ，设原来的值为 $y$ ，那么该位置改变量累加 $|x−y|$；2. 询问 $[l,r]$ 区间的改变量的总和。题解对每一个块设置lazy标记表示该块的相同的值（如果不相同则标记为0），$sum[i]$ 表示第i个数字非lazy修改（即直接单点修改）的改变量和，$sumlazy[b]$ 表示第 $b$ 块里每一个数字经lazy修改的改变量和，$sumblock[b]$ 表示第 $b$ 块经lazy修改的所有数字的改变量总和。每次区间修改最多出现两个没有lazy标记的块，所以需要暴力单点更新的块不会很多。块内询问每个数字的贡献值总和：$∑(sum[i]+sumlazy[b])$；块间询问每个块的贡献值总和：$∑sumblock[b]$。单次修改复杂度：$O(S+B)$，单次查询复杂度：$O(S+B)$总时间复杂度：$O(M(S+B))$code CodeChef QCHEF Chef and Problems题意有 $N$ 个数字，第 $i$ 个数字 $A[i]≤M$ ，$K$ 次询问：问在 $[L,R]$ 中相同数字的位置的最大间隔。题解由于没有修改操作，可以预处理一些信息来辅助求解。对序列分块之后进行预处理：块间预处理：$ans[i][j]$ 表示第 $i$ 块到第 $j$ 块区间里的最大间隔，通过prepre数组记录每个数字最早出现的位置实现。然后就可以 $O(1)$ 得到块间最大值。块内预处理：$pos0[b][v]$ 表示第 $b$ 块里 $v$ 最后出现的位置，然后转为前 $b$ 块的最后出现的位置；同理可得 $pos1[b][v]$ 表示第 $b$ 块之后 $v$ 最早出现的位置。然后暴力求解即可，求解方法和块间预处理相同。块间预处理复杂度：$O(BN)$，块内预处理复杂度：$O(N+BM)$总时间复杂度：$O(BN+BM+KS)$code类题：SPOJ ZQUERY Zero Query（提示：求前缀和） LYOI 147 「分块」区间众数题意给一个长度为 $n$ 的序列，$m$ 次询问，每次查询一个区间 $[l,r]$ 内的众数（如果有多个众数，取最小的一个），强制在线。题解同样没有修改操作，类似上题预处理一些信息。对序列离散化，分块之后进行预处理：块间预处理：$ans[i][j]$ 表示第 $i$ 块到第 $j$ 块区间的众数，通过 $cnt$ 数组记录每个数字出现次数实现。然后就可以 $O(1)$ 得到块间最大值。块内预处理：$sum[b][v]$ 表示第 $b$ 块里 $v$ 出现的次数，然后转为前 $b$ 块的出现的次数。然后暴力求解即可，求解方法和块间预处理相同。块间预处理复杂度：$O(BN)$，块内预处理复杂度：$O(N+BN)$总时间复杂度：$O(BN+S)$code拓展带修改操作：区间众数解题报告 - 陈立杰 CodeForces 455D Serega and Fun题意有 $n$ 个数字，$q$ 次操作，1. 序列循环向右移动一位；2. 询问 $[l,r]$ 里 $k$ 的个数。强制在线。题解使用块状链表解决：用deque或者list存储每块的元素，移位操作在每块 $O(1)$ 地插入或删除。预处理出每块中每个元素的个数，移位时也可以 $O(1)$ 修改。总时间复杂度：$O(Q(B+S))$code HDU 4391 Paint The Wall题意有 $n$ 个数字，$q$ 次操作，1. 将 $[l,r]$ 里的所有元素涂成颜色 $z$；2. 询问 $[l,r]$ 里 颜色 $z$ 的个数。题解颜色范围很大，如果使用朴素的线段树空间上无法承受。线段树套分块哈希：考虑线段树维护的不是单个元素，而是整块元素，每块用 map 维护每种颜色的数量，再加上懒惰标记后可以通过此题。总时间复杂度：$O(Q(B+SlogS)$code 对集合平方分割通常在图中使用，具体做法是预设一个整数$S$（$S$=$√E$），将度数超过 $S$ 的点记为重点，其余的点记为轻点。重新建图：重点只与相邻的重点连边，重点与相邻的轻点的边的信息使用预处理或者数据结构等手段高效维护，使得对点的遍历和边的修改的复杂度降至 $O(√E)$ 。 题目HDU 4858 项目管理题意有 $n$ 个点，$m$ 条边的无向无环图，两个节点可能有多条边，每条点有权值，有 $q$ 次操作，1. 节点 $u$ 的权值加上 $v$；2. 问节点 $u$ 相邻点的权值和。题解根据重点和轻点的定义，将原图重新建图，若 $u$ 是重点，$sum[u]$ 保存与 $u$ 相邻的 重点 的权值和。修改 重点 的话更新该点和与该点相邻的 重点 的 $sum$（单次修改复杂度：$O(S)$；单次查询复杂度：$O(1)$），否则在原图遍历所有相邻点的 $sum$（单次修改复杂度：$O(S)$；单次查询复杂度：$O(S)$）。总时间复杂度：$O(QS)$code HDU 4467 Graph题意有 $n$ 个点，$m$ 条边的无向无环图，每条边有权值 $w$，每个点有颜色 $(0/1)$，有 $q$ 次操作，1. 第 $x$ 个点的颜色反转；2. 问端点的颜色是 $(A,B)$ 的边的权值和。（$A(B)=0/1$）题解根据重点和轻点的定义，将原图重新建图，预处理若干信息，若 $u$ 是 重点，$sum[u][0/1]$ 保存与 $u$ 相邻的 重点（轻）点 的边权和，$ans[k]$ ($k=0$: 0-0; $k=1$: 0-1; $k=2$: 1-1) 保存统一类型的边权总和，修改只要交换信息即可，查询能 $O(1)$ 得到答案。code ZOJ 3749 Chameleon题意有 $n$ 个集合，第 $i$ 个集合有 $m_i$ 个数字，所有数字都不相同，$q$ 次操作，每次选取第 $i$ 个集合和第 $j$ 个集合，按照数字大小归并排序，问排序后相邻数字之间所属集合不同的个数。题解按照朴素的方法，复杂度是 $O(QN)$ 。按照集合的大小以 $S=√N$ 分类，两个集合都小于 $S$ 的询问按照朴素的方法解决，复杂度为 $O(QS)$ ；如果大于 $S$ ，考虑离线询问，对于一个大于 $S$ 的集合，$O(N)$ 处理出其他所有集合和它的答案，那么复杂度为 $O(NS)$。总时间复杂度：$O((N+Q)S)$code CodeForces 348C Subset Sums题意有 $n$ 个元素，第 $i$ 个元素的值为 $a[i]$ ；有 $m$ 个集合，每个集合存有若干个元素的下标（一个元素可能在多个集合出现）。$q$ 次操作，1. 询问某个集合元素值的总和；2. 第 $k$ 个集合内所有元素的值加上 $x$。题解按照集合的大小以 $S=√N$ 分类，预处理大于 $S$ 的集合内元素值的总和以及大集合之间重合的元素的个数，修改时用lazy标记记录；查询根据lazy标记集合之间重合元素个数转移来求得。对于小于 $S$ 的集合的操作暴力计算或者和上述做法类似。总时间复杂度：$O(QS)$code CodeForces 398D Instant Messanger题意作为一个聊天房间的管理员，需要支持用户登录，退出，添加朋友，删除朋友，统计在线朋友的数量这四种操作。题解对用户的朋友数量动态分割，不再按照某一个固定的值来分隔。对于比当前用户朋友数少的用户用数组维护个数，比当前多的用户遍历统计。code CodeForces 576C Points on Plane题意给出 $n$ 个点，要求排序后，相邻两点的曼哈顿距离之和小于等于 $2.5×10^9$。题解按照 $x$ 坐标每1000长度分块，块内按照 $y$ 坐标排序，那么可以构造出距离上限是 $2×10^9$ 的方案，满足题意。code 对询问平方分割莫队算法用到了分块的思想，一般是给 $Q$ 个区间 $[l,r]$ 来进行的一些操作和询问。将序列分成 $√N$ 块，每块的大小为 $√N$ 。离线处理 $Q$ 个区间：首先对左端点 $l$ 所在的块号从小到大排序，如果块号相同则按右端点 $r$ 从小到大排序。然后用双指针移动到当前区间位置，每次移动更新对结果的贡献。 1234567for (int i=1; i&lt;=Q; ++i) &#123; while (L &lt; q[i].l) sub(L++); //删除 while (L &gt; q[i].l) add(--L); //增加 while (R &lt; q[i].r) add(++R); while (R &gt; q[i].r) sub(R--); ans[q[i].id] = sum; //答案&#125; CF 86D Powerful array CodeForces 351D Jeff and Removing Periods 莫队HDU 4638 Group 莫队CodeForces 103D Time to Raid Cowavans 莫队CodeForces 375D Tree and Queries 莫队CodeForces 617E XOR and Favorite Number 莫队SPOJ DQUERY D-query 莫队CodeChef GERALD07 Chef and Graph Queries 莫队，并查集，LCTCodeChef IITI15 Sherlock and Inversions 莫队，区间逆序对","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"}]},{"title":"精选优秀软件","slug":"精选优秀软件","date":"2017-05-13T13:09:41.000Z","updated":"2017-06-14T03:43:38.660Z","comments":true,"path":"2017/05/13/精选优秀软件/","link":"","permalink":"https://sea96.github.io/2017/05/13/精选优秀软件/","excerpt":"","text":"网络浏览器 Google Chrome 最好用的浏览器 翻墙软件 赛风 免费翻墙软件 蓝灯 免费版流量受限 编程软件 Code::Blocks 开放源码的全功能的跨平台C/C++集成开发环境 Eclipse 开放源代码的、基于Java的可扩展开发平台 IntelliJ IDEA 在业界被公认为最好的java开发工具之一 Sublime Text 神级代码编辑器 gVim 编辑器之神 Typora 极致简洁的Markdown编辑器","categories":[{"name":"日常生活","slug":"日常生活","permalink":"https://sea96.github.io/categories/日常生活/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://sea96.github.io/tags/工具/"}]},{"title":"快速傅里叶变换","slug":"快速傅里叶变换","date":"2017-05-13T00:59:46.000Z","updated":"2017-06-14T03:38:54.334Z","comments":true,"path":"2017/05/13/快速傅里叶变换/","link":"","permalink":"https://sea96.github.io/2017/05/13/快速傅里叶变换/","excerpt":"","text":"","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://sea96.github.io/tags/数学/"}]},{"title":"后缀数组","slug":"后缀数组","date":"2017-05-05T09:05:53.000Z","updated":"2017-06-14T03:38:59.174Z","comments":true,"path":"2017/05/05/后缀数组/","link":"","permalink":"https://sea96.github.io/2017/05/05/后缀数组/","excerpt":"","text":"后缀数组是处理字符串的有力工具。后缀数组是后缀树的一个非常精巧的替代品，它比后缀树容易编程实现，能够实现后缀树的很多功能，而时间复杂度也并不逊色，而且它比后缀树所占用的内存空间小很多。 概念 后缀：设一个字符串为S[0 ~ |S|-1]，后缀i表示S[i ~ |S|-1]。举例：有一个字符串BANANA，后缀3就是ANA。 后缀数组：后缀数组sa保存的是所有后缀按字典序从小到大排序的结果（在字符串S的下标）。 举例：BANANA的后缀数组sa[]={5,3,1,0,4,2}，更详细点就是后缀5（A），后缀3（ANA），后缀1（ANANA）。。。 名次数组：名次数组rank[i]表示++后缀i在后缀数组里的名次（在sa数组的下标）。++ 容易看出，后缀数组和名次数组为互逆运算。举例：一个字符串BANANA，rank[3]（后缀3为ANA）等于1（结合上文），逆运算：sa[1]=3。 高度数组：高度数组height[i]表示sa[i]和sa[i-1]的LCP（最长公共前缀）。 求法后缀数组 DA算法：倍增思想+基数排序（双关键字排序），复杂度 $O(nlogn)$ 12345678910111213141516171819202122232425void build_sa(int m = 128) &#123; int i, j, p, *x = tmp_one, *y = tmp_two; //对于单字符S[i~i]的基数排序 for (i=0; i&lt;m; ++i) c[i] = 0; for (i=0; i&lt;n; ++i) c[x[i]=s[i]]++; for (i=1; i&lt;m; ++i) c[i] += c[i-1]; for (i=n-1; i&gt;=0; --i) sa[--c[x[i]]] = i; //对于长度j，关键字为(S[i~(i+j-1)],S[(i+j)~(i+j+j-1)])进行基数排序 for (j=1, p=0; j&lt;=n; j&lt;&lt;=1) &#123; //直接利用sa数组排序第二关键字 for (p=0, i=n-j; i&lt;n; ++i) y[p++] = i; for (i=0; i&lt;n; ++i) if (sa[i] &gt;= j) y[p++] = sa[i] - j; //基数排序第一关键字 for (i=0; i&lt;m; ++i) c[i] = 0; for (i=0; i&lt;n; ++i) c[x[y[i]]]++; for (i=1; i&lt;m; ++i) c[i] += c[i-1]; for (i=n-1; i&gt;=0; --i) sa[--c[x[y[i]]]] = y[i]; swap(x, y); //根据sa和y数组计算新的x数组 for (p=1, x[sa[0]]=0, i=1; i&lt;n; ++i) &#123; x[sa[i]] = (y[sa[i-1]] == y[sa[i]] &amp;&amp; y[sa[i-1]+j] == y[sa[i]+j] ? p-1 : p++); &#125; if ((m=p) &gt;= n) break; &#125;&#125; 代码解释：参数m表示不同字符的个数（会增大），数组s是字符串转换成数字数组。用到三个辅助数组，x数组记录当前长度j下后缀i的排名，y数组记录第二关键字排序的结果，c数组用来计数和定位。 DC3算法 时间复杂度 $O(n)$ 代码链接 参考资料 后缀数组（入门经典学习笔记） 数据结构之后缀数组 后缀数组(suffix array)详解","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://sea96.github.io/tags/字符串/"}]},{"title":"单调栈","slug":"单调栈","date":"2017-04-20T11:05:29.000Z","updated":"2017-06-14T03:39:21.718Z","comments":true,"path":"2017/04/20/单调栈/","link":"","permalink":"https://sea96.github.io/2017/04/20/单调栈/","excerpt":"","text":"定义 单调递减栈：元素从栈顶到栈底单调递减的栈 单调递减栈：元素从栈顶到栈底单调递减的栈 应用单调栈最常用的功能是可以求出一个元素向左（或向右）所能扩展到的最大长度，并不是说在这一段区间内是单调的，而是保证在该区间内该元素一定是最大或最小。 题目POJ 3250 Bad Hair Day题意有$n$个人，问每一个人向右看能看到人的数量的总和（能看到的人身高比当前的人矮）。 题解从后往前，维护一个单调递减栈来求每一个人右边的高度比它小的最近的位置即可。code POJ 2796 Feel Good题意有$n$个元素，问一个区间长度乘以区间最小值的最大值。 题解也就是求每一个元素往左（右）值比它小的最近的位置。维护两次单调递减栈。code SCU 1773 Largest Rectangle in a Histogram题意给$n$个宽度为1的矩形，求最大连续矩形面积。 题解矩形的面积等于区间长度乘以区间最小高度，做法和POJ 2796一样。","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"}]},{"title":"Codeforces Round #406 (Div. 2)","slug":"Codeforces-Round-406-Div-2","date":"2017-04-11T13:17:10.000Z","updated":"2017-05-13T14:26:03.577Z","comments":true,"path":"2017/04/11/Codeforces-Round-406-Div-2/","link":"","permalink":"https://sea96.github.io/2017/04/11/Codeforces-Round-406-Div-2/","excerpt":"","text":"A. The Monster给定$a,b,c,d$，问是否存在$k_1,k_2$，使得$b+k_1a=d+k_2c$.暴力枚举其中一个$k$判断是否能整除即可。 B. Not Afraid两个宇宙，每一个人在两个宇宙里一个是忠诚者，另一个是叛徒。将他们分组，问是否可能存在一个组里的人都是叛徒。如果一个数的正负数都在同一个组里，那么这个组一定有一个是忠诚者，否则可能都是叛徒。 C. Berzerk题意$n$个点形成环，两个玩家分别有$k_1,k_2$个数字$s_i$，每次都可以选择一个数字$s_i$，顺时针跳到后面第$s_i$个位置，谁先跳到第1位置谁就获胜，问从两个人从每个位置出发的最优结局。 题解正方向DFS的话，因为后继不能保证在有限次数后到达终点，那么选择从终点逆推，定义$f[2][i]$表示玩家走到$i$位置的结局是win or Lose，一个状态判为$Win$的条件是至少存在一个后继是$Lose$；一个状态判为$Lose$的条件是后继都是Win。使用记忆化搜索，每个状态只遍历一次，时间复杂度：$O(n)$.code D. Legacy题意给定$q$个操作，有3种有向边： $u$到$v$连一条边 $u$到$[l,r]$区间里所有点连一条边 $[l,r]$区间所有点到$u$连一条边 问从s点出发到每个点的最短路。 题解直接建边的话，最多有$n^2$条边，显然不能承受。区间覆盖问题考虑使用线段树，又因为线段树的树形结构可以将每个节点作为建图辅助点，具体说就是线段树的每个节点之间连上权值为0的边，对于操作2，一个点连到区间的操作转化为连到包含该区间的线段树上的所有节点，操作3同理，但是新建一棵线段树，因为不能和操作2冲突。然后使用Dijkstra跑最短路即可，时间复杂度：$O(nlog^2n)$.code E. Till I Collapse题意将$n$个数字分成若干个区间，问对于每一个$k$，每个区间的不同的数字的数量不超过$k$个的最少区间数。 题解每次贪心地选择最远的端点满足区间里不同的数字不超过$k$个。直接遍历的话，对于每一个$k$的时间复杂度$O(n)$，总时间复杂度：$O(n^2)$.参照可持久线段树求区间不同数字的个数的方法，可以维护以$i$为终点，前缀不同数字的个数（每个数字定位在最后出现的位置），那么在树上二分找到最左的位置前缀的和为$(sum-k)$，这也是为什么要定位在最后的位置，保证有$k$个不同的数字。code","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"},{"name":"线段树","slug":"线段树","permalink":"https://sea96.github.io/tags/线段树/"},{"name":"最短路","slug":"最短路","permalink":"https://sea96.github.io/tags/最短路/"},{"name":"博弈","slug":"博弈","permalink":"https://sea96.github.io/tags/博弈/"}]},{"title":"初等数论","slug":"初等数论","date":"2017-04-09T01:37:58.000Z","updated":"2017-06-14T03:39:25.674Z","comments":true,"path":"2017/04/09/初等数论/","link":"","permalink":"https://sea96.github.io/2017/04/09/初等数论/","excerpt":"","text":"素数运算 素数的定义质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个因数的数） 素数的性质和定理 欧拉证明：素数在数量上是无限的（不存在最大的素数） 存在任意长的一段连续数，其中的所有数都是合数（相邻素数之间的间隔任意大） 所有大于2的素数都可以唯一地表示成两个平方数之差。 当$n$为大于2的整数时，$2^n+1$和$2^n-1$两个数中，如果其中一个数是素数，那么另一个数一定是合数。 哥德巴赫猜想：每个大于4的偶数可以写成两个奇素数的和（陈景润证明：偶数为一个素数及一个不超过两个素数的乘积之和，简称“1+2”） 唯一分解定理：每个正整数都可以唯一地表示成素数的乘积，即有唯一的分解质因数的方案：$n=p_1^{e_1}p_2^{e_2}…p_k^{e_k}$根据上面的式子，可以推知$n$共有 $(e_{1}+1)(e_{2}+1)…(e_{k}+1)$个约数。 素数的判定试除法试用2…$\\lfloor \\sqrt{n} \\rfloor$去除$n$（更好的做法是筛选出[2..$\\sqrt{n}$]里的所有素数），$n$是素数当且仅当没有一个试用的除数能被$n$整除。时间复杂度：$O(\\sqrt{n})$ Miller_Rabin方法米勒-拉宾素性检验是一种素数判定法则，利用随机化算法判断一个数是合数还是可能是素数。测试大素数的Miller_Rabin方法基于下述定理： 费马小定理：如果$n$是素数，$a$是整数，则 $a^n \\equiv a\\pmod{n}$如果 $a$ 不是 $n$ 的倍数，也可以写成 $a^{n-1} \\equiv 1\\pmod{n}$ 二次探测定理：如果$n$是奇素数，则$a^2 ≡ 1\\pmod n$的解为$a ≡ 1\\pmod n$或$a ≡ n-1\\pmod n$ 重复$k$次计算，每次在$[1,n-1]$范围内随机选取一个$a$，若$a^{n-1} \\neq 1\\pmod{n}$，则$n$是合数。若随机选取的$k$个$a$都使得$a^{n-1} \\equiv 1\\pmod{n}$，则$n$是素数或伪素数。若使用模指数运算的快速算法，这个算法的运行时间是：$O(klog_{2}^3n)$经验结论： if n &lt; 3,215,031,751, it is enough to test a = 2, 3, 5, and 7; if n &lt; 4,759,123,141, it is enough to test a = 2, 7, and 61; if n &lt; 18,446,744,073,709,551,616 = $2^{64}$, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37. if n &lt; 318,665,857,834,031,151,167,461, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37. if n &lt; 3,317,044,064,679,887,385,961,981, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, and 41. 素数的筛法筛选[2..$n$]中的所有素数 埃拉托斯特尼筛法按递增顺序搜索筛中的最小数，将其倍数从筛中筛去，最终筛中留下的数即为素数。时间复杂度：$O(nloglogn)$ 欧拉筛法在埃式筛法上改进：每个合数仅被它最小的质因数筛去。时间复杂度：$O(n)$此方法可以求积性函数$f(x)$，即在$O(n)$时间复杂度内预处理$f(1)$,$f(2)$ … $f(n)$的值，典型的用途是求欧拉函数。 公约数问题 最大公约数和最小公倍数若$x=p_1^{k_1}p_2^{k_2}…p_r^{k_r}$$y=p_1^{n_1}p_2^{n_2}…p_r^{n_r}$则$GCD(x,y)=p_1^{min(k_1,n_1)}p_2^{min(k_2,n_2)}…p_r^{min(k_r,n_r)}$$LCM(x,y)=p_1^{max(k_1,n_1)}p_2^{max(k_2,n_2)}…p_r^{max(k_r,n_r)}$同时可以得到$x×y=GCD(x,y)×LCM(x,y)$ 若$x=p×GCD(x,y)$$y=q×GCD(x,y)$则$x+y=(p+q)×GCD(x,y)$那么 $GCD(x,y)=GCD(x,x+y)$同理可得 $GCD(x,y)=GCD(x+y,LCM(x,y))$ 欧几里得算法$$GCD(a,b)=\\begin{cases}b&amp; \\text{a = 0}\\\\GCD(b,a\\mod b)&amp; \\text{a $\\neq$ 0}\\end{cases}$$简单证明：设$g=GCD(a,b)$将$a \\mod b$化成$a$与$b$的线性组合，即$a \\mod b=a-\\lfloor{\\frac{a}{b}}\\rfloor *b$。由于$g$能整除$a$和$b$，那么$g$一定能整除$a$与$b$的线性组合，即$g$能整除$(a \\% b)$，所以$GCD(a,b)=GCD(b,a\\% b)$.时间复杂度：$O(log \\max(a,b))$ 扩展欧几里得算法已知整数$a$、$b$，扩展欧几里得算法可以在求得$a$、$b$的最大公约数的同时，能找到整数$x$、$y$（其中一个很可能是负数）满足$ax+by=GCD(a,b)$.若$b=0$，则$GCD(a,b)=a$，$x=1$，$y=0$；若$b\\neq 0$，首先递归求解满足$bx’+(a\\mod b)y’=GCD(b,a\\mod b)$的$x’$、$y’$，因为$GCD(a,b)=GCD(b,a\\% b)$，所以有以下等式成立：$$bx’+(a- \\lfloor{\\frac{a}{b}}\\rfloor b)y’=ay’+b(x’- \\lfloor{\\frac{a}{b}}\\rfloor y’)=ax+by$$选择$x=y’$，$y=x’- \\lfloor{\\frac{a}{b}}\\rfloor y’$就可以满足等式。 应用扩展欧几里得算法，可以求解如下形式的二元一次不定方程：$$ax+by=c$$首先先求解$ax+by=GCD(a,b)$的$x$和$y$，记$g=GCD(a,b)$.若$c$不能被$g$整除，则无整数解；否则初始解：$x_{0}=x\\frac{c}{g}$，$y_{0}=y\\frac{c}{g}$.不定方程的通解形式为：$$\\begin{cases}x_{k}=x_{0}+k\\frac{b}{g} &amp; \\\\y_{k}=y_{0}-k\\frac{a}{g} &amp; \\text{k $\\in $ Z}\\end{cases}$$ 同余问题同余关系式 威尔逊定理：$(p-1)! \\equiv -1 ({\\mbox{mod}} p)$ 费马小定理：${\\displaystyle a^{p}\\equiv a{\\pmod {p}}}$ 欧拉定理：$a^{\\varphi (n)}\\equiv 1{\\pmod {n}}$ 卡迈克尔函数：$a^{\\lambda (n)}\\equiv 1{\\pmod {n}}$ 阶乘幂：$(x)_{k}\\equiv x(x-1)(x-2)\\cdots (x-k+1)\\equiv 0{\\pmod {k!}}$ 其它定理 若 $ac\\equiv bc\\pmod n$ 且 $GCD(c,n)=d$，则$a \\equiv b \\pmod{ \\frac {n}{d}}$ 若 $d \\neq 0$ 且 $ad \\equiv bd \\pmod {nd}$，则 $a \\equiv b \\pmod n$ 若 $n$ 和 $a$ 互质，则一次同余方程 $ax+b\\equiv 0 \\pmod n$ 有解模运算满足交换律（除了除法） 同余方程 求解一次同余方程 $ax\\equiv b\\pmod n$也就是要求解二元一次方程 $ax-my=b$，使用扩展欧几里得算法求解。令 $g=GCD(a,m)$，如果$b$不能被$g$整除，那么同余方程无解；否则有$g$个解，即$x_k=x_0+k \\frac{m}{g}(0\\leq k &lt; g)$ 求解同余方程 $a^x\\equiv b\\pmod n$ 求解一元线性同余方程组$$\\begin{cases}x≡a_1 \\pmod {m_1} &amp; \\\\x≡a_2 \\pmod {m_2} &amp; \\\\… \\\\x≡a_n \\pmod {m_n} &amp; \\\\\\end{cases}$$中国剩余定理若$m_1$、$m_2$ …. $m_n$ 两两互质，则对任意整数 $a_1$、$a_2$ …. $a_n$ 方程组有解。令$M=m_1m_2m_3…m_n$$w_i=\\frac{M}{m_i}$$w_i’$ 为 $w_i$ 模 $m_i$ 下的逆元，即 $w_iw_i’≡1 \\pmod {m_i}$则$x=(a_1w_1w_1’+a_2w_2w_2’+…+a_nw_nw_n’) \\pmod M$ 模逆元在求解除法取模问题 $(a / b) \\% n$ 时，我们可以转化为 $(a \\% (b \\cdot n))/b$。但是 $b$ 范围很大时，$bn$ 可能存不下，所以我们使用乘法逆元将除法转换为乘法。在模 $n$ 的意义下，把 $a$ 的模逆元写作 $a^{-1}$，满足$aa^{-1}\\equiv 1{\\pmod {n}}$，那么 $\\frac {a}{b}=ab^{-1} \\pmod n$*$a$ 对模数 $n$ 之模逆元存在的充分必要条件是 $a$ 和 $n$ 互质。求解模逆元的几种方法： 使用扩展欧几里得算法求解 $ax \\equiv 1 \\pmod n$，即 $ax-ny=1$。若 $g=GCD(a,n)=1$，该模逆元存在，且有无穷个解，选取最小正整数解即可。 使用欧拉定理当 $a$ 和 $n$ 互质时，有 $a^{\\varphi (n)}\\equiv 1{\\pmod n}$。那么分解为 $a^{\\varphi (n)}=a\\cdot a^{\\varphi (n)-1}\\equiv 1{\\pmod {n}}$，其中的 $a^{\\varphi (n)-1}$ 即为 $a$ 关于模 $n$ 之模逆元。特别地，若 $n$ 为素数时，$a$ 的模逆元为 $a^{n-2}$（费马小定理） 使用线性递推法$n$为奇素数时，记 $i$ 的逆元为 $inv[i]$，有递推式：$$inv[i]=\\begin{cases}1&amp; \\text{i = 1}\\\\(n-\\frac{n}{i}) \\cdot inv[n \\% i]\\% n &amp; \\text{i $&gt;$ 1}\\end{cases}$$证明（略，公式移项）此方法以在 $O(n)$ 时间复杂度求解小于 $n$ 的所有模逆元。 积性函数在数论中，积性函数是指一个定义域为正整数 $n$ 的算术函数 $f(n)$，有如下性质：$f(1) = 1$，且当 $a$ 和 $b$ 互质时，$f(ab) = f(a) f(b)$若对于任意两个正整数 $a$ 和 $b$ ，都有 $f(ab)=f(a)f(b)$，则称此函数 $f$ 为完全积性函数。显然，对于任意积性函数，$f(1)=1$$GCD(a,b)$ 也是积性函数（当一个数字固定的情况下） 欧拉函数定义欧拉函数$φ(n)$，表示小于等于 $n$ 且与 $n$ 互质的正整数的个数。例如：$φ(1)=φ(2)=1$，$φ(3)=φ(4)=2$欧拉函数是积性函数，即当 $n$、$m$ 互质时，$φ(nm)=φ(n)φ(m)$。但不是完全积性函数。 欧拉函数的值 当 $n$ 是素数时，$φ(n)=n-1$ 当 $n$ 是合数时，$φ(n)&lt;n-1$，且 $φ(n) \\leq n- \\sqrt n$ 若 $n$ 是素数 $p$ 的 $k$ 次幂，$φ(n)=φ(p^{k})=p^{k}-p^{k-1}=(p-1)p^{k-1}$，因为除了 $p$ 的倍数外，其他数都跟 $n$ 互质。 一般地，设 $n=p_1^{k_1}p_2^{k_2}…p_r^{k_r}$则$$φ(n)=\\prod_{i=1}^{r}p_{i}^{k_{i}-1}(p_{i}-1)=n \\prod_{p|n} \\left(1-{\\frac {1}{p}} \\right)$$ 欧拉定理若两个正整数 $n$ 和 $a$ 互质，则 $a^{φ(n)} \\equiv 1 \\pmod n$推论：$a^{φ(n)+1} \\equiv a \\pmod n$欧拉定理的一个特例是费马小定理（若 $n$ 是素数，则 $φ(n)=n-1$）。 欧拉函数的性质 $n$ 的欧拉函数 $\\varphi (n)$ 也是循环群 $C_n$ 的生成元的个数，即$$ \\sum_{d \\mid n} \\varphi (d)=n $$其中的 $d$ 为 $n$ 的正约数。运用莫比乌斯反演来“翻转”这个和，就可以得到另一个关于 $\\varphi (n)$ 的公式：$$ \\varphi (n)=\\sum _{d \\mid n} {d\\cdot \\mu (n/d)}$$其中 $μ$ 是所谓的莫比乌斯函数，定义在正整数上。 当 $n&gt;1$ 时，$1…n$ 中与 $n$ 互质的整数和为 $\\frac{n\\varphi (n)}{2}$ 当 $n$ 为奇数时，有 $\\varphi (2n)= \\varphi (n)$ 莫比乌斯函数定义莫比乌斯函数$μ(n)$，表示非平方数 $n$ 的质因子个数，$μ(n)$ 是 $φ(n)$ 的反演函数。 参考资料 Matrix67 Blog维基百科 质数维基百科 辗转相除法维基百科 扩展欧几里得算法模逆元维基百科 同余维基百科 积性函数","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://sea96.github.io/tags/数论/"}]},{"title":"2016-2017 ACM-ICPC Pacific Northwest Regional Contest (Div. 2)","slug":"2016-2017-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-2","date":"2017-04-06T05:04:09.000Z","updated":"2017-05-13T05:22:13.850Z","comments":true,"path":"2017/04/06/2016-2017-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-2/","link":"","permalink":"https://sea96.github.io/2017/04/06/2016-2017-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-2/","excerpt":"A. Alphabet裸LIS","text":"A. Alphabet裸LIS B. Barbells问杠铃和盘子有多少种不同的搭配方式。关键求出左右相等且不重复使用盘子的方案数，因为数据范围小，考虑状态压缩，用map&lt;ll, vector&lt;int&gt;&gt;存储每一个重量对应的各个mask值。12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;map&lt;ll, vector&lt;int&gt; &gt; mp;set&lt;ll&gt; tmp, ans;ll b[15], p[15];int n, m;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i=1; i&lt;=n; ++i) scanf(\"%I64d\", &amp;b[i]); for (int i=1; i&lt;=m; ++i) scanf(\"%I64d\", &amp;p[i]); for (int mask=0; mask&lt;(1&lt;&lt;m); ++mask) &#123; ll x = 0; for (int j=0; j&lt;m; ++j) if (mask &amp; (1&lt;&lt;j)) x += p[j+1]; mp[x].push_back(mask); &#125; for (auto it: mp) &#123; int sz = it.second.size(); if (sz &lt; 2) continue; bool ok = false; for (int j=0; !ok &amp;&amp; j&lt;sz; ++j) for (int k=j+1; !ok &amp;&amp; k&lt;sz; ++k) &#123; if ((it.second[j] &amp; it.second[k]) == 0) &#123; tmp.insert(2LL*it.first); ok = true; &#125; &#125; &#125; tmp.insert(0); for (int i=1; i&lt;=n; ++i) &#123; for (auto x: tmp) &#123; ans.insert(b[i]+x); &#125; &#125; for (auto x: ans) &#123; printf(\"%I64d\\n\", x); &#125; return 0;&#125; C. Buggy Robot一个机器人走迷宫，给定指令序列，问最少插入或删除多少指令能使得机器人走出迷宫。转化为最短路问题，每一个坐标看成一个点，相邻坐标之间有边，权值为0或1，如果按照指令进行边权值为0，否则为1。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55;const int INF = 0x3f3f3f3f;const int dx[4] = &#123;-1, 1, 0, 0&#125;;const int dy[4] = &#123;0, 0, -1, 1&#125;;const char dir[4] = &#123;'U', 'D', 'L', 'R'&#125;;char maze[N][N];char s[N];int dis[N][N][N];struct Node &#123; int v, x, y, z; bool operator &lt; (const Node &amp;rhs) const &#123; return !(v &lt; rhs.v); &#125;&#125;;int n, m, len;int sx, sy, ex, ey;void Dijkstra() &#123; memset(dis, 127, sizeof(dis)); dis[sx][sy][0] = 0; priority_queue&lt;Node&gt; pque; pque.push(Node&#123;dis[sx][sy][0], sx, sy, 0&#125;); while (!pque.empty()) &#123; Node u = pque.top(); pque.pop(); if (u.x == ex &amp;&amp; u.y == ey) break; if (u.z &lt; len) &#123; int d = 0; for (; d&lt;4; ++d) if (dir[d] == s[u.z+1]) break; int tx = u.x + dx[d], ty = u.y + dy[d]; if (maze[tx][ty] == 0 || maze[tx][ty] == '#') tx = u.x, ty = u.y; if (dis[tx][ty][u.z+1] &gt; dis[u.x][u.y][u.z]) &#123; dis[tx][ty][u.z+1] = dis[u.x][u.y][u.z]; pque.push(Node&#123;dis[tx][ty][u.z+1], tx, ty, u.z+1&#125;); &#125; &#125; //delete if (u.z &lt; len &amp;&amp; dis[u.x][u.y][u.z+1] &gt; dis[u.x][u.y][u.z]+1) &#123; dis[u.x][u.y][u.z+1] = dis[u.x][u.y][u.z] + 1; pque.push(Node&#123;dis[u.x][u.y][u.z+1], u.x, u.y, u.z+1&#125;); &#125; //insert for (int i=0; i&lt;4; ++i) &#123; int tx = u.x + dx[i], ty = u.y + dy[i]; if (maze[tx][ty] == 0 || maze[tx][ty] == '#') continue; if (dis[tx][ty][u.z] &gt; dis[u.x][u.y][u.z]+1) &#123; dis[tx][ty][u.z] = dis[u.x][u.y][u.z] + 1; pque.push(Node&#123;dis[tx][ty][u.z], tx, ty, u.z&#125;); &#125; &#125; &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i=1; i&lt;=n; ++i) &#123; scanf(\"%s\", maze[i]+1); for (int j=1; j&lt;=m; ++j) &#123; if (maze[i][j] == 'R') sx = i, sy = j; if (maze[i][j] == 'E') ex = i, ey = j; &#125; &#125; scanf(\"%s\", s+1); len = strlen(s+1); Dijkstra(); int ans = INF; for (int i=0; i&lt;=len; ++i) ans = min(ans, dis[ex][ey][i]); printf(\"%d\\n\", ans); return 0;&#125; D. Cameras每$r$个有2个相机，如果不够贪心地放在最后面，用树状数组动态维护区间和即可。 E. Contest Score优先队列模拟即可 F. Equality模拟签到题 G. Gravity模拟题，从下往上操作 H. Islands求连通块数量。DFS求出连通块数量，剩下可能是陆地的当作海处理。 I. Mismatched Socks问最多能有多少颜色不同的袜子。如果数量最多的某种颜色的袜子不超过$\\frac {sum}{2}$，那么全部都可以错误搭配，搭配的方法：$(0,\\frac {sum}{2})$，$(1,\\frac {sum}{2}+1)$… $ans=\\frac {sum}{2}$否则除了数量最多的袜子外，其他的都能找到错误匹配，$ans=sum-mx$ J. Postman问邮递员送信的最短路程。贪心策略：从最远点往里面遍历，如果当前点数量不超过容量，那么在搭上相邻位置的信封数量。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1000 + 5;struct House &#123; int x, m; bool operator &lt; (const House &amp;rhs) const &#123; return x &lt; rhs.x; &#125;&#125;h[N];int n, k;void debug() &#123; for (int i=1; i&lt;=n; ++i) &#123; printf(\"(%d,%d)\\n\", h[i].x, h[i].m); &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;k); int c = 0; for (int i=1; i&lt;=n; ++i) &#123; ++c; scanf(\"%d%d\", &amp;h[c].x, &amp;h[c].m); if (!h[c].x) c--; &#125; n = c; h[++n].x = 0; sort(h+1, h+n+1); int p = 1; for (int i=1; i&lt;=n; ++i) if (!h[i].x) &#123; p = i; break; &#125; ll ans = 0, free = 0; int i = 1; for (; i&lt;p; i++) &#123; ll mn = min(free, (ll)h[i].m); h[i].m -= mn; free -= mn; ll dis = -h[i].x; ll cnt = h[i].m / k; if (h[i].m % k) &#123; cnt++; free += k - (h[i].m % k); &#125; ans += dis * cnt * 2; &#125; i = n; free = 0; for (; i&gt;p; --i) &#123; ll mn = min(free, (ll)h[i].m); h[i].m -= mn; free -= mn; ll dis = h[i].x; ll cnt = h[i].m / k; if (h[i].m % k) &#123; cnt++; free += k - (h[i].m % k); &#125; ans += dis * cnt * 2; &#125; printf(\"%I64d\\n\", ans); return 0;&#125; K. Six Sides抛六面的骰子，问第一个人赢的概率。简单概率计算，注意总局数去掉平局的次数。 L. Three Square三个矩形能否组成正四边形。简单暴力枚举。 M. Zigzag求最长折线子序列。$dp[i][0/1]$表示从$i$开始下降/上升的最长长度，记忆化搜索即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 50 + 5;int a[N];int dp[N][2];int s[N], g[N];int n, ans;void Max(int &amp;x, int y) &#123; if (x &lt; y) x = y;&#125;int DFS(int i, int up) &#123; if (i &gt;= n) return dp[n][up] = 1; if (dp[i][up] != -1) return dp[i][up]; int &amp;ret = dp[i][up] = 1; for (int j=i+1; j&lt;=n; ++j) &#123; if (up &amp;&amp; a[j] &gt; a[i]) Max(ret, DFS(j, up^1)+1); else if (!up &amp;&amp; a[j] &lt; a[i]) Max(ret, DFS(j, up^1)+1); &#125; return ret;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i=1; i&lt;=n; ++i) &#123; scanf(\"%d\", &amp;a[i]); &#125; memset(dp, -1, sizeof(dp)); ans = 1; for (int i=1; i&lt;=n; ++i) &#123; if (dp[i][1] == -1) &#123; for (int j=i+1; j&lt;=n; ++j) if (a[j] &gt; a[i]) &#123; Max(dp[i][1], DFS(j, 0)+1); &#125; &#125; if (dp[i][0] == -1) &#123; for (int j=i+1; j&lt;=n; ++j) if (a[j] &lt; a[i]) &#123; Max(dp[i][0], DFS(j, 1)+1); &#125; &#125; Max(ans, dp[i][1]); Max(ans, dp[i][0]); &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"},{"name":"DFS","slug":"DFS","permalink":"https://sea96.github.io/tags/DFS/"},{"name":"STL","slug":"STL","permalink":"https://sea96.github.io/tags/STL/"},{"name":"位运算","slug":"位运算","permalink":"https://sea96.github.io/tags/位运算/"},{"name":"概率","slug":"概率","permalink":"https://sea96.github.io/tags/概率/"},{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"}]},{"title":"Egyptian Collegiate Programming Contest (ECPC 2015)","slug":"Egyptian-Collegiate-Programming-Contest-ECPC-2015","date":"2017-03-23T01:11:10.000Z","updated":"2017-05-13T05:23:00.907Z","comments":true,"path":"2017/03/23/Egyptian-Collegiate-Programming-Contest-ECPC-2015/","link":"","permalink":"https://sea96.github.io/2017/03/23/Egyptian-Collegiate-Programming-Contest-ECPC-2015/","excerpt":"A. Arcade Game题意给一个$n$位的数字，每一次等概率地变成按照数位全排列的某一个排列（各个位的数不同），要求变换后的数字比之前的大，问最终变成最大排列形式的数字的概率。","text":"A. Arcade Game题意给一个$n$位的数字，每一次等概率地变成按照数位全排列的某一个排列（各个位的数不同），要求变换后的数字比之前的大，问最终变成最大排列形式的数字的概率。 数据$1 \\leq n \\leq 9$ 题解设数字在全排列的位置为$k$，它最终变成最大数字的概率为$p_k$，那么$p_k = (\\sum_{j=k+1}^{n!}p_j) \\frac {1}{n!}$，$p_{n!}=1.0$（如果一开始的数字就是最大值，那么概率为0）。发现公式是关于计算后缀的和，可以迭代计算，每次更新后缀概率总和，在$O(n!-k)$时间复杂度解决。code B. Unlucky Teacher判断选择题哪个是正确答案，因为答案唯一，所以如果答案已给出，或者知道有三个选项是错误的就能知道答案。 C. Connecting Graph题意数据题解并查集 D. Frozen Rivers简单树形DP，状态转移方程：$dp[u]=(dp[v_{min}]+w_{min})+\\sum (dp[v]+w_{min}+(w-w_{min})*2)$ E. Palmyra题意有$n×m$的格子，每个格子上有一个数字$x_{i,j}$。问从(1,1)出发，每次往右走一格或者往下走一格，达到(n,m)后得到$(n+m-1)$个数字的乘积的6进制最多有几个后缀0。 数据$ 2 \\leq n,m \\leq 100 $$ 1 \\leq x_{i,j} \\leq 10^3 $ 题解在6进制产生后缀0的条件是有2和3的因子，所以也就是要在$(n+m-1)$步里得到尽可能多的2和3，但不是得到最多的2或者3就好，因为答案是$min(cnt_2,cnt_3)$。因为二元的最值，考虑其中一元用数组存储。设$dp[i][j][k]$表示从(1,1)出发到(i,j)为止，一共获得k个3，最多能获得2的数量。那么状态转移方程：$$ dp[i][j][k] = max(dp[i][j-1][k-x[i][j].three],dp[i-1][j][k-x[i][j].three])+x[i][j].two $$code F. Geometry水题，给长和宽，判断是正方形还是长方形。 G. It is all about wisdom题意数据题解二分+最短路 H. Tonight Dinner题意数据题解I. Salem水题，计算两个数字在二进制表示下不同的位的个数。dist = __builtin_popcount(x^y) J. Game简单博弈题，每个人有两种操作： LEFT：从右往左，相邻两个合并成一个 RIGHT：从左往右，相邻两个合并成一个 当剩下一个字母游戏结束，如果是元音字母则先手胜，否则后手胜利。这个胜利条件和一般的博弈稍微有点不同，需要判断当前状态是先手还是后手的turn。 K. PhD Math题意数据题解数位DP L. Candy Jars题意数据题解博弈 M. Building Force Fields题意数据题解","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"},{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"概率","slug":"概率","permalink":"https://sea96.github.io/tags/概率/"},{"name":"博弈","slug":"博弈","permalink":"https://sea96.github.io/tags/博弈/"},{"name":"并查集","slug":"并查集","permalink":"https://sea96.github.io/tags/并查集/"}]},{"title":"AtCoder Regular Contest 070","slug":"AtCoder-Regular-Contest-070","date":"2017-03-20T00:16:43.000Z","updated":"2017-05-13T05:22:26.335Z","comments":true,"path":"2017/03/20/AtCoder-Regular-Contest-070/","link":"","permalink":"https://sea96.github.io/2017/03/20/AtCoder-Regular-Contest-070/","excerpt":"C. Go Home题意从0的位置出发，第$i$秒能往前或往后跳$i$步，也可以选择不跳，问跳到$X$位置的最短时间。","text":"C. Go Home题意从0的位置出发，第$i$秒能往前或往后跳$i$步，也可以选择不跳，问跳到$X$位置的最短时间。 数据$1≤X≤10^9$ 题解答案就是满足$\\sum_{i=1}^{n}i \\geq X$的最小的$n$。如果恰好相等那一定最优；如果大于的话，一定可以找到$k$（k&lt;n），使得$(\\sum_{i=1}^{n}i)-k = X$，那么第$k$秒不跳就可以了。 D. No Need题意有$N$个数字，第$i$个数字的值是$a_i$。定义$N$个数字的子集满足子集内的数字和不小于$K$，如果某一个子集里去掉一个数字后依然满足条件，那么去掉的数字是unnecessary。问unnecessary的数字的个数。 数据$1 \\leq N \\leq 5000 $$1 \\leq K \\leq 5000 $$1 \\leq a_i \\leq 10^9 (1≤i≤N)$ 题解如果$a_i$是necessary，那么在其它$N-1$个数字的子集里存在和的区间在$[K-a_i,K)$范围内。那么可以用$O(N^3)$的DP来做。优化： 注意到如果$a_p &lt; a_q$并且$a_q$是unnecessary，那么$a_p$也一定是unnecessary。二分边界可以将复杂度降到$O(N^2logN)$；如果用bitset判断和是否存在的话，复杂度为$O(\\frac{N^2logN}{32})$ 从最大值往最小值遍历，维护一个最大前缀子集和S，S的区间在$[K-a_i,K)$内，如果$S+a_i \\geq K$，那么$a_i$是necessary，否则是unnecessary，并且$S+=a_i$。时间复杂度：$O(N)$ code1code2","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"},{"name":"位运算","slug":"位运算","permalink":"https://sea96.github.io/tags/位运算/"}]},{"title":"Gym 100676H Capital City","slug":"Gym-100676H-Capital-City","date":"2017-03-16T01:08:02.000Z","updated":"2017-05-13T01:14:22.482Z","comments":true,"path":"2017/03/16/Gym-100676H-Capital-City/","link":"","permalink":"https://sea96.github.io/2017/03/16/Gym-100676H-Capital-City/","excerpt":"题意有$n$个点$m$条边的无向图，每条边上有权值$w$，问一个点的序号，满足从这个点出发到其他点的最大距离最小（在环上走的距离为0），如果有多个，取序号最小的点。","text":"题意有$n$个点$m$条边的无向图，每条边上有权值$w$，问一个点的序号，满足从这个点出发到其他点的最大距离最小（在环上走的距离为0），如果有多个，取序号最小的点。 数据$1 \\leq n \\leq 10^5$$ 0 \\leq m \\leq 2*10^5$$ 1 \\leq w \\leq 10^5$ 题解对无向图求边-双联通分量进行缩环，问题转换为树上找一个点使得到其他点的最大距离最小。可以用dp，两次DFS得到每一个点到其他点的最大距离。但是只需要找一个点，那么这个点一定在树的直径上，处理出每一个点到直径的两个端点的距离即可，时间复杂度：$O(n+m)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 5;const int M = 2e5 + 5;struct Edge &#123; int v, w, nex, cut;&#125;edges[M&lt;&lt;2];int head[N], head2[N];vector&lt;int&gt; bcc[N];int dfn[N], bcc_no[N];int sta[N], top;int id[N];int dfs_clock, bcc_cnt;int n, m, etot;void init_edge() &#123; memset(head, -1, sizeof(head)); memset(head2, -1, sizeof(head2)); etot = 0;&#125;inline void add_edge(int u, int v, int w, int *head) &#123; edges[etot] = Edge&#123;v, w, head[u], 0&#125;; head[u] = etot++;&#125;int Tarjan(int u, int fa) &#123; int lowu = dfn[u] = ++dfs_clock; sta[top++] = u; for (int i=head[u]; ~i; i=edges[i].nex) &#123; int v = edges[i].v; if (!dfn[v]) &#123; int lowv = Tarjan(v, u); lowu = min(lowu, lowv); &#125; else if (dfn[v] &lt; dfn[u] &amp;&amp; v != fa) &#123; lowu = min(lowu, dfn[v]); &#125; &#125; //桥 if (lowu == dfn[u]) &#123; bcc[++bcc_cnt].clear(); int v; do &#123; v = sta[--top]; bcc[bcc_cnt].push_back(v); bcc_no[v] = bcc_cnt; &#125; while (v != u); &#125; return lowu;&#125;void find_bcc() &#123; memset(dfn, 0, sizeof(dfn)); memset(bcc_no, 0, sizeof(bcc_no)); dfs_clock = top = bcc_cnt = 0; Tarjan(1, -1);&#125;ll d[N], d1[N], d2[N];void DFS(int u, int fa, ll *dis) &#123; for (int i=head2[u]; ~i; i=edges[i].nex) &#123; int v = edges[i].v, w = edges[i].w; if (v == fa) continue; dis[v] = dis[u] + w; DFS(v, u, dis); &#125;&#125;void solve() &#123; find_bcc(); if (bcc_cnt == 1) &#123; puts(\"1 0\"); return ; &#125; for (int i=1; i&lt;=bcc_cnt; ++i) &#123; id[i] = (int)(1e9); for (int x: bcc[i]) &#123; id[i] = min(id[i], x); for (int j=head[x]; ~j; j=edges[j].nex) &#123; int y = edges[j].v, z = edges[j].w; if (bcc_no[y] == i) continue; add_edge(i, bcc_no[y], z, head2); &#125; &#125; &#125; int x = bcc_no[1]; d[x] = 0; DFS(x, 0, d); x = -1; for (int i=1; i&lt;=n; ++i) &#123; int v = bcc_no[i]; if (x == -1 || d[x] &lt; d[v]) x = v; &#125; d1[x] = 0; DFS(x, 0, d1); int y = -1; for (int i=1; i&lt;=n; ++i) &#123; int v = bcc_no[i]; if (y == -1 || d1[y] &lt; d1[v]) y = v; &#125; d2[y] = 0; DFS(y, 0, d2); int ans = -1; ll len = (ll)(1e18); for (int i=1; i&lt;=n; ++i) &#123; int v = bcc_no[i]; ll md = max(d1[v], d2[v]); if (ans == -1 || len &gt; md) &#123; ans = id[v]; len = md; &#125; else if (md == len &amp;&amp; ans &gt; id[v]) ans = id[v]; &#125; printf(\"%d %I64d\\n\", ans, len);&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); init_edge(); for (int i=1; i&lt;=m; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); add_edge(u, v, w, head); add_edge(v, u, w, head); &#125; solve(); &#125; return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"},{"name":"DFS","slug":"DFS","permalink":"https://sea96.github.io/tags/DFS/"},{"name":"树的直径","slug":"树的直径","permalink":"https://sea96.github.io/tags/树的直径/"}]},{"title":"Gym 100676G Training Camp","slug":"Gym-100676G-Training-Camp","date":"2017-03-16T00:30:03.000Z","updated":"2017-05-13T05:23:04.626Z","comments":true,"path":"2017/03/16/Gym-100676G-Training-Camp/","link":"","permalink":"https://sea96.github.io/2017/03/16/Gym-100676G-Training-Camp/","excerpt":"题意一个人要读$n$个topic，每天一个topic。在第$k$天读第$x$个topic得到的level是$k*w[x]$，现在有$m$个约束，即读topic的顺序，问得到的最大的level是多少。","text":"题意一个人要读$n$个topic，每天一个topic。在第$k$天读第$x$个topic得到的level是$k*w[x]$，现在有$m$个约束，即读topic的顺序，问得到的最大的level是多少。 数据$1 \\leq n \\leq 18$$ 1 \\leq w \\leq 100$ 题解很容易想到是拓扑排序，如果使用贪心策略每次取出$w$最小的，用优先队列实现，但是这个是错误的，因为只保证了当前的最优解，没有保证全局最优解。所以考虑dp的方法，注意到$n$的数据范围很小，自然想到用状态压缩dp，状态转移的条件和拓扑排序一样，入度为0的时候才能转移。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 20;map&lt;string, int&gt; ID;struct Edge &#123; int u, v;&#125;;vector&lt;Edge&gt; edges;int dp[(1&lt;&lt;18)+5];bool vis[N];int w[N];int deg[N];int n, m;int solve() &#123; memset(dp, 0, sizeof(dp)); for (int mask=0; mask&lt;(1&lt;&lt;n); ++mask) &#123; memset(vis, false, sizeof(vis)); for (int i=0; i&lt;n; ++i) if (mask &amp; (1&lt;&lt;i)) vis[i] = true; int day = __builtin_popcount(mask); bool flag = true; memset(deg, 0, sizeof(deg)); for (auto e: edges) &#123; if (!vis[e.u] &amp;&amp; vis[e.v]) &#123; flag = false; break; &#125; if (!vis[e.u]) deg[e.v]++; &#125; if (!flag) continue; for (int i=0; i&lt;n; ++i) &#123; if (!vis[i] &amp;&amp; !deg[i]) &#123; dp[mask|(1&lt;&lt;i)] = max(dp[mask|(1&lt;&lt;i)], dp[mask]+(day+1)*w[i]); &#125; &#125; &#125; return dp[(1&lt;&lt;n)-1];&#125;int main() &#123; int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n &gt;&gt; m; edges.clear(); ID.clear(); string topic, topic2, tmp; getline(cin, tmp); for (int i=0; i&lt;n; ++i) &#123; w[i] = 0; topic = \"\"; getline(cin, tmp); for (int j=0; j&lt;tmp.length(); ++j) &#123; if (tmp[j] &gt;= '0' &amp;&amp; tmp[j] &lt;= '9') &#123; w[i] = w[i]*10 + (tmp[j]-'0'); &#125; else topic += tmp[j]; &#125; ID[topic] = i; &#125; edges.clear(); for (int i=1; i&lt;=m; ++i) &#123; getline(cin, tmp); topic = topic2 = \"\"; bool fir = true; for (int j=0; j&lt;tmp.length(); ++j) &#123; if (tmp[j] == '-') &#123; j += 3; fir = false; &#125; else &#123; if (fir) topic += tmp[j]; else topic2 += tmp[j]; &#125; &#125; topic2 += ' '; edges.push_back(Edge&#123;ID[topic], ID[topic2]&#125;); &#125; cout &lt;&lt; solve() &lt;&lt; '\\n'; &#125; return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"},{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"位运算","slug":"位运算","permalink":"https://sea96.github.io/tags/位运算/"}]},{"title":" AtCoder Grand Contest 011","slug":"AtCoder-Grand-Contest-011","date":"2017-03-15T03:20:18.000Z","updated":"2017-05-13T01:33:38.971Z","comments":true,"path":"2017/03/15/AtCoder-Grand-Contest-011/","link":"","permalink":"https://sea96.github.io/2017/03/15/AtCoder-Grand-Contest-011/","excerpt":"A. Airport Bus题意有$n$个人在等车，第$i$个人的等车时间为$[t_i,t_i+k]$，每辆车最多能载$c$个人。问所有人都上车最少需要多少辆车。","text":"A. Airport Bus题意有$n$个人在等车，第$i$个人的等车时间为$[t_i,t_i+k]$，每辆车最多能载$c$个人。问所有人都上车最少需要多少辆车。 数据$2≤n≤10^5$$1≤c≤10^9$$1≤k≤10^9$$1≤ti≤10^9$ 题解贪心的策略：凑齐$c$个人或者有人等不了就上车。显然上车时间在$t_i$或者$t_i+k$端点上更优。对$t_i$从小到大排序，双指针扫描一遍即可，时间复杂度：$O(nlogn)$code B. Colorful Creatures题意有$n$个生物，每个生物的大小为$a_i$。一个生物$i$能吸收另一个生物$j$的条件是：$2a_i\\geq a_j$，吸收后生物$i$的大小变成$a_i+a_j$，问有多少个生物可以吸收其他所有生物。 数据$2≤n≤10^5$$1≤a_i≤10^9$ 题解对$a_i$从小到大排序，那么也就是要找到最小的$j$，满足第$j$个生物可以吸收其他所有生物（吸收的顺序从小到大最优），符合二分的性质，所以答案就是$n-j+1$，时间复杂度：$O(nlogn)$更好的做法是求最大的$k$满足$2\\sum_{k=1}^{i} a_k &lt; a_{k+1}$，也就是求满足条件的最大的后缀长度，可以在$O(n)$时间复杂度解决。code C. Squared GraphD. Half ReflectorE. Increasing Numbers","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"},{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"},{"name":"组合数学","slug":"组合数学","permalink":"https://sea96.github.io/tags/组合数学/"},{"name":"数学","slug":"数学","permalink":"https://sea96.github.io/tags/数学/"}]},{"title":"2015-2016 ACM ICPC Baltic Selection Contest","slug":"2015-2016-ACM-ICPC-Baltic-Selection-Contest","date":"2017-03-11T01:47:32.000Z","updated":"2017-06-13T14:29:11.416Z","comments":true,"path":"2017/03/11/2015-2016-ACM-ICPC-Baltic-Selection-Contest/","link":"","permalink":"https://sea96.github.io/2017/03/11/2015-2016-ACM-ICPC-Baltic-Selection-Contest/","excerpt":"","text":"A. AHB求数位上相减的绝对值，注意0的特殊情况。 B. Wet Boxes暂时不会，Wannafly Union Goodbye 2016 F C. Minimax Tree题意有$n$个点的一颗树，叶子结点上有权值$a_i$，在非叶子结点上贴取最大或最小标签，最大标签有$k$个，问根节点能获得的最大值和最小值。 数据$2 \\leq n \\leq 10^5$$0 \\leq a_i \\leq 10^9$$k+l \\leq n$ 题解简单的思路是：二分答案，dp求得获得该值最少需要多少个最值标签，判断是否小于给定的数量。另一种贪心思路是：如果某个最大值要传到根节点，那么到根节点的路径上，有分叉处只能贴上max标签，那么其余的地方贴上min标签。 代码dp+binary search123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;const int INF = 0x3f3f3f3f;vector&lt;int&gt; edge[N];int a[N];int n, k, l;int ans1, ans2;int DFS(int u, int fa, int m, int tp) &#123; if (a[u]) &#123; if (tp) return a[u] &gt;= m ? 0 : INF; else return a[u] &lt;= m ? 0 : INF; &#125; int need = 0, son = 0, tot = 0, mn = INF; for (int v: edge[u]) if (v != fa) &#123; int res = DFS(v, u, m, tp); if (res) need++; son++; mn = min(mn, res); &#125; if (mn == INF) return INF; if (!need) return 0; if (son == 1) return mn; else return mn+1;&#125;bool check(int m, int tp) &#123; return DFS(1, 0, m, tp) &lt;= k;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i=2; i&lt;=n; ++i) &#123; int p; scanf(\"%d\", &amp;p); edge[p].push_back(i); &#125; l = 0; for (int i=1; i&lt;=n; ++i) &#123; scanf(\"%d\", &amp;a[i]); if (a[i]) l++; &#125; int low = -1, high = (int)(1e9+5); while (low &lt; high) &#123; int mid = low + high &gt;&gt; 1; if (check(mid, 0)) &#123; ans1 = mid; high = mid; &#125; else low = mid+1; &#125; k = n - k - l; low = -1, high = (int)(1e9+5); while (low &lt; high) &#123; int mid = low + high &gt;&gt; 1; if (check(mid, 1)) &#123; ans2 = mid; low = mid+1; &#125; else high = mid; &#125; printf(\"%d %d\\n\", ans1, ans2); return 0;&#125; greedy123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;const int INF = 0x3f3f3f3f;vector&lt;int&gt; edge[N];int n, k, l;int mx[N], mn[N], son[N];int ans1, ans2;void DFS(int u, int fa, int dep) &#123;// if (edge[u].size() == 1) return ; for (int v: edge[u]) if (v != fa) &#123; if (son[u] == 1) DFS(v, u, dep); else DFS(v, u, dep+1); mx[u] = max(mx[u], mx[v]); mn[u] = min(mn[u], mn[v]); &#125; if (dep-1 &lt;= k) ans1 = min(ans1, mx[u]); if (dep-1 &lt;= n-k-l) ans2 = max(ans2, mn[u]);&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i=2; i&lt;=n; ++i) &#123; int p; scanf(\"%d\", &amp;p); edge[p].push_back(i); son[p]++; &#125; memset(mn, INF, sizeof(mn)); l = 0; for (int i=1; i&lt;=n; ++i) &#123; int x; scanf(\"%d\", &amp;x); if (x) &#123; mx[i] = mn[i] = x; l++; &#125; &#125; ans1 = INF; ans2 = 0; DFS(1, 0, 1); printf(\"%d %d\\n\", ans1, ans2); return 0;&#125; D. Journey简单BFS即可。 E. Permutation Polygon题意有$n$个点的正多边形，每一个顶点i都和另一个顶点$p_i$有线段相连，$p_1，p_2…p_n$是$n$的一个排列。问线段相交点的数量（重叠的算多个）。 数据$3\\leq n \\leq 10^5$$i \\neq p_i$ 题解定义一条线段为：$(x,y)$，并且$x&lt;y$。线段相交的条件是：若$x_1&lt;x_2$，则$y_1&lt;y2$按照线段的$x$从小到大排序，对于当前的线段(x,y)，只要统计y’的数量，满足条件：$x&lt;y’&lt;y$，就能知道有多少个相交点，可以用树状数组维护。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 1e5 + 5;int C[N];vector&lt;pii&gt; vec;int n;void modify(int i) &#123; for (; i&lt;=n; i+=i&amp;-i) C[i] += 1;&#125;int query(int i) &#123; int ret = 0; for (; i; i-=i&amp;-i) ret += C[i]; return ret;&#125;int sum(int l, int r) &#123; return query(r) - query(l-1);&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i=1; i&lt;=n; ++i) &#123; int p, q = i; scanf(\"%d\", &amp;p); if (p &gt; q) swap(p, q); if (q - p &lt;= 1 || (p==1 &amp;&amp; q==n)) continue; vec.push_back(pii(p, q)); &#125; sort(vec.begin(), vec.end());// vec.erase(unique(vec.begin(), vec.end()), vec.end()); int m = vec.size(); int ans = 0; for (int i=0; i&lt;m; ++i) &#123; ans += sum(vec[i].first+1, vec[i].second-1); vector&lt;int&gt; tmp; tmp.push_back(vec[i].second); ++i; while (i &lt; m &amp;&amp; vec[i].first == vec[i-1].first) &#123; ans += sum(vec[i].first+1, vec[i].second-1); tmp.push_back(vec[i].second); i++; &#125; for (auto p: tmp) modify(p); i--; &#125; printf(\"%d\\n\", ans); return 0;&#125; F. Unusual Sum定义$s(n)=\\sum \\limits_{k=1}^{n}\\frac{1}{k^2+k}=\\frac{n-1}{n}$$\\sum \\limits_{k=l_i}^{r_i}\\frac{1}{k^2+k}=s(r_i)-s(l_i-1)$ G. Robot Walk简单模拟 H. Game of Corners$ans=n*m+min(n,m)$智商题？ I. Shell Game问杯子里放球的最大半径。二分答案或者推公式。 J. Narrow Bus题意模拟公交车的乘客上下车过程，$n$个操作： “F”：一个乘客从前门上车 ”B“：一个乘客从后门上车 ”O i”：第i个乘客从人数少的门下车，被挤出去的乘客顺序不改变地从另一个重新上车。 数据$1\\leq n \\leq 10^5$ 题解用Splay的序列分裂和合并模拟这个过程。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;struct Node &#123; Node *ch[2], *fa; //儿子，父亲 int s; Node() &#123; s = 0; &#125; //给null初始化 int d() &#123; return fa-&gt;ch[1]==this; //判断自己是哪个儿子 &#125; void setc(Node* c, int d) &#123; ch[d] = c; c-&gt;fa = this; //指定儿子 &#125; void up() &#123; s = ch[0]-&gt;s + ch[1]-&gt;s + 1; //向上更新 &#125;&#125;Tnull, *null = &amp;Tnull;Node pool[N], *node = pool;Node* new_node() &#123; Node *o = node++; o-&gt;ch[0] = o-&gt;ch[1] = o-&gt;fa = null; o-&gt;s = 1; return o;&#125;//将节点o向上旋转void rotate(Node* o) &#123; Node* p = o-&gt;fa; int d = o-&gt;d(); p-&gt;fa-&gt;setc(o, p-&gt;d()); p-&gt;setc(o-&gt;ch[d^1], d); o-&gt;setc(p, d^1); p-&gt;up();&#125;//将节点o伸展到p的儿子的位置void splay(Node* o, Node *p = null) &#123; while (o-&gt;fa != p) &#123; if (o-&gt;fa-&gt;fa == p) rotate(o); else &#123; //三点共线：先旋转父亲，再旋转o；不共线：o旋转两次 if (o-&gt;d() == o-&gt;fa-&gt;d()) rotate(o-&gt;fa), rotate(o); else rotate(o), rotate(o); &#125; &#125; o-&gt;up();&#125;//找到以o为根的树上第k小Node* kth(Node* o, int k) &#123; while (1) &#123; int c = 1 + o-&gt;ch[0]-&gt;s; if (k == c) return o; if (k &gt; c) &#123; k -= c; o = o-&gt;ch[1]; &#125; else o = o-&gt;ch[0]; &#125; return null;&#125;//将前k小放到左子树，其它的放到右子树void split(Node* o, int k, Node* &amp;left, Node* &amp;right) &#123; if (k == 0) &#123; left = null; right = o; &#125; else if (k == o-&gt;s) &#123; left = o; right = null; &#125; else &#123; //先找到分裂节点，伸展到根再分裂 right = kth(o, k+1); splay(right); left = right-&gt;ch[0]; right-&gt;ch[0] = right-&gt;fa = null; right-&gt;up(); &#125;&#125;void merge(Node* &amp;o, Node* left, Node* right) &#123; if (left == null) o = right; else if (right == null) o = left; else &#123; o = kth(left, left-&gt;s); splay(o); o-&gt;setc(right, 1); o-&gt;up(); &#125;&#125;int n, m;Node* id[N];int main() &#123; scanf(\"%d\", &amp;m); Node* root = null; while (m--) &#123; char str[10]; scanf(\"%s\", str); if (str[0] == 'O') &#123; int x; scanf(\"%d\", &amp;x); splay(id[x]); id[x]-&gt;ch[0]-&gt;fa = id[x]-&gt;ch[1]-&gt;fa = null; int d = id[x]-&gt;ch[0]-&gt;s &lt;= id[x]-&gt;ch[1]-&gt;s ? 0 : 1; printf(\"%d\\n\", id[x]-&gt;ch[d]-&gt;s); merge(root, id[x]-&gt;ch[1], id[x]-&gt;ch[0]); &#125; else &#123; id[++n] = new_node(); if (str[0] == 'F') merge(root, id[n], root); else merge(root, root, id[n]); &#125; &#125; return 0;&#125; K. Profact判断一个数是否为一个或若干个数的阶乘的乘积。注意到 $20！&gt; 10^{18} $，预处理出所有符合情况的答案，用set保存和查询即可。 L. Emoticons相邻两项判断即可。","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"},{"name":"伸展树","slug":"伸展树","permalink":"https://sea96.github.io/tags/伸展树/"}]},{"title":"HackRank Lena Sort","slug":"HackRank-Lena-Sort","date":"2017-03-04T00:58:03.000Z","updated":"2017-05-13T01:11:25.379Z","comments":true,"path":"2017/03/04/HackRank-Lena-Sort/","link":"","permalink":"https://sea96.github.io/2017/03/04/HackRank-Lena-Sort/","excerpt":"题意有一个排序算法伪码如下：","text":"题意有一个排序算法伪码如下： 12345678910111213141516171819202122lena_sort(array nums) &#123; if (nums.size &lt;= 1) &#123; return nums; &#125; pivot = nums[0]; array less; array more; for (i = 1; i &lt; nums.size; ++i) &#123; // Comparison if (nums[i] &lt; pivot) &#123; less.append(nums[i]); &#125; else &#123; more.append(nums[i]); &#125; &#125; sorted_less = lena_sort(less); sorted_more = lena_sort(more); ans = sorted_less + pivot + sorted_more; return ans;&#125; 有$q$次询问，构造一组长度为$len$的序列，使其排序完成后恰好与pivot比较$c$次，无解输出 -1。 数据$1 \\leq q\\leq 10^5$$1 \\leq len \\leq 10^5$$1\\leq a_i \\leq 10^9$$0 \\leq c \\leq 10^9$ 题解官方题解官方题解说得很详细了，把每个数字看成一个节点，节点的左儿子比它小，右儿子比它大，变成一棵二叉树，那么比较次数总和为所有节点在树的深度和。那么次数总和的上界情况是树退化成一条链（序列是单调序列），下界情况是完全二叉树。预处理出所有长度对应比较次数的上下界，如果在范围内，总能构造出一棵比较次数为$c$的二叉树。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;//#define DEBUG(x) cout &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; x &lt;&lt; endltypedef long long ll;const int N = 1e5 + 5;ll mn[N], mx[N];int q, n;ll c;void solve(int st, int len, ll tot) &#123; if (len &lt; 3) &#123; for (int i=0; i&lt;len; ++i) &#123; printf(\"%d \", st+i); &#125; return ; &#125; tot -= (len-1); for (int i=0; i&lt;len; ++i) &#123; if (tot &lt; mn[i]+mn[len-1-i] || tot &gt; mx[i]+mx[len-1-i]) continue; printf(\"%d \", st+i); ll tot_l = max(mn[i], tot-mx[len-1-i]); solve(st, i, tot_l); solve(st+i+1, len-1-i, tot-tot_l); return ; &#125;&#125;int main() &#123; mn[2] = mx[2] = 1; for (int i=3; i&lt;=100000; ++i) &#123; mx[i] = (ll)i*(i-1)/2; mn[i] = mn[i/2]+mn[(i-1)/2]+(i-1); &#125; scanf(\"%d\", &amp;q); while (q--) &#123; scanf(\"%d%lld\", &amp;n, &amp;c); if (c &lt; mn[n] || c &gt; mx[n]) puts(\"-1\"); else &#123; solve(1, n, c); puts(\"\"); &#125; &#125; return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://sea96.github.io/tags/组合数学/"},{"name":"二叉树","slug":"二叉树","permalink":"https://sea96.github.io/tags/二叉树/"}]},{"title":"Codeforces 468C Hack it!","slug":"Codeforces-468C-Hack-it","date":"2017-03-03T08:42:28.000Z","updated":"2017-05-13T01:30:28.380Z","comments":true,"path":"2017/03/03/Codeforces-468C-Hack-it/","link":"","permalink":"https://sea96.github.io/2017/03/03/Codeforces-468C-Hack-it/","excerpt":"题意定义$f(n)$表示$n$的数位和，求一组$[l,r]$$(1 \\leq l,r &lt; 10^{200})$，使得$\\sum\\limits_{i=l}^rf(i)\\equiv 0\\pmod a$$(1\\leq a\\leq 10^{18})$。","text":"题意定义$f(n)$表示$n$的数位和，求一组$[l,r]$$(1 \\leq l,r &lt; 10^{200})$，使得$\\sum\\limits_{i=l}^rf(i)\\equiv 0\\pmod a$$(1\\leq a\\leq 10^{18})$。 题解记$s(n)=\\sum\\limits_{i=1}^{n}f(i)$，计算$s(n)$只要把每一个数位对答案的贡献加起来即可。 构造：注意到$f(x+10^{18})=f(x)+1$，那么$s(x+10^{18})=s(10^{18})+s(x)+x$，即$s(x+10^{18})-s(x)=s(10^{18})+x$。令$s(10^{18})+x=a$，即$x=a-s(10^{18})$，构造出一组解：$L=x+1$，$R=x+10^{18}$。 二分方法： 我们只需找到$s(R)%a = s(L-1)%a$就美滋滋了。我们使用二分查询找到最小的且满足$g(R)&gt;=a$的值$R$，接下来令$L=1$，然后跑一个双指针,调整L,R的值即可。 时间复杂度：$O(?)$ 官方题解 代码123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a;int main() &#123; scanf(\"%I64d\", &amp;a); //s(1e18) ll s = ((3*(3*(3*(3*(5*(2*((ll)1e17%a))%a)%a)%a)%a)%a)%a+1)%a; ll x = a - s; ll L = x + 1, R = x + (ll)(1e18); printf(\"%I64d %I64d\\n\", L, R); return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"数学","slug":"数学","permalink":"https://sea96.github.io/tags/数学/"},{"name":"构造","slug":"构造","permalink":"https://sea96.github.io/tags/构造/"}]},{"title":"Codeforces 493E Vasya and Polynomial","slug":"Codeforces-493E-Vasya-and-Polynomial","date":"2017-03-02T12:09:49.000Z","updated":"2017-05-13T01:29:15.351Z","comments":true,"path":"2017/03/02/Codeforces-493E-Vasya-and-Polynomial/","link":"","permalink":"https://sea96.github.io/2017/03/02/Codeforces-493E-Vasya-and-Polynomial/","excerpt":"题意有一个多项式$P(x) = a_0 + a_1x^1 + … + a_nx^n$，$a_i$为非负整数。给定$t$,$a$,$b$ $(0 &lt; t,a,b \\leq 10^{18})$，问存在多少多项式满足$P(t) = a$, $P(P(t)) = b$，对方案数 mod $10^9+7$，如果有无穷多个，那么输出inf。","text":"题意有一个多项式$P(x) = a_0 + a_1x^1 + … + a_nx^n$，$a_i$为非负整数。给定$t$,$a$,$b$ $(0 &lt; t,a,b \\leq 10^{18})$，问存在多少多项式满足$P(t) = a$, $P(P(t)) = b$，对方案数 mod $10^9+7$，如果有无穷多个，那么输出inf。 题解根据$P(t)=a$，并且$t&gt;0$，可知$\\sum_{i=0}^{n}a_i \\leq a$。 当$t&gt;1$时，所有系数$a_i&lt;a$，$P(P(t)) = P(a) = b$，相当于告诉了$b$在$a$进制的表示，且是唯一的，所以可以先求出所有系数$a_i$，然后验证$P(t)=a$是否成立即可。 当$t=1$时，如果存在$a_k=a$，那么$a_j=0$$(j \\neq k)$，那么$$P(t=1)=a_kt^k=a_k=a$$ $$P(a)=a_ka^k=a^{k+1}=b$$ 当且仅当$a=b=1$时对于任意$k$成立，否则只要验证$b$是$a$的正整数次幂即可。如果任意系数$a_{i} &lt; a$，问题在$t&gt;1$时已经解决。 特判$P(x)=a_0$的情况。代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll t, a, b;//t &gt; 1 || another caseint solve() &#123; ll p = 0, x = 1, r = b; int cnt = 0; for (; r; r/=a) &#123; p += r % a * x; x *= t; cnt++; if (cnt &gt; 100) break; &#125; return (p==a) + (cnt &gt; 1 &amp;&amp; a==b);&#125;int main() &#123; cin &gt;&gt; t &gt;&gt; a &gt;&gt; b; if (t == 1) &#123; if (a == 1) &#123; if (b == 1) cout &lt;&lt; \"inf\" &lt;&lt; '\\n'; else cout &lt;&lt; 0 &lt;&lt; '\\n'; &#125; else &#123; bool ok = false; ll p = 1; while (p &lt;= b/a) &#123; p *= a; if (p == b) ok = true; &#125; if (ok) cout &lt;&lt; 1 &lt;&lt; '\\n'; else cout &lt;&lt; solve() &lt;&lt; '\\n'; &#125; &#125; else cout &lt;&lt; solve() &lt;&lt; '\\n'; return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://sea96.github.io/tags/数学/"}]},{"title":"Kattis Boxes","slug":"Kattis-Boxes","date":"2017-03-02T03:02:25.000Z","updated":"2017-05-13T01:10:59.860Z","comments":true,"path":"2017/03/02/Kattis-Boxes/","link":"","permalink":"https://sea96.github.io/2017/03/02/Kattis-Boxes/","excerpt":"题意给出$n$$(n\\leq 2\\times 10^5)$个盒子，其中一些盒子可能会被放进另一些盒子里，$q$$(q \\leq 10^5)$次询问，每次询问给出$m$$(m\\leq 20)$个盒子序号，求这$m$个盒子包含的盒子总数。","text":"题意给出$n$$(n\\leq 2\\times 10^5)$个盒子，其中一些盒子可能会被放进另一些盒子里，$q$$(q \\leq 10^5)$次询问，每次询问给出$m$$(m\\leq 20)$个盒子序号，求这$m$个盒子包含的盒子总数。 题解盒子显然有树的结构（注意：可能不止一棵树），有两种做法： 求森林的DFS序，根据DFS序将子树映射到区间，那么问题就变成了区间染色点记数问题，用线段树（区间更新，lazy标记）解决。 另外一种比较zuo的做法是LCA搞。首先求出所有的树上节点对应的子树的大小sz，节点深度 dep，以及LCA的初始化fa。然后按照节点深度对 M个节点按照节点排序。然后，对于 M 个点，LCA去重，依次加上节点为根节点的子树的大小即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int N = 2e5 + 5;vector&lt;int&gt; edge[N];int L[N], R[N];bool root[N];int box[25];int n, m, q;int dfs_clock;//#define lc o &lt;&lt; 1//#define rc o &lt;&lt; 1 | 1int sum[N&lt;&lt;2], lazy[N&lt;&lt;2];void push_down(int o, int l, int r) &#123; if (lazy[o] != -1) &#123; lazy[lc] = lazy[rc] = lazy[o]; int mid = (l + r) / 2; sum[lc] = (mid-l+1) * lazy[o]; sum[rc] = (r-mid) * lazy[o]; lazy[o] = -1; &#125;&#125;void build(int o, int l, int r) &#123; lazy[o] = -1; if (l == r) return ; int mid = l + r &gt;&gt; 1; build(lc, l, mid); build(rc, mid+1, r);&#125;void modify(int o, int l, int r, int ql, int qr, int col) &#123; if (sum[o] == (r-l+1)*col) return ; if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; sum[o] = (r-l+1)*col; lazy[o] = col; return ; &#125; push_down(o, l, r); int mid = l + r &gt;&gt; 1; if (ql &lt;= mid) modify(lc, l, mid, ql, qr, col); if (qr &gt; mid) modify(rc, mid+1, r, ql, qr, col); sum[o] = sum[lc] + sum[rc];&#125;void DFS(int u, int fa) &#123; L[u] = ++dfs_clock; for (int v: edge[u]) if (v != fa) &#123; DFS(v, u); &#125; R[u] = dfs_clock;&#125;int main() &#123; scanf(\"%d\", &amp;n); memset(root, false, sizeof(root)); for (int i=1; i&lt;=n; ++i) &#123; int fa; scanf(\"%d\", &amp;fa); if (fa == 0) &#123; root[i] = true; continue; &#125; edge[fa].push_back(i); &#125; dfs_clock = 0; for (int i=1; i&lt;=n; ++i) &#123; if (root[i]) DFS(i, 0); &#125; build(1, 1, n); scanf(\"%d\", &amp;q); for (int i=1; i&lt;=q; ++i) &#123; scanf(\"%d\", &amp;m); for (int j=1; j&lt;=m; ++j) &#123; scanf(\"%d\", &amp;box[j]); modify(1, 1, n, L[box[j]], R[box[j]], 1); &#125; printf(\"%d\\n\", sum[1]); for (int j=1; j&lt;=m; ++j) &#123; modify(1, 1, n, L[box[j]], R[box[j]], 0); &#125; &#125; return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://sea96.github.io/tags/DFS/"},{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"}]},{"title":"Gym 101020K Clash Of Snakes","slug":"Gym-101020K-Clash-Of-Snakes","date":"2017-03-01T11:57:14.000Z","updated":"2017-05-13T01:12:18.937Z","comments":true,"path":"2017/03/01/Gym-101020K-Clash-Of-Snakes/","link":"","permalink":"https://sea96.github.io/2017/03/01/Gym-101020K-Clash-Of-Snakes/","excerpt":"题意有$n\\times m$$(2\\leq n,m \\leq 10^5)$的格子，有两条蛇长度分别为$k$和$s$$(2\\leq k,s \\leq min(n,m))$垂直或者水平地放置在格子里，要求两蛇不重叠，问放置的方案数（mod $10^9+7$）。","text":"题意有$n\\times m$$(2\\leq n,m \\leq 10^5)$的格子，有两条蛇长度分别为$k$和$s$$(2\\leq k,s \\leq min(n,m))$垂直或者水平地放置在格子里，要求两蛇不重叠，问放置的方案数（mod $10^9+7$）。 题解易得长度为$L$的方格放置长度为$k$的蛇的方案数为$L-k+1$。记长度$k$的蛇水平放置的方案数为$tot_k$，则$tot_k=(m-k+1)\\times n$。先考虑长度$k$的蛇水平放置在第$i$行，长度为$s$的蛇也水平放置的方案数$A$： $sum_1=tot_k\\times (n-1)\\times (m-s+1)$，长度为$s$的蛇不在第$i$行 $sum_2=(\\sum_{L=s}^{m-k}(L-s+1)+\\sum_{L=0}^{m-k-s}(m-L-k-s+1))\\times n$，长度为$s$的蛇在第$i$行 $$A=sum_1+sum_2$$ 再考虑长度$k$的蛇水平放置在$[j,j+k-1]$列，长度为$s$的蛇垂直放置的方案数$B$： $sum_3=tot_k\\times (m-k)\\times (n-s+1)$，长度为$s$的蛇不在$[j,j+k-1]$范围内 $sum_4=(\\sum_{L=s}^{n-1}(L-s+1)+\\sum_{L=0}^{n-1-s}(n-L-1-s+1))\\times k \\times (m-k+1)$，长度为$s$的蛇在$[j,j+k-1]$范围内 $$B=sum_3+sum_4$$那么要计算长度$k$的蛇垂直放置以及长度$s$的蛇两种的放置的方案数$A’$和$B’$，只要swap(n,m)后重复上面的计算即可。但是$sum_2$和$sum_4$的计算，用$O(n)$复杂度会TLE，要用求和公式来$O(1)$计算。最后头尾的组合有4种，所以最终答案：$$ans=4\\times (A+B+A’+B’)$$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 5;const ll MOD = 1000000007;int n, m, k, s;int ans;inline void add_mod(int &amp;a, int b) &#123; a += b; if (a &gt;= MOD) a -= MOD;&#125;int sum(int l, int r) &#123; int x = l + r, y = r - l + 1; if (x % 2 == 0) x &gt;&gt;= 1; else y &gt;&gt;= 1; return (ll)x * y % MOD;&#125;int solve() &#123; if (m &lt; k) return 0; int tot_k = (ll)n*(m-k+1)%MOD; int ret = 0; if (s &lt;= m) add_mod(ret, (ll)tot_k*(n-1)%MOD*(m-s+1)%MOD); if (s &lt;= n) add_mod(ret, (ll)tot_k*(m-k)%MOD*(n-s+1)%MOD); int res = 0; if (s &lt;= m-k) &#123; add_mod(res, sum(s, m-k)); ll sub = (ll)(s-1)*(m-k-s+1) % MOD; res = (res-sub+MOD)%MOD; add_mod(ret, (ll)res*n%MOD); &#125; res = 0; if (m-k-s &gt;= 0) &#123; add_mod(res, (ll)(m-k-s+1)*(m-k-s+1)%MOD); ll sub = sum(0, m-k-s); res = (res-sub+MOD)%MOD; add_mod(ret, (ll)res*n%MOD); &#125; res = 0; if (s &lt;= n-1) &#123; add_mod(res, sum(s, n-1)); ll sub = (ll)(s-1)*(n-1-s+1)%MOD; res = (res-sub+MOD)%MOD; add_mod(ret, (ll)res*k*(m-k+1)%MOD); &#125; res = 0; if (n-1-s &gt;= 0) &#123; add_mod(res, (ll)(n-s)*(n-s)%MOD); ll sub = sum(0, n-1-s); res = (res-sub+MOD)%MOD; add_mod(ret, (ll)res*k*(m-k+1)%MOD); &#125; return ret;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); for (int cas=1; cas&lt;=T; ++cas) &#123; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;s); ans = solve(); swap(n, m); add_mod(ans, solve()); ans = (ll)ans * 4 % MOD; printf(\"Case %d: %d\\n\", cas, ans); &#125; return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://sea96.github.io/tags/组合数学/"}]},{"title":"ZOJ 3328 Wu Xing","slug":"ZOJ-3328-Wu-Xing","date":"2017-02-28T10:03:54.000Z","updated":"2017-05-13T01:06:38.860Z","comments":true,"path":"2017/02/28/ZOJ-3328-Wu-Xing/","link":"","permalink":"https://sea96.github.io/2017/02/28/ZOJ-3328-Wu-Xing/","excerpt":"题意给一张完全图，用$k$个$n(\\leq 10^6)$元简单环去覆盖所有边，问$k$的最小值。","text":"题意给一张完全图，用$k$个$n(\\leq 10^6)$元简单环去覆盖所有边，问$k$的最小值。 题解 我们可以看到，他说要是任意两个点都有联系，看到这里，马上可以想到，要满足这个条件， 必须需要$\\frac {n(n-1)}{2}$条边，于是，换一种思考，该题目就可以理解为，在$\\frac {n(n-1)}{2}$条边中可以构成几个环。如果想到这里，你又开始去画点画边，那估计最后结果还是要悲剧。至少我是画不出，就算画出了也不知道到底是否是最小个数的环。 所以我们接着继续分析。。。抛开怎么连线不管， 往整体方向想，要构成一个环， $n$个点必须要$n$条边，可以理解，最终所有环所构成的边，都不会超过$\\frac {n(n-1)}{2}$条边。 所以每条边都在一个或几个环内，（其中不同的环可以共用一条边）。 所以至少有$\\frac {(n-1)}{2}$个环， 如果可以整除，那么商就是答案。如果不能整除呢？ 那么余下的边必定可以再组成一个环（必定的嘛）。所以如果$(n-1)%2 != 0$，那么答案就等于$\\frac {(n-1)}{2}+1$;结果就是和$\\frac {n}{2}$的结果一样，如果有些同学，开玩笑地试了这个公式，恭喜你，你ac了。（踩到狗屎了，呵呵！） 由$kn\\geq \\frac {n(n-1)}{2}$，可以求出 k 的下界，同时可以构造出取得下界的方案 代码略","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"}]},{"title":"Kattis Curious Cupid","slug":"Kattis-Curious-Cupid","date":"2017-02-28T09:48:52.000Z","updated":"2017-05-13T01:10:41.987Z","comments":true,"path":"2017/02/28/Kattis-Curious-Cupid/","link":"","permalink":"https://sea96.github.io/2017/02/28/Kattis-Curious-Cupid/","excerpt":"题意有$k(\\leq 10^6)$种不同的语言，每个人只说一种语言。现在有$n$$(\\leq 5\\times 10^4)$个男性和$n$个女性，每个人都想找一个和自己用同一种语言的异性，第$i$个男性的语言是$a_i$,，第$i$个女性的语言是$b_i$。现在给出$m$$(\\leq 5\\times 10^4)$个区间作为询问，每次需要回答在$[L, R]$区间的男女最多能够配对成多少对情侣。","text":"题意有$k(\\leq 10^6)$种不同的语言，每个人只说一种语言。现在有$n$$(\\leq 5\\times 10^4)$个男性和$n$个女性，每个人都想找一个和自己用同一种语言的异性，第$i$个男性的语言是$a_i$,，第$i$个女性的语言是$b_i$。现在给出$m$$(\\leq 5\\times 10^4)$个区间作为询问，每次需要回答在$[L, R]$区间的男女最多能够配对成多少对情侣。 题解离线处理，使用莫队算法解决，$O(1)$维护相同语言的情侣对数。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e4 + 5;const int M = N;const int K = 1e6 + 5;struct Query &#123; int l, r, b, id; bool operator &lt; (const Query &amp;rhs) const &#123; return b &lt; rhs.b || (b == rhs.b &amp;&amp; r &lt; rhs.r); &#125;&#125;q[M];int a[N], b[N];int ans[M];int cnt[K][2];int n, m, k;int tot;void add(int i) &#123; if (a[i] == b[i]) &#123; cnt[a[i]][0]++; cnt[b[i]][1]++; tot++; return ; &#125; if (cnt[a[i]][0] &lt; cnt[a[i]][1]) tot++; if (cnt[b[i]][0] &gt; cnt[b[i]][1]) tot++; cnt[a[i]][0]++; cnt[b[i]][1]++;&#125;void sub(int i) &#123; if (a[i] == b[i]) &#123; cnt[a[i]][0]--; cnt[b[i]][1]--; tot--; return ; &#125; if (cnt[a[i]][0] &lt;= cnt[a[i]][1]) tot--; if (cnt[b[i]][0] &gt;= cnt[b[i]][1]) tot--; cnt[a[i]][0]--; cnt[b[i]][1]--;&#125;int main() &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i=1; i&lt;=n; ++i) &#123; scanf(\"%d\", &amp;a[i]); &#125; for (int i=1; i&lt;=n; ++i) &#123; scanf(\"%d\", &amp;b[i]); &#125; int block = (int)sqrt(n); for (int i=1; i&lt;=m; ++i) &#123; scanf(\"%d%d\", &amp;q[i].l, &amp;q[i].r); q[i].l++; q[i].r++; q[i].b = q[i].l / block; q[i].id = i; &#125; sort(q+1, q+m+1); int L = 1, R = 1; tot = 0; cnt[a[1]][0]++; cnt[b[1]][1]++; if (a[1] == b[1]) tot++; for (int i=1; i&lt;=m; ++i) &#123; while (L &lt; q[i].l) sub(L++); while (L &gt; q[i].l) add(--L); while (R &lt; q[i].r) add(++R); while (R &gt; q[i].r) sub(R--); ans[q[i].id] = tot; &#125; for (int i=1; i&lt;=m; ++i) printf(\"%d\\n\", ans[i]); return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"},{"name":"莫队算法","slug":"莫队算法","permalink":"https://sea96.github.io/tags/莫队算法/"}]},{"title":"最长公共子序列","slug":"最长公共子序列","date":"2017-02-27T06:38:08.000Z","updated":"2017-06-14T03:38:37.359Z","comments":true,"path":"2017/02/27/最长公共子序列/","link":"","permalink":"https://sea96.github.io/2017/02/27/最长公共子序列/","excerpt":"","text":"问题描述求两个字符串的最长公共子序列（Longest Common Subsequence ( LCS )）。 算法分别记两个字符串为$S_1$和$S_2$，它们的最长公共子序列为$LCS(S_1,S_2)$。 朴素的做法枚举出$S_1$所有的子序列和$S_2$比较，时间复杂度：$O(2^{|S_1|}|S_2|)$。 动态规划的做法记$S_1$和$S_2$最后的字符分别是$S_1$和$S_2$，即：$$S_1=S_1’+e_1$$ $$S_2=S_2’+e_2$$有四种情况： $LCS$包含$e_1$ 不含$e_2$ $LCS$包含$e_2$ 不含$e_1$ $LCS$不含$e_1$，$e_2$ $LCS$包含$e_1$，$e_2$ 对于第一种情况，$e_2$没有用处，$LCS(S_1,S_2)=LCS(S_1,S_2’)$。对于第二种同理，$LCS(S_1,S_2)=LCS(S_1’,S_2)$对于第三种同理，$LCS(S_1,S_2)=LCS(S_1’,S_2’)$对于第四种同理，$LCS(S_1,S_2)=LCS(S_1’,S_2’)+e_1$如果使用非递归的做法，要保存前缀串的$LCS$，可以用动态规划实现。定义$dp[i][j]$表示$S_1$的前$i$个字符和$S_2$的前$j$个字符的$LCS$的长度，状态转移方程：$$dp[i][j]=max \\left \\{ dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1 (S_{1_{i}}=S_{2_{j}}) \\right \\}$$如果要求得到一个最长公共子序列，用一个二维数组记录状态是从哪一个转移来的即可，递归打印。时间复杂度：$O(|S_1||S_2|)$ 优化如果用滚动数组优化，空间复杂度降至：$O(2|S|)$ 基于位运算的算法压位最长公共子序列（论文，代码） Hunt-Szymanski Algorithm转换为二维LIS问题 从两序列中找出对应的相同元素，以位置数对表示。这些位置数对可以排出的最长严格递增序列，即是两序列的$LCS $。首先將所有数对排序，规则是第一个维度由小到大排序，当第一个维度相等时，第二个維度由大到小排序。排序之后，第二个维度的$1D$ $LIS$，就对应到原数对们的$2D$ $LIS$。 记数对的总数目为$K$，时间复杂度：$O(Klog |S|)$如果出现类似于：$S_1=aaaa$，$S_2=aaaaaa$，时间复杂度退化成：$O(|S|^2log |S|)$ 代码12345678//DPfor (int i=1; i&lt;=n; ++i) &#123; now ^= 1; for (int j=1; j&lt;=m; ++j) &#123; dp[now][j] = max(dp[now^1][j], dp[now][j-1]); if (s[i] == t[j]) dp[now][j] = max(dp[now][j], dp[now^1][j-1]+1); &#125;&#125; //lcs = dp[now][m]; 123456789101112131415161718//2D LISint LCS(char *s, char &amp;t) &#123; int n = strlen(s+1), m = strlen(t+1); vector&lt;int&gt; pos[128]; for (int i=1; i&lt;=m; ++i) &#123; pos[t[i]].push_back(i); &#125; vector&lt;int&gt; lcs; for (int i=1; i&lt;=n; ++i) &#123; for (int j=(int)pos[s[i]].size()-1; j&gt;=0; --j) &#123; int p = pos[s[i]][j]; if (lcs.empty()) lcs.push_back(p); else if (p &gt; lcs.back()) lcs.push_back(p); else *lower_bound(lcs.begin(), lcs.end(), p) = p; &#125; &#125; return lcs.size();&#125; 习题UVA 111（简单题）POJ 2250（打印LCS）POJ 1159（滚动数组优化）UVA 10635 UVA 10949（2D LIS）玲珑学院OJ 1097 （2D LIS） 拓展最长公共上升子序列最长回文子序列最长公共子串 参考资料演算法笔记 - Longest Common Subsequence","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"LCS","slug":"LCS","permalink":"https://sea96.github.io/tags/LCS/"}]},{"title":"动态规划的各种类型","slug":"动态规划的各种类型","date":"2017-02-27T06:22:00.000Z","updated":"2017-06-15T13:57:39.107Z","comments":true,"path":"2017/02/27/动态规划的各种类型/","link":"","permalink":"https://sea96.github.io/2017/02/27/动态规划的各种类型/","excerpt":"","text":"子序列DP最长公共子序列http://m.blog.csdn.net/article/details?id=6918848 树形DP区间DP状压DP概率DP数位DP 在信息学竞赛中，有一类与数位有关的区间统计问题。这类问题往往具有比较浓厚的数学味道，无法暴力求解，需要在数位上进行递推等操作。在信息学竞赛中，有这样一类问题：求给定区间中，满足给定条件的某个 $D$ 进制数或此类数的数量。所求的限定条件往往与数位有关，例如数位之和、指定数码个数、数的大小顺序分组等等。题目给定的区间往往很大，无法采用朴素的方法求解。此时，我们就需要利用数位的性质，设计 $log(n)$ 级别复杂度的算法。解决这类问题最基本的思想就是逐位确定的方法。 HDOJ 4722 Good Numbers题意如果一个数字的每个数位和能被10整除，那么它是good number，问 $[A,B]$ 区间里good number的数量。数据$0 \\leq A,B \\leq 10^{18}$题解$dp[pos][mod]$表示前 $pos$ 位，数位和取模10为 $mod$ ，后面数字任意且满足总数位和取模10为0的数量。记忆化深搜，基础入门题。code HDOJ 5642 King’s Order题意问长度为 $n$ 的字符串，由26个小写字母组成，满足相同的字母相邻出现不超过3个，问满足条件的方案数（mod 1000000007）。数据$0 \\leq n \\leq 2×10^{3}$题解$dp[pos][pre][mod]$表示前 $pos$ 位，当前位的字母是 $pre$，相同出现的个数为 $cnt$ 的方案数。code URAL 1057 Amount of Degrees题意求给定区间 $[X,Y]$ 中满足下列条件的整数个数：这个数恰好等于 $K$ 个互不相等的 $B$ 的整数次幂之和。数据$1 ≤ X ≤ Y ≤ 2^{31}−1$，$1 ≤ K ≤ 20$， $2 ≤ B ≤ 10$题解所求的数为互不相等的幂之和，亦即其 $B$ 进制表示的各位数字都只能是 $0$ 和 $1$。因此，我们只需讨论二进制的情况，其他进制都可以转化为二进制求解。那么问题和上题几乎一样，$dp[pos][mod]$表示前 $pos$ 位，相同出现 $1$ 的个数为 $cnt$ 的方案数。code SPOJ SQRTBIT Sorted bit squence题意将区间 $[m,n]$ 内的所有整数按照其二进制表示中 $1$ 的数量从小到大排序。如果 $1$ 的数量相同，则按照数的大小排序。求这个序列中的第 $k$ 个数。数据$m × n ≥ 0$， $-2^{31} ≤ m ≤ n ≤ 2^{31}-1$，$1 ≤ k ≤ min(n − m + 1, 2147473547)$题解我们首先考虑 $m,n&gt;0$ 的情况。由于排序的第一关键字是 $1$ 的数量，第二关键字是数的大小，因此我们很容易确定答案中 $1$ 的个数：依次统计区间 $[m,n]$ 内二进制表示中含 $1$ 的数量为$0,1,2,…$的数，直到累加的答案超过 $k$ ，则当前值就是答案含 $1$ 的个数，假设是 $s$ 。利用上题的方法处理。同时，我们也求出了答案是第几个 $[m,n]$ 中含 $s$ 个 $1$ 的数。因此，只需二分答案，求出$[m,ans]$ 中含 $s$ 个 $1$ 的数的个数进行判断即可。$m&lt;0$的情况也不难处理，直接将负数视为32位无符号数（或者直接使用 long long 数据类型），采用同正数一样的处理方法（需特殊处理$n=0$ 的情况）。code SPOJ BIGSEQ Sequence题意给定所有 $K$ 位二进制数：$0,1,…,2^{K}-1$。你需要将它们分成恰好 $M$ 组，每组都是原序列中连续的一些数。设 $S_i$($1 ≤ i ≤ M$)表示第 $i$ 组中所有数的二进制表示中 $1$ 的个数，$S$ 等于所有$S_i$中的最大值。你的任务是令 $S$ 最小。数据$1 ≤ K ≤ 100$, $1 ≤ M ≤ 100$, $M ≤ 2^K$题解代码解释：$d[i]=2^i$，$f[i]$ 表示高度为i的左子树中所有数的二进制表示中 $1$ 的个数（叶子结点高度为0）。code 背包DP动态规划总结与题目分类","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"}]},{"title":"Codeforces Round #402 (Div.2)","slug":"Codeforces-Round-402-Div-2","date":"2017-02-26T11:49:06.000Z","updated":"2017-05-13T01:26:27.413Z","comments":true,"path":"2017/02/26/Codeforces-Round-402-Div-2/","link":"","permalink":"https://sea96.github.io/2017/02/26/Codeforces-Round-402-Div-2/","excerpt":"A. Pupils Redistribution题意：有2组学生，问最少交换几次学生，使得2组的各类型学生的人数相等。题解：比赛时先是看错题以为DP，然后又想法有问题调不出来，结果最后时间A掉，题倒不难。记录第一组的每类学生缺多少人以及不要多少人（其实是相等的，否则输出-1），可以在交换中得到一个人以及送出一个人。","text":"A. Pupils Redistribution题意：有2组学生，问最少交换几次学生，使得2组的各类型学生的人数相等。题解：比赛时先是看错题以为DP，然后又想法有问题调不出来，结果最后时间A掉，题倒不难。记录第一组的每类学生缺多少人以及不要多少人（其实是相等的，否则输出-1），可以在交换中得到一个人以及送出一个人。 B. Weird Rounding题意：给定一个数字$n(\\leq 2\\times 10^9)$，问最少删除多少个数位，使得剩余的能被$10^k(1\\leq k\\leq 9)$整除。题解：贪心地从后往前扫即可。如果没有符合的，还要额外考虑0。 C. Dishonest Sellers题意：有$n(\\leq 2\\times 10^5)$个商品，第$i$个商品当前价格为$a_i$，一周后的价格为$b_i$，必须至少现在买$k(\\leq n)$个商品，问最小花费。题解：按照$a_i-b_i$从小到大排序，前$k$个用$a_i$买，后面的用$min(a_i,b_i)$买即可。 D. String Game题意：有两个字符串$t$和$p$$(1 ≤ |p| &lt; |t| ≤ 2\\times 10^5)$，$t$按照一定顺序删除字符，直到和$p$相等或者子序列没有$p$，问最多能删除多少个字符。题解：二分答案$k$，check删除前$k$个指定字符后子序列还有没有$p$，二分找到最大的$k$。code E. Bitwise Formula题意：有$n(\\leq 5\\times 10^3)$个变量，每个变量用$m(\\leq 10^3)$位的二进制表示，给出$n$个变量的递推式，问’?’取何值时，所有变量的和最大以及最小？如果有多个满足题意，’?’取最小值。题解：常量不影响结果不考虑。由于相邻二进制的位运算互不影响，所以从高位到低位枚举’?’的二进制数’0’和’1’，根据所有由’?’决定的变量该位的’0’和’1’的数量和来选择答案。代码实现上处理好映射关系。code","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"},{"name":"STL","slug":"STL","permalink":"https://sea96.github.io/tags/STL/"},{"name":"排序","slug":"排序","permalink":"https://sea96.github.io/tags/排序/"}]},{"title":"Codeforces 711E ZS and The Birthday Paradox","slug":"Codeforces-711E-ZS-and-The-Birthday-Paradox","date":"2017-02-26T07:15:19.000Z","updated":"2017-05-13T01:28:53.907Z","comments":true,"path":"2017/02/26/Codeforces-711E-ZS-and-The-Birthday-Paradox/","link":"","permalink":"https://sea96.github.io/2017/02/26/Codeforces-711E-ZS-and-The-Birthday-Paradox/","excerpt":"题意$k(\\leq 10^{18})$个人的生日在$2^n(n \\leq 10^{18})$天内，问至少有两个人的生日在同一天的概率。","text":"题意$k(\\leq 10^{18})$个人的生日在$2^n(n \\leq 10^{18})$天内，问至少有两个人的生日在同一天的概率。 题解先求所有人的生日都不同的概率$p$，那么答案就是$1-p$。$$p=\\frac {A_{2^n}^{k}}{(2^n)^k}=\\frac {\\prod_{i=0}^{k-1}(2^n-i)}{2^{kn}}$$也就是说第$i$个人的生日不重复的概率为$\\frac {(2^n-i)}{2^n}$。题目要求先约分再取模，根据公式$$GCD(a,b)=GCD(b-a,b),(a&lt;b)$$只要求$GCD((k-1)!,2^{(k-1)n})$，分子分母同除掉它后就可以取模，也就是求$(k-1)!$有多少个2，根据勒让德定理（Legendre’s formula）：在正数$n!$的素因子标准分解式中，素数$p$的指数记作$L_p(n!)$，则$$L_p(n!)=\\sum_{k=1}\\lfloor \\frac {n}{p^k} \\rfloor$$根据抽屉原理，当$k-1\\geq MOD$时，$k-1$个连续整数中必有一个能被$MOD$整除，这就意味着取模之后结果为0，那$k-1$个连续整数的乘积就是0。而当$k-1&lt;MOD$时,因为$MOD$的值不大,所以我们可以暴力循环求出分子，指数很大直接快速幂显然不行，注意到$MOD$是素数，根据费马小定理$$2^{p-1}\\equiv 1(mod p)$$可以降幂后用快速幂。时间复杂度：$O(MOD+log_k+log_n)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MOD = 1e6 + 3;ll pow_mod(ll x, ll n) &#123; ll ret = 1; for (; n; n&gt;&gt;=1) &#123; if (n &amp; 1) ret = ret * x % MOD; x = x * x % MOD; &#125; return ret;&#125;ll n, k;int main() &#123; scanf(\"%I64d%I64d\", &amp;n, &amp;k); if (n&lt;63 &amp;&amp; (1LL&lt;&lt;n) &lt; k) &#123; puts(\"1 1\"); return 0; &#125; ll B = pow_mod(2LL, n%(MOD-1)*((k%(MOD-1)-1+(MOD-1))%(MOD-1))); ll cnt = 0; for (ll i=k-1; i; i&gt;&gt;=1) cnt += (i&gt;&gt;1); ll igcd = pow_mod(2LL, cnt%(MOD-1)*(MOD-2)%(MOD-1)); B = B * igcd % MOD; if (k-1 &gt;= MOD) &#123; printf(\"%I64d %I64d\\n\", B, B); return 0; &#125; ll A = 1; for (int i=1; i&lt;=k-1; ++i) &#123; A = A * ((pow_mod(2LL, n%(MOD-1))-i+MOD)%MOD) % MOD; &#125; A = A * igcd % MOD; printf(\"%I64d %I64d\\n\", (B-A+MOD)%MOD, B); return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"概率","slug":"概率","permalink":"https://sea96.github.io/tags/概率/"},{"name":"数论","slug":"数论","permalink":"https://sea96.github.io/tags/数论/"}]},{"title":"Codeforces 449C Jzzhu and Apples","slug":"Codeforces-449C-Jzzhu-and-Apples","date":"2017-02-26T06:53:58.000Z","updated":"2017-05-13T01:30:42.575Z","comments":true,"path":"2017/02/26/Codeforces-449C-Jzzhu-and-Apples/","link":"","permalink":"https://sea96.github.io/2017/02/26/Codeforces-449C-Jzzhu-and-Apples/","excerpt":"题意给定$n(\\leq 10^5)$个数字，从1到n，问最多能组成多少对不互质的数对（每个数字只用一次，且公约数大于1）。","text":"题意给定$n(\\leq 10^5)$个数字，从1到n，问最多能组成多少对不互质的数对（每个数字只用一次，且公约数大于1）。 题解大于$\\lfloor \\frac {n}{2} \\rfloor $的素数不用考虑。找出小于$\\lfloor \\frac {n}{2} \\rfloor $的所有素数，从大到小，对于每一个素数$p$找出所有没有访问过且是$p$的倍数，如果个数为偶数，两两匹配即可；否则暂时不考虑$2p$，直到$p=2$时一起考虑。不会证明为什么是最优的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;vector&lt;pair&lt;int, int&gt; &gt; ans;int n;int prime[N/4];bool is_prime[N/2];bool vis[N];void prime_table(int n) &#123; memset(is_prime, true, sizeof(is_prime)); int &amp;p = prime[0] = 0; is_prime[0] = is_prime[1] = false; for (int i=2; i&lt;=n; ++i) &#123; if (is_prime[i]) prime[++p] = i; for (int j=1; j&lt;=p &amp;&amp; i*prime[j]&lt;=n; ++j) &#123; is_prime[i*prime[j]] = false; if (i % prime[j] == 0) break; &#125; &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); prime_table(n/2); vector&lt;int&gt; last, tmp; for (int i=prime[0]; i&gt;=2; --i) &#123; tmp.clear(); for (int j=prime[i]; j&lt;=n; j+=prime[i]) if (!vis[j]) tmp.push_back(j); int k = 0; if (tmp.size() &amp; 1) &#123; ans.push_back(make_pair(tmp[0], tmp[2])); vis[tmp[0]] = vis[tmp[2]] = true; k = 3; &#125; for (; k&lt;tmp.size(); k+=2) &#123; ans.push_back(make_pair(tmp[k], tmp[k+1])); vis[tmp[k]] = vis[tmp[k+1]] = true; &#125; &#125; for (int i=2; i&lt;=n; i+=2) if (!vis[i]) last.push_back(i); for (int k=0; k&lt;(int)last.size()-1; k+=2) &#123; ans.push_back(make_pair(last[k], last[k+1])); &#125; printf(\"%d\\n\", ans.size()); for (auto p: ans) &#123; printf(\"%d %d\\n\", p.first, p.second); &#125; return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://sea96.github.io/tags/构造/"},{"name":"数论","slug":"数论","permalink":"https://sea96.github.io/tags/数论/"}]},{"title":"BestCoder 92C Girls Love 233","slug":"BestCoder-92C-Girls-Love-233","date":"2017-02-26T02:14:30.000Z","updated":"2017-05-13T05:22:31.507Z","comments":true,"path":"2017/02/26/BestCoder-92C-Girls-Love-233/","link":"","permalink":"https://sea96.github.io/2017/02/26/BestCoder-92C-Girls-Love-233/","excerpt":"题意给定一个长度为$n(\\leq 10^2)$，只包含’2’和’3’的字符串，每次操作可以交换相邻的字符，代价是智商-2。问智商为$m(\\leq 10^2)$不降为负数的情况下，最多能使字符串出现多少个字串“233”。","text":"题意给定一个长度为$n(\\leq 10^2)$，只包含’2’和’3’的字符串，每次操作可以交换相邻的字符，代价是智商-2。问智商为$m(\\leq 10^2)$不降为负数的情况下，最多能使字符串出现多少个字串“233”。 题解定义$dp[i][j][k]$表示使用了前$i$个’2’，第$i$个’2’在j位置，一共有$k$个“233”所需要的最小代价。状态转移方程：$$dp[i][j][k]=min \\left \\{ dp[i-1][j2][k],dp[i-1][j3][k-1] \\right \\} + 2|a[i]-j|$$时间复杂度：$O(n^4)$。 首先，因为字符不是’2’就是’3’，所以我们可以把字符串当做一个全部都是’3’的串，然后有若干的’2’插入到了某些位置。显然，我们交换相邻的’2’与’2’或者相邻的’3’与’3’是没有意义的，我们只会进行相邻’2’与’3’之间的交换。因此，所有’2’的相对前后关系其实是不会变化的。 利用偏移量来确定状态，优化内存时间。定义$dp[i][j][k][s]$表示考虑了i个’2’和j个’3’，花费k代价，后缀为s状态（0：前面没有’2’或者有足够多’3’；1：前一个’2’后面跟着1个’3’：2：跟着2个’3’）最多获得的”233”个数，状态转移方程：放一个’2’：$$Max(dp[i+1][j][k2][1],dp[i][j][k][s]),k2=k+|i+j+1-a[i+1]|$$放一个’3’：$$Max(dp[i][j+1][k][s2],dp[i][j][k][s]+add)$$放3时不增加代价，我的理解是移动’2’的同时相当于移动了’3’，如果原来的位置放了’2’，那么放’3’的代价会在放’2’的时候计算。 代码$O(n^4)$12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e2 + 5;const int INF = 0x3f3f3f3f;char str[N];int dp[N][N][N];int a[N], cnt;int n, m;inline void Min(int &amp;a, int b) &#123; if (a &gt; b) a = b;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); scanf(\"%s\", str+1); cnt = 0; for (int i=1; i&lt;=n; ++i) if (str[i] == '2') a[++cnt] = i; for (int i=0; i&lt;=cnt; ++i) for (int j=1; j&lt;=n; ++j) for (int k=0; k&lt;=cnt; ++k) dp[i][j][k] = INF; for (int j=1; j&lt;=n; ++j) &#123; dp[1][j][0] = 2*abs(a[1]-j); &#125; for (int i=2; i&lt;=cnt; ++i) &#123; for (int j=i; j&lt;=n; ++j) &#123; for (int k=0; k&lt;=i; ++k) &#123; for (int j2=max(i-1,j-2); j2&lt;=j-1; ++j2) Min(dp[i][j][k], dp[i-1][j2][k]); if (k) for (int j2=i-1; j2&lt;=j-3; ++j2) Min(dp[i][j][k], dp[i-1][j2][k-1]); dp[i][j][k] += 2*abs(a[i]-j); &#125; &#125; &#125; int ans = 0; for (int j=1; j&lt;=n; ++j) for (int k=0; k&lt;=cnt; ++k) if (dp[cnt][j][k] &lt;= m) &#123; ans = max(ans, k+(j&lt;=n-2)); &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125; $O(n^3)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e2 + 5;const int INF = 0x3f3f3f3f;char str[N];int dp[N][N][N&gt;&gt;1][3];int a[N];int c2, c3;int n, m;inline void Max(int &amp;a, int b) &#123; if (a &lt; b) a = b;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); scanf(\"%s\", str+1); m /= 2; c2 = 0; for (int i=1; i&lt;=n; ++i) if (str[i] == '2') a[++c2] = i; c3 = n - c2; for (int i=0; i&lt;=c2; ++i) for (int j=0; j&lt;=c3; ++j) for (int k=0; k&lt;=m; ++k) for (int s=0; s&lt;3; ++s) dp[i][j][k][s] = -1; dp[0][0][0][0] = 0; for (int i=0; i&lt;=c2; ++i) &#123; for (int j=0; j&lt;=c3; ++j) &#123; for (int k=0; k&lt;=m; ++k) &#123; for (int s=0; s&lt;3; ++s) if (~dp[i][j][k][s]) &#123; if (i &lt; c2) &#123; int k2 = k + abs(i+j+1-a[i+1]); if (k2 &lt;= m) Max(dp[i+1][j][k2][1], dp[i][j][k][s]); &#125; if (j &lt; c3) &#123; int s2 = s, add = 0; if (s) &#123; if (s == 1) s2++; else s2 = 0, add++; &#125; Max(dp[i][j+1][k][s2], dp[i][j][k][s]+add); &#125; &#125; &#125; &#125; &#125; int ans = 0; for (int k=0; k&lt;=m; ++k) for (int s=0; s&lt;3; ++s) &#123; Max(ans, dp[c2][c3][k][s]); &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"}]},{"title":"动态规划的各种优化","slug":"动态规划的各种优化","date":"2017-02-25T07:03:05.000Z","updated":"2017-06-14T03:39:07.520Z","comments":true,"path":"2017/02/25/动态规划的各种优化/","link":"","permalink":"https://sea96.github.io/2017/02/25/动态规划的各种优化/","excerpt":"","text":"用单调性优化动态规划 单调性优化Vijos 1243 生产产品题意：产品的生产需要$m(\\leq 10^5)$个步骤，每个步骤可以在$n(\\leq 5)$个机器中任何一台完成，机器$i$完成第$j$个步骤的时间为$a_{i,j}$。把半成品从一台机器上搬到另一台机器上也需要一定的时间$k$，每台机器最多只能连续完成产品的$l(\\leq 5*10^4)$个步骤，问最短需要多长时间。 题解：朴素的动态规划的算法：定义$dp[i][j]$表示前i个步骤，最后一段步骤用第$j$个机器完成，$sum[i][j]$表示前$i$个步骤用第$j$个机器完成的时间。状态转移方程：$$dp[i][j]=min\\left \\{ dp[t][p]+(sum[i][j]-sum[t][j])+k \\right \\},(j\\neq p,i-t\\leq l)$$时间复杂度：$O(n^2ml)$。把方程式变形得：$$dp[i][j]=min\\left \\{ dp[t][p]-sum[t][j] \\right \\}+sum[i][j]+k,(j\\neq p,i-t\\leq l)$$发现括号内的式子是根据$t$决定的（枚举$p$和$j$），所以可以用单调队列维护一个单调递增的序列进行优化，时间复杂度：$O(n^2m)$。code POJ 3017 Cut the Sequence题意：给定一个有$n$个非负整数的数列$a(a_i\\leq 10^5)$，要求将其划分为若干个部分，使得每部分的和不超过给定的常数$m$，并且所有部分的最大值的和最小。 题解：朴素的动态规划的算法：定义$dp[i]$表示前$i$个数字划分后所有部分最大值的和，$m(l,r)$表示区间$[l,r]$的最大值，$sum(l,r)$表示区间$[l,r]$的和，状态转移方程：$$dp[i]=min\\left \\{ dp[t]+m(t+1,i) \\right \\},sum(t+1,i)\\leq m$$因为是非负整数，dp的值显然是递增的，但是并没有可维护单调的序列，决策点也没有单调性，需要挖掘出单调性，引用kuangbin的做法： 首先假如不考虑m的限制，那么最优决策的$j$点，一定满足$a[j] &gt; max(a[j+1~i])$就是$j$点的值要大于$j+1$到$j$点的值。很明显的结论，因为假如不成立，那么可以把$j$点也划分到后面去，得到更优的所以用单调队列维护一个递减数列，这样的话最优决策点只能出现在这些点中。现在加了$m$的限制，假如上面那个递减数列只有后面一部分是满足$m$限制的。那么决策点就是上面这些点再加上满足$m$条件的那个边界，所以可以用平衡二叉树维护二叉树里面的值只要随着队列进行维护就好了，可以用multiset实现。 code 斜率优化BZOJ 1010 玩具装箱toy题意：$n$个玩具装到若干个容器内，问制作容器费用的最小值。题解：一份写的不错的题解 这里面详细的证明了决策点的单调性，在这前提下利用斜率的单调性，维护单调队列，侧重于“数”。 POJ 1180 Batch Scheduling（批量任务）题意：有$n(n\\leq 10^4)$个任务，要求依次执行，从时刻$0$开始，任务被分批加工。在每批任务开始前，机器需要启动时间$s$。每个任务有相应的执行时间T和影响因素F。一批任务完成时间就是各个任务的完成时间总和，每个任务完成的费用是任务完成时刻*该任务费用系数。确定一个方案使得总费用最小。 题解：这题要倒推，只有后面任务的分配确定后才有意义。$f(i)$表示完成$i$~$n$任务的最小费用，$T[i,j]$，$F[i,j]$分别表示完成任务$i$~任务$j$所需要的时间和费用。假设新增批次任务$i$~任务$j-1$，那么在$f(j)$的基础上，新增加的完成$i$~$j-1$任务的费用：$(s+T[i,j-1])F[i,j-1]$，延时造成的费用：$(s+T[i,j-1])F[i,j-1]$。所以$f(i)=min(f(j)+(s+T[i,j-1])*F[i,n])$，时间复杂度$O(n^2)$。 利用最优决策点的凸性优化（侧重“形”）：记$x(i)=T[i,n]，y(i)=f(i)，a[i]=s+T[i,n]，b[i]=F[i,n]$。上面的状态转移方程式等价于：$f(i)=min(y(j)+(a[i]-x[j])b[i])$，即$minp=f(i)=-b[i]x(j)+y(j)+a[i]b[i]$，即$y(j)=b[i]x(j)+(p-a[i]*b[i])$。随着$i$递减，$x(i)$递增，斜率$b[i]$递增，所以用单调队列维护一个下凸壳，时间复杂度降为$O(n)$。code HDOJ 5956 The Elder（长者的王国）题意：给出一个n个点的有根树，每条边上有权值，两个点的距离定义为路上边权和，给出另一个参数p。令$f_i=max(f_j+dis(i,j)^2+p)$，求f_i的最大值。 题解：树上的斜率优化DP，DFS遍历时，记录下当前单调队列的两个指针，以及队尾哪些被pop掉，递归结束后恢复即可。code 斜率单调暴力移指针斜率不单调二分找答案x坐标单调开单调队列x坐标不单调开平衡树|cdq分治 四边形不等式优化百度文库CSDNchino瀚清Aireen Ye 滚动数组优化（空间）二进制优化（时间）矩阵优化（时间）数据结构优化（时间）斜率优化四边形优化[dp优化]个人对dp优化的理解 夜深人静写算法（二） - 动态规划","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"}]},{"title":"Codeforces 396B On Sum of Fractions","slug":"Codeforces-396B-On-Sum-of-Fractions","date":"2017-02-24T02:33:59.000Z","updated":"2017-05-13T01:31:04.066Z","comments":true,"path":"2017/02/24/Codeforces-396B-On-Sum-of-Fractions/","link":"","permalink":"https://sea96.github.io/2017/02/24/Codeforces-396B-On-Sum-of-Fractions/","excerpt":"题意定义$v(n)$是不大于$n$的最大素数，$u(n)$是大于$n$的最小素数，求$\\sum_{i=2}^{n}\\frac {1}{v(i)u(i)}$。","text":"题意定义$v(n)$是不大于$n$的最大素数，$u(n)$是大于$n$的最小素数，求$\\sum_{i=2}^{n}\\frac {1}{v(i)u(i)}$。 题解$$ans=\\sum_{k=2}^{p_{k}\\leq n}(\\frac {p_k-p_{k-1}}{p_k p_{k-1}})+\\frac {n-p_k+1}{p_{k+1}p_k}=\\frac {1}{p_1}-\\frac {1}{p_{k}}+\\frac {n-p_k+1}{p_{k+1}p_{k}}=\\frac {p_{k+1}(p_{k}-2)+2(n-p_{k}+1)}{2p_{k}p_{k+1}}$$再用GCD约分即可。 代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll GCD(ll a, ll b) &#123; return b ? GCD(b, a%b) : a;&#125;bool is_prime(int n) &#123; for (int i=2; i*i&lt;=n; ++i) &#123; if (n % i == 0) return false; &#125; return true;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; int n; scanf(\"%d\", &amp;n); int p1 = n, p2 = n+1; while (!is_prime(p1)) p1--; while (!is_prime(p2)) p2++; ll a = (ll)p2*(p1-2) + 2LL*(n-p1+1); ll b = 2LL * p1 * p2; ll c = GCD(a, b); printf(\"%I64d/%I64d\\n\", a/c, b/c); &#125; return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://sea96.github.io/tags/数论/"}]},{"title":"Codeforces 287D Shifting","slug":"Codeforces-287D-Shifting","date":"2017-02-24T00:59:06.000Z","updated":"2017-05-13T01:31:20.094Z","comments":true,"path":"2017/02/24/Codeforces-287D-Shifting/","link":"","permalink":"https://sea96.github.io/2017/02/24/Codeforces-287D-Shifting/","excerpt":"题意定义排列$p=p_1,p_2,…,p_n$。定义函数$f(p, k)$用来转换$p$排列，$k$是转换参数。假设排列$p$的长度为$n(\\leq 10^6)$，首先把$p$按长度$k(&gt;1)$进行分块，若最后一块长度不足$k$，则其长度为$n%k$，然后分别对每一块循环左移一位，得到一个新的排列。","text":"题意定义排列$p=p_1,p_2,…,p_n$。定义函数$f(p, k)$用来转换$p$排列，$k$是转换参数。假设排列$p$的长度为$n(\\leq 10^6)$，首先把$p$按长度$k(&gt;1)$进行分块，若最后一块长度不足$k$，则其长度为$n%k$，然后分别对每一块循环左移一位，得到一个新的排列。 给定$n$，请输出$f(f(…f(p = [1,2,…,n],2)…,n-1,),n)$的结果。例如$n=5$的变化过程如下：$1,2,3,4,5 \\rightarrow 2,1,4,3,5 \\rightarrow 1,4,2,5,3 \\rightarrow 4,2,5,1,3 \\rightarrow 2,5,1,3,4$ 题解$f(9,3)$变化如下：$1,2,3,4,5,6,7,8,9 \\rightarrow 2,3,1,5,6,4,8,9,7$把左移过程看成往右jump的过程：$a,2,3,b,5,6,c,8,9 \\rightarrow 2,3,a,5,6,b,8,9,c$可以用一个双端队列维护，第$k$次操作需要操作$\\frac {n}{k}$个元素，总时间复杂度：$O(nlogn)$。 代码1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 5;deque&lt;int&gt; dque;int n;int main() &#123; scanf(\"%d\", &amp;n); for (int i=1; i&lt;=n; ++i) dque.push_back(i); for (int k=2; k&lt;=n; ++k) &#123; int p = (n-1)/k*k; dque.push_back(dque[p]); for (; p-k&gt;=0; p-=k) &#123; dque[p] = dque[p-k]; &#125; dque.pop_front(); &#125; for (int i=0; i&lt;dque.size(); ++i) &#123; printf(\"%d \", dque[i]); &#125; return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://sea96.github.io/tags/构造/"}]},{"title":"Codeforces 21D Traveling Graph","slug":"Codeforces-21D-Traveling-Graph","date":"2017-02-24T00:31:41.000Z","updated":"2017-05-13T01:31:42.578Z","comments":true,"path":"2017/02/24/Codeforces-21D-Traveling-Graph/","link":"","permalink":"https://sea96.github.io/2017/02/24/Codeforces-21D-Traveling-Graph/","excerpt":"题意给出一个$n(1\\leq n \\leq5)$个点，$m(0\\leq m \\leq2000)$条边的无向带权图，问从$1$号点出发，通过所有的边至少一次，再回到$1$号点，需要花费的最少代价是多少。存在自环和重边。如果无法满足上述要求，那么输出$-1$。","text":"题意给出一个$n(1\\leq n \\leq5)$个点，$m(0\\leq m \\leq2000)$条边的无向带权图，问从$1$号点出发，通过所有的边至少一次，再回到$1$号点，需要花费的最少代价是多少。存在自环和重边。如果无法满足上述要求，那么输出$-1$。 题解用Floyd求出全源最短路，如果1号点到某个点的最短路不存在，并且该点有边相连，则直接输出$-1$。如果所有点的度数为偶数，则存在一条欧拉回路，$ans=\\sum w_i$。否则有偶数个点的度数是奇数，尝试用一些路径连接这些点。问题其实转变为：加上若干条边构造出一条欧拉回路，求花费的最小代价。可以发现度数已经是偶数的点作为某条路径的端点是不优的（因为会产生新的奇数度数的点），于是考虑对度数是奇数的点进行状态压缩，$dp[S]$表示已经相连的点集为$S$时的最小代价。转移枚举选出两个集合内的点，用一条路连起来，这两个点的度数都会变成偶数，时间复杂度：$O(n^22^n)$。一个trick是由于最后所有点度数都要是偶数，也就是每个度数是奇数的点都要作为某条路径的端点，那么每次考虑选出集合内标号最小的点，枚举这个点和另一个点用一条路径连起来，时间复杂度：$O(n2^n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 15;const int S = 1&lt;&lt;N;const int INF = 0x3f3f3f3f;int d[N][N], deg[N];int a[N];int dp[S];int n, m;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(d, INF, sizeof(d)); for (int i=0; i&lt;n; ++i) d[i][i] = 0; int sum = 0; for (int i=0; i&lt;m; ++i) &#123; int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); sum += w; deg[--u]++; deg[--v]++; d[u][v] = min(d[u][v], w); d[v][u] = min(d[v][u], w); &#125; for (int k=0; k&lt;n; ++k) for (int i=0; i&lt;n; ++i) for (int j=0; j&lt;n; ++j) d[i][j] = min(d[i][j], d[i][k]+d[k][j]); for (int i=0; i&lt;n; ++i) &#123; if (deg[i] &gt; 0 &amp;&amp; d[0][i] == INF) &#123; puts(\"-1\"); return 0; &#125; &#125; memset(dp, INF, sizeof(dp)); int c = 0; for (int i=0; i&lt;n; ++i) &#123; if (deg[i] &amp; 1) a[c++] = i; &#125; dp[0] = 0; for (int mask=0; mask&lt;(1&lt;&lt;c); ++mask) &#123; for (int i=0; i&lt;c; ++i) if (!(mask &amp; (1&lt;&lt;i))) &#123; for (int j=i+1; j&lt;c; ++j) if (!(mask &amp; (1&lt;&lt;j))) &#123; dp[mask|(1&lt;&lt;i)|(1&lt;&lt;j)] = min(dp[mask|(1&lt;&lt;i)|(1&lt;&lt;j)], dp[mask]+d[a[i]][a[j]]); &#125; break; &#125; &#125; printf(\"%d\\n\", sum+dp[(1&lt;&lt;c)-1]); return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"},{"name":"位运算","slug":"位运算","permalink":"https://sea96.github.io/tags/位运算/"}]},{"title":"Codeforces 732D Exams","slug":"Codeforces-732D-Exams","date":"2017-02-24T00:22:31.000Z","updated":"2017-05-13T01:27:43.750Z","comments":true,"path":"2017/02/24/Codeforces-732D-Exams/","link":"","permalink":"https://sea96.github.io/2017/02/24/Codeforces-732D-Exams/","excerpt":"题意你需要在$n$天内通过$m$门课程(n,m \\leq 10^5)，每天可以考完一科科目，或者准备一门科目，或者休息。第$i$天可以考的科目为$d_i$，$d_i=0$表示这天不能考试，复习第$i$门课需要花费的时间为$a_i$。问复习完所有课程需要花费的最小天数是多少天，如果复习不完，输出$-1$。","text":"题意你需要在$n$天内通过$m$门课程(n,m \\leq 10^5)，每天可以考完一科科目，或者准备一门科目，或者休息。第$i$天可以考的科目为$d_i$，$d_i=0$表示这天不能考试，复习第$i$门课需要花费的时间为$a_i$。问复习完所有课程需要花费的最小天数是多少天，如果复习不完，输出$-1$。 题解二分枚举出可行的天数，贪心地将每门课程复习时间放在考试的前几天，check下是否能复习完。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 5;int d[N], a[N];bool vis[N];int n, m;bool check(int x) &#123; memset(vis, false, sizeof(vis)); int need = 0, cnt = 0; for (int i=x; i&gt;=1; --i) &#123; if (d[i] &amp;&amp; !vis[d[i]]) &#123; need += a[d[i]]; vis[d[i]] = true; cnt++; &#125; else if (need &gt; 0) need--; &#125; if (need || cnt &lt; m) return false; else return true;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i=1; i&lt;=n; ++i) &#123; scanf(\"%d\", &amp;d[i]); &#125; for (int i=1; i&lt;=m; ++i) &#123; scanf(\"%d\", &amp;a[i]); &#125; int low = 1, high = n, ans = -1; while (low &lt; high) &#123; int mid = low + high &gt;&gt; 1; if (check(mid)) &#123; ans = high = mid; &#125; else low = mid + 1; &#125; if (check(high)) ans = high; printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"}]},{"title":"Codeforces 3D Least Cost Bracket Sequence","slug":"Codeforces-3D-Least-Cost-Bracket-Sequence","date":"2017-02-21T14:00:32.000Z","updated":"2017-05-13T01:31:57.930Z","comments":true,"path":"2017/02/21/Codeforces-3D-Least-Cost-Bracket-Sequence/","link":"","permalink":"https://sea96.github.io/2017/02/21/Codeforces-3D-Least-Cost-Bracket-Sequence/","excerpt":"题意给出一个字符串$(|S|\\leq 5*10^4)$，包含’(‘, ‘)’, ‘?’三种字符，将一个’?’变为左括号的代价为$a_i$，变为右括号的代价为$b_i$$(1≤a_i,b_i≤10^6)$。问将字符串变为合法括号序列的最小代价和此时的合法序列，无解输出$-1$。","text":"题意给出一个字符串$(|S|\\leq 5*10^4)$，包含’(‘, ‘)’, ‘?’三种字符，将一个’?’变为左括号的代价为$a_i$，变为右括号的代价为$b_i$$(1≤a_i,b_i≤10^6)$。问将字符串变为合法括号序列的最小代价和此时的合法序列，无解输出$-1$。 题解先尝试将所有’?’变成’)’，从左到右看，如果某个时刻’)’比’(‘多，那么从前面选取一个转变代价（$a_i$-&gt;$b_i$）最小的。选取位置任意，所以用set维护即可，时间复杂度$O(nlogn)$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 5e4 + 5;char str[N];set&lt;pii&gt; st;int main() &#123; scanf(\"%s\", str); int a, b; int x = 0; long long ans = 0; for (int i=0; str[i]; ++i) &#123; if (str[i] == '(') x--; else if (str[i] == ')') x++; else &#123; scanf(\"%d%d\", &amp;a, &amp;b); str[i] = ')'; x++; ans += b; st.insert(pii(a-b, i)); &#125; while (x &gt; 0) &#123; if (st.empty()) &#123; puts(\"-1\"); return 0; &#125; pii p = *st.begin(); ans += p.first; str[p.second] = '('; st.erase(p); x -= 2; &#125; &#125; if (x != 0) &#123; puts(\"-1\"); return 0; &#125; printf(\"%I64d\\n\", ans); puts(str); return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"}]},{"title":"SPOJ ODDDIV Odd Numbers of Divisors","slug":"SPOJ-ODDDIV-Odd-Numbers-of-Divisors","date":"2017-02-21T13:54:00.000Z","updated":"2017-05-13T01:10:18.907Z","comments":true,"path":"2017/02/21/SPOJ-ODDDIV-Odd-Numbers-of-Divisors/","link":"","permalink":"https://sea96.github.io/2017/02/21/SPOJ-ODDDIV-Odd-Numbers-of-Divisors/","excerpt":"题意给出一个正奇数$K(\\leq 1o^4)$，两个正整数$low$, $high(0&lt; low \\leq high &lt; 10^{10})$。问有多少个整数属于$[low, high]$，且包含$K$个因子。","text":"题意给出一个正奇数$K(\\leq 1o^4)$，两个正整数$low$, $high(0&lt; low \\leq high &lt; 10^{10})$。问有多少个整数属于$[low, high]$，且包含$K$个因子。 题解满足条件的数字一定是完全平方数。假设$n=p_1^{m_1}p_2^{m_2}…p_k^{m_k}$，那么$n$的约数个数为$(m_1+1)(m_2+1)…(m_k+1)$，那么$n^2$的约数个数为$(2m_1+1)(2m_2+1)…(2m_k+1)$。所以我们只要预处理将$[1,10^5]$所有数字分解质因数，用vec[k]从小到大，存下所有的，有k个约数的完全平方数，询问时二分即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 5;int prime[N/2];bool is_prime[N];vector&lt;ll&gt; vec[1500];void prime_table(int n) &#123; memset (is_prime, true, sizeof (is_prime)); is_prime[0] = is_prime[1] = false; int &amp;p = prime[0] = 0; for (int i=2; i&lt;=n; ++i) &#123; if (is_prime[i]) prime[++p] = i; for (int j=1; j&lt;=p &amp;&amp; i*prime[j]&lt;=n; ++j) &#123; is_prime[i*prime[j]] = false; if (i % prime[j] == 0) break; &#125; &#125;&#125;int count_factors(int n) &#123; //return cnt(n*n); int ret = 1; for (int i=1; i&lt;=prime[0]; ++i) &#123; if (n % prime[i] == 0) &#123; int p = prime[i], c = 0; while (n % p == 0) &#123; n /= p; c++; &#125; ret *= (2*c + 1); &#125; if (n &lt;= 1 || (n &lt;= 100000 &amp;&amp; is_prime[n])) break; &#125; if (n &gt; 1) ret *= (2*1+1); return ret;&#125;void init() &#123; prime_table(100000); for (int i=1; i&lt;=100000; ++i) &#123; int cnt = count_factors(i); vec[cnt].push_back((ll)i*i); &#125;&#125;int k;ll low, high;int main() &#123; init(); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%lld%lld\", &amp;k, &amp;low, &amp;high); if (k &gt;= 1500 || vec[k].size() == 0) puts(\"0\"); else &#123; int p1 = lower_bound(vec[k].begin(), vec[k].end(), low) - vec[k].begin(); int p2 = upper_bound(vec[k].begin(), vec[k].end(), high) - vec[k].begin(); printf(\"%d\\n\", p2-p1); &#125; &#125; return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"数论","slug":"数论","permalink":"https://sea96.github.io/tags/数论/"}]},{"title":"“玲珑杯”ACM比赛 Round #10","slug":"“玲珑杯”ACM比赛-Round-10","date":"2017-02-21T11:42:20.000Z","updated":"2017-05-13T14:23:50.296Z","comments":true,"path":"2017/02/21/“玲珑杯”ACM比赛-Round-10/","link":"","permalink":"https://sea96.github.io/2017/02/21/“玲珑杯”ACM比赛-Round-10/","excerpt":"","text":"A. Black and White题意$n(\\leq 10^6)$个格子从左到右排列，每个格子可以填黑色或者白色，但是不能有连续$a(\\leq 10^6)$个黑色或者连续$b(\\leq 10^6)$个白色，问填完$n$个格子的方案数。 题解一下子联想到BestCoder Round #75 1003 King’s Order（不超过$3$个连续相同的），那题的做法：定义$f[i]$表示前$i$个满足条件的方案数，则$$f[i]=\\sum_{j=1}^{3}f[i-j]*25$$意思是使得最后$j$个连续相同。但是这题$a$和$b$范围太大，显然不是这么做的，但是思想可以借鉴。定义$f[i][0/1]$表示前$i$个最后一个是$0$（白色）或$1$（黑色）的方案数。状态转移方程：$$f[i][1]=f[i-1][0]+f[i-1][1]-f[i-1-(b-1)][0]$$意思是如果第$i$块填黑色，第$i-1$块当然可以填白色，但是如果填黑色的话，去掉连续$b$个相同的方案数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e6 + 5;const int MOD = 1e9 + 7;ll f[N][2];int n, a, b;ll pow_mod(ll x, int n) &#123; ll ret = 1; for (; n; n&gt;&gt;=1) &#123; if (n &amp; 1) ret = ret * x % MOD; x = x * x % MOD; &#125; return ret;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;n); if (a &gt; b) swap(a, b); if (b == 1) &#123; puts(\"0\"); continue; &#125; if (a &gt; n) &#123; printf(\"%lld\\n\", pow_mod(2LL, n)); continue; &#125; else if (a == 1) &#123; if (b &lt;= n) puts(\"0\"); else printf(\"1\\n\"); continue; &#125; f[0][0] = f[0][1] = 1; int m = a - 1; for (int i=1; i&lt;=m; ++i) &#123; f[i][0] = f[i][1] = pow_mod(2LL, i-1); &#125; for (int i=m+1; i&lt;=n; ++i) &#123; f[i][1] = (f[i-1][0]+f[i-1][1])%MOD; if (i-1 &gt;= b-1) f[i][1] = (f[i][1]-f[i-1-(b-1)][0]+MOD)%MOD; f[i][0] = (f[i-1][1]+f[i-1][0])%MOD; if (i-1 &gt;= a-1) f[i][0] = (f[i][0]-f[i-1-(a-1)][1]+MOD)%MOD; &#125; printf(\"%lld\\n\", (f[n][0]+f[n][1])%MOD); &#125; return 0;&#125; E. Six and One题意定义$n=\\prod a_i$，$a_i$只由1或者6组成，问$[L,R]$范围内$(L,R\\leq 10^{10})$，有多少个$n$。 题解可以发现其实满足条件的$n$并不多，先打表出所有$a_i$，然后DFS处理出所有$n$，排好序后二分查询即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 5;vector&lt;ll&gt; a;int sz;void DFS(ll x) &#123; if (x &gt; (ll)(1e10)) return ; else if (x != 0) a.push_back(x); DFS(x*10+1); DFS(x*10+6);&#125;void DFS2(int i, ll x) &#123; a.push_back(x); for (int j=i; j&lt;sz; ++j) &#123; if (x &lt;= (ll)(1e10)/a[j]) DFS2(j, x*a[j]); else break; &#125;&#125; void init() &#123; DFS(0); sort(a.begin(), a.end()); sz = a.size(); DFS2(1, 1LL); sort(a.begin(), a.end()); vector&lt;ll&gt;::iterator it = unique(a.begin(), a.end()); if (it != a.end()) a.erase(it, a.end());&#125;int main() &#123; init(); int T; scanf(\"%d\", &amp;T); while (T--) &#123; ll L, R; scanf(\"%lld%lld\", &amp;L, &amp;R); int p1 = lower_bound(a.begin(), a.end(), L) - a.begin(); int p2 = upper_bound(a.begin(), a.end(), R) - a.begin(); printf(\"%d\\n\", p2-p1); &#125; return 0;&#125;","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"组合数学","slug":"组合数学","permalink":"https://sea96.github.io/tags/组合数学/"}]}]}