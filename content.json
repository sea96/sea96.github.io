{"meta":{"title":"清逸","subtitle":null,"description":"知者不言，言者不知。","author":"清逸","url":"https://sea96.github.io"},"pages":[{"title":"关于","date":"2017-02-21T12:18:24.000Z","updated":"2017-02-26T07:33:00.830Z","comments":false,"path":"about/index.html","permalink":"https://sea96.github.io/about/index.html","excerpt":"","text":"Hello, I am O(∩_∩)O"},{"title":"标签云","date":"2017-02-21T12:08:14.000Z","updated":"2017-05-01T13:30:37.518Z","comments":false,"path":"tags/index.html","permalink":"https://sea96.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-02-21T12:16:31.000Z","updated":"2017-02-26T07:31:26.688Z","comments":false,"path":"categories/index.html","permalink":"https://sea96.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"快速傅里叶变换","slug":"快速傅里叶变换","date":"2017-05-13T00:59:46.000Z","updated":"2017-05-13T01:04:51.453Z","comments":true,"path":"2017/05/13/快速傅里叶变换/","link":"","permalink":"https://sea96.github.io/2017/05/13/快速傅里叶变换/","excerpt":"","text":"","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://sea96.github.io/tags/数学/"}]},{"title":"后缀数组","slug":"后缀数组","date":"2017-05-05T09:05:53.000Z","updated":"2017-05-13T01:44:35.726Z","comments":true,"path":"2017/05/05/后缀数组/","link":"","permalink":"https://sea96.github.io/2017/05/05/后缀数组/","excerpt":"后缀数组是处理字符串的有力工具。后缀数组是后缀树的一个非常精巧的替代品，它比后缀树容易编程实现，能够实现后缀树的很多功能，而时间复杂度也并不逊色，而且它比后缀树所占用的内存空间小很多。","text":"后缀数组是处理字符串的有力工具。后缀数组是后缀树的一个非常精巧的替代品，它比后缀树容易编程实现，能够实现后缀树的很多功能，而时间复杂度也并不逊色，而且它比后缀树所占用的内存空间小很多。 概念 后缀：设一个字符串为S[0 ~ |S|-1]，后缀i表示S[i ~ |S|-1]。举例：有一个字符串BANANA，后缀3就是ANA。 后缀数组：后缀数组sa保存的是所有后缀按字典序从小到大排序的结果（在字符串S的下标）。 举例：BANANA的后缀数组sa[]={5,3,1,0,4,2}，更详细点就是后缀5（A），后缀3（ANA），后缀1（ANANA）。。。 名次数组：名次数组rank[i]表示++后缀i在后缀数组里的名次（在sa数组的下标）。++ 容易看出，后缀数组和名次数组为互逆运算。举例：一个字符串BANANA，rank[3]（后缀3为ANA）等于1（结合上文），逆运算：sa[1]=3。 高度数组：高度数组height[i]表示sa[i]和sa[i-1]的LCP（最长公共前缀）。 求法后缀数组 DA算法：倍增思想+基数排序（双关键字排序），复杂度 $O(nlogn)$ void build_sa(int m = 128) { int i, j, p, *x = tmp_one, *y = tmp_two; //对于单字符S[i~i]的基数排序 for (i=0; i&lt;m; ++i) c[i] = 0; for (i=0; i&lt;n; ++i) c[x[i]=s[i]]++; for (i=1; i&lt;m; ++i) c[i] += c[i-1]; for (i=n-1; i>=0; --i) sa[--c[x[i]]] = i; //对于长度j，关键字为(S[i~(i+j-1)],S[(i+j)~(i+j+j-1)])进行基数排序 for (j=1, p=0; j&lt;=n; j&lt;&lt;=1) { //直接利用sa数组排序第二关键字 for (p=0, i=n-j; i&lt;n; ++i) y[p++] = i; for (i=0; i&lt;n; ++i) if (sa[i] >= j) y[p++] = sa[i] - j; //基数排序第一关键字 for (i=0; i&lt;m; ++i) c[i] = 0; for (i=0; i&lt;n; ++i) c[x[y[i]]]++; for (i=1; i&lt;m; ++i) c[i] += c[i-1]; for (i=n-1; i>=0; --i) sa[--c[x[y[i]]]] = y[i]; swap(x, y); //根据sa和y数组计算新的x数组 for (p=1, x[sa[0]]=0, i=1; i&lt;n; ++i) { x[sa[i]] = (y[sa[i-1]] == y[sa[i]] &amp;&amp; y[sa[i-1]+j] == y[sa[i]+j] ? p-1 : p++); } if ((m=p) >= n) break; } } 代码解释：参数m表示不同字符的个数（会增大），数组s是字符串转换成数字数组。用到三个辅助数组，x数组记录当前长度j下后缀i的排名，y数组记录第二关键字排序的结果，c数组用来计数和定位。 DC3算法 时间复杂度 $O(n)$ 代码链接 参考资料 后缀数组（入门经典学习笔记） 数据结构之后缀数组 后缀数组(suffix array)详解","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://sea96.github.io/tags/字符串/"}]},{"title":"单调栈","slug":"单调栈","date":"2017-04-20T11:05:29.000Z","updated":"2017-05-13T01:05:43.109Z","comments":true,"path":"2017/04/20/单调栈/","link":"","permalink":"https://sea96.github.io/2017/04/20/单调栈/","excerpt":"定义单调栈就是栈，满足栈内的元素是单调的。 单调递减栈：从栈顶到栈底单调递减的栈 单调递减栈：从栈顶到栈底单调递减的栈","text":"定义单调栈就是栈，满足栈内的元素是单调的。 单调递减栈：从栈顶到栈底单调递减的栈 单调递减栈：从栈顶到栈底单调递减的栈 应用单调栈最常用的功能是可以求出一个元素向左（或向右）所能扩展到的最大长度，并不是说在这一段区间内是单调的，而是保证在该区间内该元素一定是最大或最小。 题目POJ 3250 Bad Hair Day题意有$n$个人，问每一个人向右看能看到人的数量的总和（能看到的人身高比当前的人矮）。 题解从后往前，维护一个单调递减栈来求每一个人右边的高度比它小的最近的位置即可。code POJ 2796 Feel Good题意有$n$个元素，问一个区间长度乘以区间最小值的最大值。 题解也就是求每一个元素往左（右）值比它小的最近的位置。维护两次单调递减栈。code SCU 1773 Largest Rectangle in a Histogram题意给$n$个宽度为1的矩形，求最大连续矩形面积。 题解矩形的面积等于区间长度乘以区间最小高度，做法和POJ 2796一样。","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"}]},{"title":"Codeforces Round #406 (Div. 2)","slug":"Codeforces-Round-406-Div-2","date":"2017-04-11T13:17:10.000Z","updated":"2017-05-13T05:22:45.759Z","comments":true,"path":"2017/04/11/Codeforces-Round-406-Div-2/","link":"","permalink":"https://sea96.github.io/2017/04/11/Codeforces-Round-406-Div-2/","excerpt":"A. The Monster给定$a,b,c,d$，问是否存在$k_1,k_2$，使得$b+k_1a=d+k_2c$.暴力枚举其中一个$k$判断是否能整除即可。","text":"A. The Monster给定$a,b,c,d$，问是否存在$k_1,k_2$，使得$b+k_1a=d+k_2c$.暴力枚举其中一个$k$判断是否能整除即可。 B. Not Afraid两个宇宙，每一个人在两个宇宙里一个是忠诚者，另一个是叛徒。将他们分组，问是否可能存在一个组里的人都是叛徒。如果一个数的正负数都在同一个组里，那么这个组一定有一个是忠诚者，否则可能都是叛徒。 C. Berzerk题意$n$个点形成环，两个玩家分别有$k_1,k_2$个数字$s_i$，每次都可以选择一个数字$s_i$，顺时针跳到后面第$s_i$个位置，谁先跳到第1位置谁就获胜，问从两个人从每个位置出发的最优结局。 题解正方向DFS的话，因为后继不能保证在有限次数后到达终点，那么选择从终点逆推，定义$f[2][i]$表示玩家走到$i$位置的结局是win or Lose，一个状态判为$Win$的条件是至少存在一个后继是$Lose$；一个状态判为$Lose$的条件是后继都是Win。使用记忆化搜索，每个状态只遍历一次，时间复杂度：$O(n)$.code D. Legacy题意给定$q$个操作，有3种有向边： $u$到$v$连一条边 $u$到$[l,r]$区间里所有点连一条边 $[l,r]$区间所有点到$u$连一条边 问从s点出发到每个点的最短路。 题解直接建边的话，最多有$n^2$条边，显然不能承受。区间覆盖问题考虑使用线段树，又因为线段树的树形结构可以将每个节点作为建图辅助点，具体说就是线段树的每个节点之间连上权值为0的边，对于操作2，一个点连到区间的操作转化为连到包含该区间的线段树上的所有节点，操作3同理，但是新建一棵线段树，因为不能和操作2冲突。然后使用Dijkstra跑最短路即可，时间复杂度：$O(nlog^2n)$.code E. Till I Collapse题意将$n$个数字分成若干个区间，问对于每一个$k$，每个区间的不同的数字的数量不超过$k$个的最少区间数。 题解每次贪心地选择最远的端点满足区间里不同的数字不超过$k$个。直接遍历的话，对于每一个$k$的时间复杂度$O(n)$，总时间复杂度：$O(n^2)$.参照可持久线段树求区间不同数字的个数的方法，可以维护以$i$为终点，前缀不同数字的个数（每个数字定位在最后出现的位置），那么在树上二分找到最左的位置前缀的和为$(sum-k)$，这也是为什么要定位在最后的位置，保证有$k$个不同的数字。code","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"},{"name":"线段树","slug":"线段树","permalink":"https://sea96.github.io/tags/线段树/"},{"name":"最短路","slug":"最短路","permalink":"https://sea96.github.io/tags/最短路/"},{"name":"博弈","slug":"博弈","permalink":"https://sea96.github.io/tags/博弈/"}]},{"title":"初等数论","slug":"初等数论","date":"2017-04-09T01:37:58.000Z","updated":"2017-05-13T01:05:51.638Z","comments":true,"path":"2017/04/09/初等数论/","link":"","permalink":"https://sea96.github.io/2017/04/09/初等数论/","excerpt":"素数运算 素数的定义质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个因数的数）","text":"素数运算 素数的定义质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个因数的数） 素数的性质和定理 欧拉证明：素数在数量上是无限的（不存在最大的素数） 存在任意长的一段连续数，其中的所有数都是合数（相邻素数之间的间隔任意大） 所有大于2的素数都可以唯一地表示成两个平方数之差。 当$n$为大于2的整数时，$2^n+1$和$2^n-1$两个数中，如果其中一个数是素数，那么另一个数一定是合数。 哥德巴赫猜想：每个大于4的偶数可以写成两个奇素数的和（陈景润证明：偶数为一个素数及一个不超过两个素数的乘积之和，简称“1+2”） 唯一分解定理：每个正整数都可以唯一地表示成素数的乘积，即有唯一的分解质因数的方案：$n=p_1^{e_1}p_2^{e_2}…p_k^{e_k}$根据上面的式子，可以推知$n$共有 $(e_{1}+1)(e_{2}+1)…(e_{k}+1)$个约数。 素数的判定试除法试用2…$\\lfloor \\sqrt{n} \\rfloor$去除$n$（更好的做法是筛选出[2..$\\sqrt{n}$]里的所有素数），$n$是素数当且仅当没有一个试用的除数能被$n$整除。时间复杂度：$O(\\sqrt{n})$ Miller_Rabin方法米勒-拉宾素性检验是一种素数判定法则，利用随机化算法判断一个数是合数还是可能是素数。测试大素数的Miller_Rabin方法基于下述定理： 费马小定理：如果$n$是素数，$a$是整数，则 $a^n \\equiv a\\pmod{n}$如果 $a$ 不是 $n$ 的倍数，也可以写成 $a^{n-1} \\equiv 1\\pmod{n}$ 二次探测定理：如果$n$是奇素数，则$a^2 ≡ 1\\pmod n$的解为$a ≡ 1\\pmod n$或$a ≡ n-1\\pmod n$ 重复$k$次计算，每次在$[1,n-1]$范围内随机选取一个$a$，若$a^{n-1} \\neq 1\\pmod{n}$，则$n$是合数。若随机选取的$k$个$a$都使得$a^{n-1} \\equiv 1\\pmod{n}$，则$n$是素数或伪素数。若使用模指数运算的快速算法，这个算法的运行时间是：$O(klog_{2}^3n)$经验结论： if n &lt; 3,215,031,751, it is enough to test a = 2, 3, 5, and 7; if n &lt; 4,759,123,141, it is enough to test a = 2, 7, and 61; if n &lt; 18,446,744,073,709,551,616 = $2^{64}$, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37. if n &lt; 318,665,857,834,031,151,167,461, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37. if n &lt; 3,317,044,064,679,887,385,961,981, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, and 41. 素数的筛法筛选[2..$n$]中的所有素数 埃拉托斯特尼筛法按递增顺序搜索筛中的最小数，将其倍数从筛中筛去，最终筛中留下的数即为素数。时间复杂度：$O(nloglogn)$ 欧拉筛法在埃式筛法上改进：每个合数仅被它最小的质因数筛去。时间复杂度：$O(n)$此方法可以求积性函数$f(x)$，即在$O(n)$时间复杂度内预处理$f(1)$,$f(2)$ … $f(n)$的值，典型的用途是求欧拉函数。 公约数问题 最大公约数和最小公倍数若$x=p_1^{k_1}p_2^{k_2}…p_r^{k_r}$$y=p_1^{n_1}p_2^{n_2}…p_r^{n_r}$则$GCD(x,y)=p_1^{min(k_1,n_1)}p_2^{min(k_2,n_2)}…p_r^{min(k_r,n_r)}$$LCM(x,y)=p_1^{max(k_1,n_1)}p_2^{max(k_2,n_2)}…p_r^{max(k_r,n_r)}$同时可以得到$x×y=GCD(x,y)×LCM(x,y)$ 若$x=p×GCD(x,y)$$y=q×GCD(x,y)$则$x+y=(p+q)×GCD(x,y)$那么 $GCD(x,y)=GCD(x,x+y)$同理可得 $GCD(x,y)=GCD(x+y,LCM(x,y))$ 欧几里得算法$$GCD(a,b)=\\begin{cases}b&amp; \\text{a = 0}\\\\GCD(b,a\\mod b)&amp; \\text{a $\\neq$ 0}\\end{cases}$$简单证明：设$g=GCD(a,b)$将$a \\mod b$化成$a$与$b$的线性组合，即$a \\mod b=a-\\lfloor{\\frac{a}{b}}\\rfloor *b$。由于$g$能整除$a$和$b$，那么$g$一定能整除$a$与$b$的线性组合，即$g$能整除$(a \\% b)$，所以$GCD(a,b)=GCD(b,a\\% b)$.时间复杂度：$O(log \\max(a,b))$ 扩展欧几里得算法已知整数$a$、$b$，扩展欧几里得算法可以在求得$a$、$b$的最大公约数的同时，能找到整数$x$、$y$（其中一个很可能是负数）满足$ax+by=GCD(a,b)$.若$b=0$，则$GCD(a,b)=a$，$x=1$，$y=0$；若$b\\neq 0$，首先递归求解满足$bx’+(a\\mod b)y’=GCD(b,a\\mod b)$的$x’$、$y’$，因为$GCD(a,b)=GCD(b,a\\% b)$，所以有以下等式成立：$$bx’+(a- \\lfloor{\\frac{a}{b}}\\rfloor b)y’=ay’+b(x’- \\lfloor{\\frac{a}{b}}\\rfloor y’)=ax+by$$选择$x=y’$，$y=x’- \\lfloor{\\frac{a}{b}}\\rfloor y’$就可以满足等式。 应用扩展欧几里得算法，可以求解如下形式的二元一次不定方程：$$ax+by=c$$首先先求解$ax+by=GCD(a,b)$的$x$和$y$，记$g=GCD(a,b)$.若$c$不能被$g$整除，则无整数解；否则初始解：$x_{0}=x\\frac{c}{g}$，$y_{0}=y\\frac{c}{g}$.不定方程的通解形式为：$$\\begin{cases}x_{k}=x_{0}+k\\frac{b}{g} &amp; \\\\y_{k}=y_{0}-k\\frac{a}{g} &amp; \\text{k $\\in $ Z}\\end{cases}$$ 同余问题同余关系式 威尔逊定理：$(p-1)! \\equiv -1 ({\\mbox{mod}} p)$ 费马小定理：${\\displaystyle a^{p}\\equiv a{\\pmod {p}}}$ 欧拉定理：$a^{\\varphi (n)}\\equiv 1{\\pmod {n}}$ 卡迈克尔函数：$a^{\\lambda (n)}\\equiv 1{\\pmod {n}}$ 阶乘幂：$(x)_{k}\\equiv x(x-1)(x-2)\\cdots (x-k+1)\\equiv 0{\\pmod {k!}}$ 其它定理 若 $ac\\equiv bc\\pmod n$ 且 $GCD(c,n)=d$，则$a \\equiv b \\pmod{ \\frac {n}{d}}$ 若 $d \\neq 0$ 且 $ad \\equiv bd \\pmod {nd}$，则 $a \\equiv b \\pmod n$ 若 $n$ 和 $a$ 互质，则一次同余方程 $ax+b\\equiv 0 \\pmod n$ 有解模运算满足交换律（除了除法） 同余方程 求解一次同余方程 $ax\\equiv b\\pmod n$也就是要求解二元一次方程 $ax-my=b$，使用扩展欧几里得算法求解。令 $g=GCD(a,m)$，如果$b$不能被$g$整除，那么同余方程无解；否则有$g$个解，即$x_k=x_0+k \\frac{m}{g}(0\\leq k &lt; g)$ 求解同余方程 $a^x\\equiv b\\pmod n$ 求解一元线性同余方程组$$\\begin{cases}x≡a_1 \\pmod {m_1} &amp; \\\\x≡a_2 \\pmod {m_2} &amp; \\\\… \\\\x≡a_n \\pmod {m_n} &amp; \\\\\\end{cases}$$中国剩余定理若$m_1$、$m_2$ …. $m_n$ 两两互质，则对任意整数 $a_1$、$a_2$ …. $a_n$ 方程组有解。令$M=m_1m_2m_3…m_n$$w_i=\\frac{M}{m_i}$$w_i’$ 为 $w_i$ 模 $m_i$ 下的逆元，即 $w_iw_i’≡1 \\pmod {m_i}$则$x=(a_1w_1w_1’+a_2w_2w_2’+…+a_nw_nw_n’) \\pmod M$ 模逆元在求解除法取模问题 $(a / b) \\% n$ 时，我们可以转化为 $(a \\% (b \\cdot n))/b$。但是 $b$ 范围很大时，$bn$ 可能存不下，所以我们使用乘法逆元将除法转换为乘法。在模 $n$ 的意义下，把 $a$ 的模逆元写作 $a^{-1}$，满足$aa^{-1}\\equiv 1{\\pmod {n}}$，那么 $\\frac {a}{b}=ab^{-1} \\pmod n$*$a$ 对模数 $n$ 之模逆元存在的充分必要条件是 $a$ 和 $n$ 互质。求解模逆元的几种方法： 使用扩展欧几里得算法求解 $ax \\equiv 1 \\pmod n$，即 $ax-ny=1$。若 $g=GCD(a,n)=1$，该模逆元存在，且有无穷个解，选取最小正整数解即可。 使用欧拉定理当 $a$ 和 $n$ 互质时，有 $a^{\\varphi (n)}\\equiv 1{\\pmod n}$。那么分解为 $a^{\\varphi (n)}=a\\cdot a^{\\varphi (n)-1}\\equiv 1{\\pmod {n}}$，其中的 $a^{\\varphi (n)-1}$ 即为 $a$ 关于模 $n$ 之模逆元。特别地，若 $n$ 为素数时，$a$ 的模逆元为 $a^{n-2}$（费马小定理） 使用线性递推法$n$为奇素数时，记 $i$ 的逆元为 $inv[i]$，有递推式：$$inv[i]=\\begin{cases}1&amp; \\text{i = 1}\\\\(n-\\frac{n}{i}) \\cdot inv[n \\% i]\\% n &amp; \\text{i $&gt;$ 1}\\end{cases}$$证明（略，公式移项）此方法以在 $O(n)$ 时间复杂度求解小于 $n$ 的所有模逆元。 积性函数在数论中，积性函数是指一个定义域为正整数 $n$ 的算术函数 $f(n)$，有如下性质：$f(1) = 1$，且当 $a$ 和 $b$ 互质时，$f(ab) = f(a) f(b)$若对于任意两个正整数 $a$ 和 $b$ ，都有 $f(ab)=f(a)f(b)$，则称此函数 $f$ 为完全积性函数。显然，对于任意积性函数，$f(1)=1$$GCD(a,b)$ 也是积性函数（当一个数字固定的情况下） 欧拉函数定义欧拉函数$φ(n)$，表示小于等于 $n$ 且与 $n$ 互质的正整数的个数。例如：$φ(1)=φ(2)=1$，$φ(3)=φ(4)=2$欧拉函数是积性函数，即当 $n$、$m$ 互质时，$φ(nm)=φ(n)φ(m)$。但不是完全积性函数。 欧拉函数的值 当 $n$ 是素数时，$φ(n)=n-1$ 当 $n$ 是合数时，$φ(n)&lt;n-1$，且 $φ(n) \\leq n- \\sqrt n$ 若 $n$ 是素数 $p$ 的 $k$ 次幂，$φ(n)=φ(p^{k})=p^{k}-p^{k-1}=(p-1)p^{k-1}$，因为除了 $p$ 的倍数外，其他数都跟 $n$ 互质。 一般地，设 $n=p_1^{k_1}p_2^{k_2}…p_r^{k_r}$则$$φ(n)=\\prod_{i=1}^{r}p_{i}^{k_{i}-1}(p_{i}-1)=n \\prod_{p|n} \\left(1-{\\frac {1}{p}} \\right)$$ 欧拉定理若两个正整数 $n$ 和 $a$ 互质，则 $a^{φ(n)} \\equiv 1 \\pmod n$推论：$a^{φ(n)+1} \\equiv a \\pmod n$欧拉定理的一个特例是费马小定理（若 $n$ 是素数，则 $φ(n)=n-1$）。 欧拉函数的性质 $n$ 的欧拉函数 $\\varphi (n)$ 也是循环群 $C_n$ 的生成元的个数，即$$ \\sum_{d \\mid n} \\varphi (d)=n $$其中的 $d$ 为 $n$ 的正约数。运用莫比乌斯反演来“翻转”这个和，就可以得到另一个关于 $\\varphi (n)$ 的公式：$$ \\varphi (n)=\\sum _{d \\mid n} {d\\cdot \\mu (n/d)}$$其中 $μ$ 是所谓的莫比乌斯函数，定义在正整数上。 当 $n&gt;1$ 时，$1…n$ 中与 $n$ 互质的整数和为 $\\frac{n\\varphi (n)}{2}$ 当 $n$ 为奇数时，有 $\\varphi (2n)= \\varphi (n)$ 莫比乌斯函数定义莫比乌斯函数$μ(n)$，表示非平方数 $n$ 的质因子个数，$μ(n)$ 是 $φ(n)$ 的反演函数。 参考资料 Matrix67 Blog维基百科 质数维基百科 辗转相除法维基百科 扩展欧几里得算法模逆元维基百科 同余维基百科 积性函数","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://sea96.github.io/tags/数论/"}]},{"title":"2016-2017 ACM-ICPC Pacific Northwest Regional Contest (Div. 2)","slug":"2016-2017-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-2","date":"2017-04-06T05:04:09.000Z","updated":"2017-05-13T05:22:13.850Z","comments":true,"path":"2017/04/06/2016-2017-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-2/","link":"","permalink":"https://sea96.github.io/2017/04/06/2016-2017-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-2/","excerpt":"A. Alphabet裸LIS","text":"A. Alphabet裸LIS B. Barbells问杠铃和盘子有多少种不同的搭配方式。关键求出左右相等且不重复使用盘子的方案数，因为数据范围小，考虑状态压缩，用map&lt;ll, vector&lt;int&gt;&gt;存储每一个重量对应的各个mask值。 #include &lt;bits/stdc++.h> using namespace std; typedef long long ll; map&lt;ll, vector&lt;int> > mp; set&lt;ll> tmp, ans; ll b[15], p[15]; int n, m; int main() { scanf(\"%d%d\", &amp;n, &amp;m); for (int i=1; i&lt;=n; ++i) scanf(\"%I64d\", &amp;b[i]); for (int i=1; i&lt;=m; ++i) scanf(\"%I64d\", &amp;p[i]); for (int mask=0; mask&lt;(1&lt;&lt;m); ++mask) { ll x = 0; for (int j=0; j&lt;m; ++j) if (mask &amp; (1&lt;&lt;j)) x += p[j+1]; mp[x].push_back(mask); } for (auto it: mp) { int sz = it.second.size(); if (sz &lt; 2) continue; bool ok = false; for (int j=0; !ok &amp;&amp; j&lt;sz; ++j) for (int k=j+1; !ok &amp;&amp; k&lt;sz; ++k) { if ((it.second[j] &amp; it.second[k]) == 0) { tmp.insert(2LL*it.first); ok = true; } } } tmp.insert(0); for (int i=1; i&lt;=n; ++i) { for (auto x: tmp) { ans.insert(b[i]+x); } } for (auto x: ans) { printf(\"%I64d\\n\", x); } return 0; } C. Buggy Robot一个机器人走迷宫，给定指令序列，问最少插入或删除多少指令能使得机器人走出迷宫。转化为最短路问题，每一个坐标看成一个点，相邻坐标之间有边，权值为0或1，如果按照指令进行边权值为0，否则为1。 #include &lt;bits/stdc++.h> using namespace std; const int N = 55; const int INF = 0x3f3f3f3f; const int dx[4] = {-1, 1, 0, 0}; const int dy[4] = {0, 0, -1, 1}; const char dir[4] = {'U', 'D', 'L', 'R'}; char maze[N][N]; char s[N]; int dis[N][N][N]; struct Node { int v, x, y, z; bool operator &lt; (const Node &amp;rhs) const { return !(v &lt; rhs.v); } }; int n, m, len; int sx, sy, ex, ey; void Dijkstra() { memset(dis, 127, sizeof(dis)); dis[sx][sy][0] = 0; priority_queue&lt;Node> pque; pque.push(Node{dis[sx][sy][0], sx, sy, 0}); while (!pque.empty()) { Node u = pque.top(); pque.pop(); if (u.x == ex &amp;&amp; u.y == ey) break; if (u.z &lt; len) { int d = 0; for (; d&lt;4; ++d) if (dir[d] == s[u.z+1]) break; int tx = u.x + dx[d], ty = u.y + dy[d]; if (maze[tx][ty] == 0 || maze[tx][ty] == '#') tx = u.x, ty = u.y; if (dis[tx][ty][u.z+1] > dis[u.x][u.y][u.z]) { dis[tx][ty][u.z+1] = dis[u.x][u.y][u.z]; pque.push(Node{dis[tx][ty][u.z+1], tx, ty, u.z+1}); } } //delete if (u.z &lt; len &amp;&amp; dis[u.x][u.y][u.z+1] > dis[u.x][u.y][u.z]+1) { dis[u.x][u.y][u.z+1] = dis[u.x][u.y][u.z] + 1; pque.push(Node{dis[u.x][u.y][u.z+1], u.x, u.y, u.z+1}); } //insert for (int i=0; i&lt;4; ++i) { int tx = u.x + dx[i], ty = u.y + dy[i]; if (maze[tx][ty] == 0 || maze[tx][ty] == '#') continue; if (dis[tx][ty][u.z] > dis[u.x][u.y][u.z]+1) { dis[tx][ty][u.z] = dis[u.x][u.y][u.z] + 1; pque.push(Node{dis[tx][ty][u.z], tx, ty, u.z}); } } } } int main() { scanf(\"%d%d\", &amp;n, &amp;m); for (int i=1; i&lt;=n; ++i) { scanf(\"%s\", maze[i]+1); for (int j=1; j&lt;=m; ++j) { if (maze[i][j] == 'R') sx = i, sy = j; if (maze[i][j] == 'E') ex = i, ey = j; } } scanf(\"%s\", s+1); len = strlen(s+1); Dijkstra(); int ans = INF; for (int i=0; i&lt;=len; ++i) ans = min(ans, dis[ex][ey][i]); printf(\"%d\\n\", ans); return 0; } D. Cameras每$r$个有2个相机，如果不够贪心地放在最后面，用树状数组动态维护区间和即可。 E. Contest Score优先队列模拟即可 F. Equality模拟签到题 G. Gravity模拟题，从下往上操作 H. Islands求连通块数量。DFS求出连通块数量，剩下可能是陆地的当作海处理。 I. Mismatched Socks问最多能有多少颜色不同的袜子。如果数量最多的某种颜色的袜子不超过$\\frac {sum}{2}$，那么全部都可以错误搭配，搭配的方法：$(0,\\frac {sum}{2})$，$(1,\\frac {sum}{2}+1)$… $ans=\\frac {sum}{2}$否则除了数量最多的袜子外，其他的都能找到错误匹配，$ans=sum-mx$ J. Postman问邮递员送信的最短路程。贪心策略：从最远点往里面遍历，如果当前点数量不超过容量，那么在搭上相邻位置的信封数量。 #include &lt;bits/stdc++.h> using namespace std; typedef long long ll; const int N = 1000 + 5; struct House { int x, m; bool operator &lt; (const House &amp;rhs) const { return x &lt; rhs.x; } }h[N]; int n, k; void debug() { for (int i=1; i&lt;=n; ++i) { printf(\"(%d,%d)\\n\", h[i].x, h[i].m); } } int main() { scanf(\"%d%d\", &amp;n, &amp;k); int c = 0; for (int i=1; i&lt;=n; ++i) { ++c; scanf(\"%d%d\", &amp;h[c].x, &amp;h[c].m); if (!h[c].x) c--; } n = c; h[++n].x = 0; sort(h+1, h+n+1); int p = 1; for (int i=1; i&lt;=n; ++i) if (!h[i].x) { p = i; break; } ll ans = 0, free = 0; int i = 1; for (; i&lt;p; i++) { ll mn = min(free, (ll)h[i].m); h[i].m -= mn; free -= mn; ll dis = -h[i].x; ll cnt = h[i].m / k; if (h[i].m % k) { cnt++; free += k - (h[i].m % k); } ans += dis * cnt * 2; } i = n; free = 0; for (; i>p; --i) { ll mn = min(free, (ll)h[i].m); h[i].m -= mn; free -= mn; ll dis = h[i].x; ll cnt = h[i].m / k; if (h[i].m % k) { cnt++; free += k - (h[i].m % k); } ans += dis * cnt * 2; } printf(\"%I64d\\n\", ans); return 0; } K. Six Sides抛六面的骰子，问第一个人赢的概率。简单概率计算，注意总局数去掉平局的次数。 L. Three Square三个矩形能否组成正四边形。简单暴力枚举。 M. Zigzag求最长折线子序列。$dp[i][0/1]$表示从$i$开始下降/上升的最长长度，记忆化搜索即可。 #include &lt;bits/stdc++.h> using namespace std; const int N = 50 + 5; int a[N]; int dp[N][2]; int s[N], g[N]; int n, ans; void Max(int &amp;x, int y) { if (x &lt; y) x = y; } int DFS(int i, int up) { if (i >= n) return dp[n][up] = 1; if (dp[i][up] != -1) return dp[i][up]; int &amp;ret = dp[i][up] = 1; for (int j=i+1; j&lt;=n; ++j) { if (up &amp;&amp; a[j] > a[i]) Max(ret, DFS(j, up^1)+1); else if (!up &amp;&amp; a[j] &lt; a[i]) Max(ret, DFS(j, up^1)+1); } return ret; } int main() { scanf(\"%d\", &amp;n); for (int i=1; i&lt;=n; ++i) { scanf(\"%d\", &amp;a[i]); } memset(dp, -1, sizeof(dp)); ans = 1; for (int i=1; i&lt;=n; ++i) { if (dp[i][1] == -1) { for (int j=i+1; j&lt;=n; ++j) if (a[j] > a[i]) { Max(dp[i][1], DFS(j, 0)+1); } } if (dp[i][0] == -1) { for (int j=i+1; j&lt;=n; ++j) if (a[j] &lt; a[i]) { Max(dp[i][0], DFS(j, 1)+1); } } Max(ans, dp[i][1]); Max(ans, dp[i][0]); } printf(\"%d\\n\", ans); return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://sea96.github.io/tags/DFS/"},{"name":"STL","slug":"STL","permalink":"https://sea96.github.io/tags/STL/"},{"name":"位运算","slug":"位运算","permalink":"https://sea96.github.io/tags/位运算/"},{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"},{"name":"概率","slug":"概率","permalink":"https://sea96.github.io/tags/概率/"},{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"}]},{"title":"Egyptian Collegiate Programming Contest (ECPC 2015)","slug":"Egyptian-Collegiate-Programming-Contest-ECPC-2015","date":"2017-03-23T01:11:10.000Z","updated":"2017-05-13T05:23:00.907Z","comments":true,"path":"2017/03/23/Egyptian-Collegiate-Programming-Contest-ECPC-2015/","link":"","permalink":"https://sea96.github.io/2017/03/23/Egyptian-Collegiate-Programming-Contest-ECPC-2015/","excerpt":"A. Arcade Game题意给一个$n$位的数字，每一次等概率地变成按照数位全排列的某一个排列（各个位的数不同），要求变换后的数字比之前的大，问最终变成最大排列形式的数字的概率。","text":"A. Arcade Game题意给一个$n$位的数字，每一次等概率地变成按照数位全排列的某一个排列（各个位的数不同），要求变换后的数字比之前的大，问最终变成最大排列形式的数字的概率。 数据$1 \\leq n \\leq 9$ 题解设数字在全排列的位置为$k$，它最终变成最大数字的概率为$p_k$，那么$p_k = (\\sum_{j=k+1}^{n!}p_j) \\frac {1}{n!}$，$p_{n!}=1.0$（如果一开始的数字就是最大值，那么概率为0）。发现公式是关于计算后缀的和，可以迭代计算，每次更新后缀概率总和，在$O(n!-k)$时间复杂度解决。code B. Unlucky Teacher判断选择题哪个是正确答案，因为答案唯一，所以如果答案已给出，或者知道有三个选项是错误的就能知道答案。 C. Connecting Graph题意数据题解并查集 D. Frozen Rivers简单树形DP，状态转移方程：$dp[u]=(dp[v_{min}]+w_{min})+\\sum (dp[v]+w_{min}+(w-w_{min})*2)$ E. Palmyra题意有$n×m$的格子，每个格子上有一个数字$x_{i,j}$。问从(1,1)出发，每次往右走一格或者往下走一格，达到(n,m)后得到$(n+m-1)$个数字的乘积的6进制最多有几个后缀0。 数据$ 2 \\leq n,m \\leq 100 $$ 1 \\leq x_{i,j} \\leq 10^3 $ 题解在6进制产生后缀0的条件是有2和3的因子，所以也就是要在$(n+m-1)$步里得到尽可能多的2和3，但不是得到最多的2或者3就好，因为答案是$min(cnt_2,cnt_3)$。因为二元的最值，考虑其中一元用数组存储。设$dp[i][j][k]$表示从(1,1)出发到(i,j)为止，一共获得k个3，最多能获得2的数量。那么状态转移方程：$$ dp[i][j][k] = max(dp[i][j-1][k-x[i][j].three],dp[i-1][j][k-x[i][j].three])+x[i][j].two $$code F. Geometry水题，给长和宽，判断是正方形还是长方形。 G. It is all about wisdom题意数据题解二分+最短路 H. Tonight Dinner题意数据题解I. Salem水题，计算两个数字在二进制表示下不同的位的个数。dist = __builtin_popcount(x^y) J. Game简单博弈题，每个人有两种操作： LEFT：从右往左，相邻两个合并成一个 RIGHT：从左往右，相邻两个合并成一个 当剩下一个字母游戏结束，如果是元音字母则先手胜，否则后手胜利。这个胜利条件和一般的博弈稍微有点不同，需要判断当前状态是先手还是后手的turn。 K. PhD Math题意数据题解数位DP L. Candy Jars题意数据题解博弈 M. Building Force Fields题意数据题解","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"概率","slug":"概率","permalink":"https://sea96.github.io/tags/概率/"},{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"},{"name":"博弈","slug":"博弈","permalink":"https://sea96.github.io/tags/博弈/"},{"name":"并查集","slug":"并查集","permalink":"https://sea96.github.io/tags/并查集/"}]},{"title":"平方分割","slug":"平方分割","date":"2017-03-21T12:02:57.000Z","updated":"2017-05-13T01:04:15.765Z","comments":true,"path":"2017/03/21/平方分割/","link":"","permalink":"https://sea96.github.io/2017/03/21/平方分割/","excerpt":"概述 平方分割又叫做分桶法或者分块法，把排成一排的 $N$ 个元素每 $\\sqrt N $ 分在一个块（桶）里，这样的分割方法可以把对区间的操作的复杂度降至 $O(\\sqrt N)$。","text":"概述 平方分割又叫做分桶法或者分块法，把排成一排的 $N$ 个元素每 $\\sqrt N $ 分在一个块（桶）里，这样的分割方法可以把对区间的操作的复杂度降至 $O(\\sqrt N)$。 对序列平方分割 一般的做法是预设一个整数$S$（$S=\\lceil \\sqrt {N} \\rceil$），将序列分成$B（B=\\lceil \\frac{N}{S} \\rceil）$块，每块$S$个元素。对于一个区间的操作分为块内操作和块间操作，块内的暴力求解，块间的高效求解（排序后二分，lazy标记，预处理，数据结构维护等）。 //定义块号和块边界 for (int i=0; i&lt;n; ++i) { belong[i] = i / S; L[i] = belong[i]*S; R[i] = min(n, L[i]+S) } //区间询问或区间修改 for (int i=l; i&lt;=r; ) { if (i == L[i] &amp;&amp; R[i] &lt; r) { //need efficient algorithm i = R[i]; } else { //just use brute force i++; } } 题目POJ 2104 K-th Number题意有$n$个数字，$m$次询问，询问$[l,r]$区间里第$k$大的数字。 题解这题是主席树的经典题目，在本文中尝试用分块的方法求解。对元素的位置分块，每块分别排好序，二分第$k$大的数字$v$，对于一个区间$[l,r]$查询小于$v$的个数分为块内查询和块间查询，块内元素一个一个判断是否小于$v$；块间用二分查找来统计小于$v$的个数。二分复杂度：$O(logN)$，单次查询复杂度：$O(S+BlogS)$总时间复杂度：$O(M(logN(S+BlogS)))$code UVA 12003 Array Transformer题意有一个数组$A[1,…,n]$和$m$条指令和一个数字$u$，每条指令形如$(l,r,v,p)$，统计出$A[l],A[l+1],…,A[r]$中严格小于$v$的元素的个数为$k$，然后把$A[p]$改为$\\frac {u*k}{r-l+1}$。问变换后的最终数组。 题解对元素的位置分块，每块分别排序。询问的操作同POJ 2104，修改的操作则在$p$所在的块里进行，因为修改后块内元素基本有序，所以用 插入排序 的方法使得被修改的元素移动到正确的位置。单次修改的复杂度：$O(logS+S)$，单次查询的复杂度：$O(S+BlogS)$总时间复杂度：$O(M(S+BlogS))$类题：SPOJ RACETIME Race Against Timecode 拓展若本题修改不是单点修改，而是区间修改，那么也没有必要重新全部排序： 本来数组是有序的，现在把其中一部分加上了一个数，那么可以将原数组分为修改后的和没修改的两部分，每部分都是一个有序数组，可以在 $O(S )$ 的时间内 归并排序。 ——《非常规大小分块算法初探》 徐明宽 BZOJ 2957 楼房重建题意一个人在坐标(0,0)看楼房，楼房定义为$(x_i,y_i)$表示位置在$x_i$，高度为$y_i$。如果这栋楼房上任何一个高度大于0的点与(0,0)的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。起初所有楼房的高度都为0，有M次操作，每次修改某个楼房的高度，问每次操作结束后能从(0,0)看到多少栋楼房。 题解如果一栋楼房可见，那么最高点$(x_i,y_i)$和(0,0)在x轴上的斜率一定大于前面所有的楼房，也就是要求斜率单调递增的序列的长度。对楼房的位置分块，每个块维护斜率递增的序列。修改操作直接在某个块上重新计算斜率递增的序列（可以使用插入排序算法），查询操作在每个块里二分查找大于前一个块里的最大斜率的斜率，并更新当前最大斜率。单次修改复杂度：$O(S)$，单次查询复杂度：$O(BlogS)$总时间复杂度：$O(M(BlogS+S))$code HDOJ 4366 Successor题意有$n$个人，编号为0的是老板，编号1到$n-1$是员工，每个员工只有一个上司，除老板为每个人有他的忠诚值和能力值。每次要解雇一个人的时候，从他的下属中选取能力值大于他的且忠诚值最高的一个，若不存在则输出-1。共$m$次询问，每次询问解雇编号为i的员工会选择哪个编号的员工顶替他。（所有询问都不相互影响） 题解显然是一棵树，用DFS序得到编号的序列，每个点能知道子树在序列上对应的区间。对序列分块，每块的元素按照能力值排序，简单的dp求得能力值更大的后缀里忠诚值的最大值。块内查询逐个遍历，块间查询二分查找大于解雇员工的能力值的位置，从而得到最大的忠诚值，又因为忠诚值互不相同，所以能用map对应到员工的编号。单次查询复杂度：$O(BlogS)$总时间复杂度：$O(M(BlogS))$code BZOJ 2002 Bounce 弹飞绵羊题意有$n$个弹力装置，每个装置有一个弹力系数$k_i$，如果绵羊到达第$i$个装置，它会被弹到第$i+k_i$个装置。有$m$个操作，修改某个装置的弹力系数，或者询问从某个装置出发弹几次后会被弹飞。 题解对装置的位置分块，预处理出每个块维护从块里每个位置出发要弹几次后弹出该块，以及弹出后到达的位置。修改操作直接在某个块上重新计算要维护的信息，查询操作利用每个块的信息可以$O(1)$跳出该块，累计次数和即可。单次修改复杂度：$O(S)$，单次查询复杂度：$O(B)$总时间复杂度：$O(M(S+B))$code 拓展本题的加强版：CodeForces 13E Holes增加单点修改的操作以及询问最后被弹飞的位置。做法类似，预处理中增加从块里每个位置出发最后弹出该块的位置code CodeForces 551E GukiZ and GukiZiana题意有$n$个数字，$m$次操作：1. $[l,r]$区间里的所有数字都增加$x$；2. 询问$[1,n]$里的最远点对$(i,j)$满足$a_i=a_j=y$。 题解类似线段树的区间修改，对每一个块添加lazy标记表示该块统一增加的总和。每块分别把$pair(a[i],i)$排好序，若块内元素被修改则重新排序，询问时只要对所有的块二分$(y-lazy[b])$求出最近左端点和最远右端点即可。单次修改复杂度：$O(SlogS+B)$，单次查询复杂度：$O(BlogS)$总时间复杂度：$O(M(SlogS+BlogS))$code CodeForces 444C DZY Loves Colors题意有$n$个数字，第$i$个数字$a[i]=i$，有$m$次操作：1. 修改$[l,r]$区间的数字为$x$，设原来的值为$y$，那么该位置改变量累加$|x-y|$；2. 询问$[l,r]$区间的改变量的总和。 题解对每一个块设置lazy标记表示该块的相同的值（如果不相同则标记为0），$sum[i]$表示第i个数字非lazy修改（即直接单点修改）的改变量和，$sum_{lazy}[b]$表示第$b$块里每一个数字经lazy修改的改变量和，$sum_{block}[b]$表示第b块经lazy修改的所有数字的改变量总和。每次区间修改最多出现两个没有lazy标记的块，所以需要暴力单点更新的块不会很多。块内询问每个数字的贡献值总和：$\\sum (sum[i]+sum_{lazy}[b])$；块间询问每个块的贡献值总和：$\\sum sum_{block}[b]$。单次修改复杂度：$O(S+B)$，单次查询复杂度：$O(S+B)$总时间复杂度：$O(M(S+B))$code CodeChef QCHEF Chef and Problems题意有$N$个数字，第$i$个数字$A[i] \\leq M$，$K$次询问：问在$[L,R]$中相同数字的位置的最大间隔。 题解由于没有修改操作，可以预处理一些信息来辅助求解。对序列分块之后进行预处理：块间预处理：$ans[i][j]$表示第$i$块到第$j$块区间里的最大间隔，通过$pre$数组记录每个数字最早出现的位置实现。然后就可以$O(1)$得到块间最大值。块内预处理：$pos_0[b][v]$表示第$b$块里$v$最后出现的位置，然后转为前$b$块的最后出现的位置；同理可得$pos_1[b][v]$表示第$b$块之后$v$最早出现的位置。然后暴力求解即可，求解方法和块间预处理相同。块间预处理复杂度：$O(BN)$，块内预处理复杂度：$O(N+BM)$总时间复杂度：$O(BN+BM+KS)$code类题：SPOJ ZQUERY Zero Query（提示：求前缀和） LYOI 147 「分块」区间众数题意给一个长度为 $n$ 的序列，$m$ 次询问，每次查询一个区间 $[l,r]$ 内的众数（如果有多个众数，取最小的一个），强制在线。 题解同样没有修改操作，类似上题预处理一些信息。对序列离散化，分块之后进行预处理：块间预处理：$ans[i][j]$表示第$i$块到第$j$块区间的众数，通过$cnt$数组记录每个数字出现次数实现。然后就可以$O(1)$得到块间最大值。块内预处理：$sum[b][v]$表示第$b$块里$v$出现的次数，然后转为前$b$块的出现的次数。然后暴力求解即可，求解方法和块间预处理相同。块间预处理复杂度：$O(BN)$，块内预处理复杂度：$O(N+BN)$总时间复杂度：$O(BN+S)$code 拓展带修改操作：区间众数解题报告 - 陈立杰 CodeForces 455D Serega and Fun题意有 $n$ 个数字，$q$ 次操作，1. 序列循环向右移动一位；2. 询问 $[l,r]$ 里 $k$ 的个数。强制在线。 题解使用块状链表解决：用deque或者list存储每块的元素，移位操作在每块 $O(1)$ 地插入或删除。预处理出每块中每个元素的个数，移位时也可以 $O(1)$ 修改。总时间复杂度：$O(Q(B+S))$code HDU 4391 Paint The Wall题意有 $n$ 个数字，$q$ 次操作，1. 将 $[l,r]$ 里的所有元素涂成颜色 $z$；2. 询问 $[l,r]$ 里 颜色 $z$ 的个数。 题解颜色范围很大，如果使用朴素的线段树空间上无法承受。线段树套分块哈希：考虑线段树维护的不是单个元素，而是整块元素，每块用 map 维护每种颜色的数量，再加上懒惰标记后可以通过此题。总时间复杂度：$O(Q(B+SlogS)$code 对集合平方分割 通常在图中使用，具体做法是预设一个整数$S$（$S=\\lceil \\sqrt {E} \\rceil$），将度数超过 $S$ 的点记为重点，其余的点记为轻点。重新建图：重点只与相邻的重点连边，重点与相邻的轻点的边的信息使用预处理或者数据结构等手段高效维护，使得对点的遍历和边的修改的复杂度降至 $O(\\sqrt E)$。 题目HDU 4858 项目管理题意有 $n$ 个点，$m$ 条边的无向无环图，两个节点可能有多条边，每条点有权值，有 $q$ 次操作，1. 节点 $u$ 的权值加上 $v$；2. 问节点 $u$ 相邻点的权值和。 题解根据重点和轻点的定义，将原图重新建图，若 $u$ 是重点，$sum[u]$ 保存与 $u$ 相邻的 重点 的权值和。修改 重点 的话更新该点和与该点相邻的 重点 的$sum$（单次修改复杂度：$O(S)$；单次查询复杂度：$O(1)$），否则在原图遍历所有相邻点的 $sum$（单次修改复杂度：$O(S)$；单次查询复杂度：$O(S)$）。总时间复杂度：$O(QS)$code HDU 4467 Graph题意有 $n$ 个点，$m$ 条边的无向无环图，每条边有权值 $w$，每个点有颜色 $(0/1)$，有 $q$ 次操作，1. 第 $x$ 个点的颜色反转；2. 问端点的颜色是 $(A,B)$ 的边的权值和。（$A(B)=0/1$） 题解根据重点和轻点的定义，将原图重新建图，预处理若干信息，若 $u$ 是 重点，$sum[u][0/1]$ 保存与 $u$ 相邻的 重点（轻）点 的边权和，$ans[k]$(k=0: 0-0; k=1: 0-1; k=2: 1-1) 保存统一类型的边权总和，修改只要交换信息即可，查询能 $O(1)$ 得到答案。code ZOJ 3749 Chameleon题意有 $n$ 个集合，第 $i$ 个集合有 $m_i$ 个数字，所有数字都不相同，$q$ 次操作，每次选取第 $i$ 个集合和第 $j$ 个集合，按照数字大小归并排序，问排序后相邻数字之间所属集合不同的个数。 题解按照朴素的方法，复杂度是 $O(QN)$。按照集合的大小以 $S=\\sqrt N$ 分类，两个集合都小于 $S$ 的询问按照朴素的方法解决，复杂度为 $O(QS)$；如果大于$S$，考虑离线询问，对于一个大于 $S$ 的集合，$O(N)$ 处理出其他所有集合和它的答案，那么复杂度为 $O(NS)$。总时间复杂度：$O((N+Q)S)$code CodeForces 348C Subset Sums 对集合CodeForces 576C Points on Plane 对集合CodeForces 398D Instant Messanger 对集合 对询问平方分割 莫队算法用到了分块的思想，一般是给$Q$个区间$[l,r]$来进行的一些操作和询问。将序列分成$\\sqrt N $块，每块的大小为$\\sqrt N $。离线处理$Q$个区间：首先对左端点$l$所在的块号从小到大排序，如果块号相同则按右端点$r$从小到大排序。然后用双指针移动到当前区间位置，每次移动更新对结果的贡献。 for (int i=1; i&lt;=Q; ++i) { while (L &lt; q[i].l) sub(L++); //删除 while (L > q[i].l) add(--L); //增加 while (R &lt; q[i].r) add(++R); while (R > q[i].r) sub(R--); ans[q[i].id] = sum; //答案 } CF 86D Powerful array CodeForces 351D Jeff and Removing Periods 莫队HDU 4638 Group 莫队CodeForces 103D Time to Raid Cowavans 莫队CodeForces 375D Tree and Queries 莫队CodeForces 617E XOR and Favorite Number 莫队SPOJ DQUERY D-query 莫队CodeChef GERALD07 Chef and Graph Queries 莫队，并查集，LCTCodeChef IITI15 Sherlock and Inversions 莫队，区间逆序对 分块大法好！","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"},{"name":"平方分割","slug":"平方分割","permalink":"https://sea96.github.io/tags/平方分割/"}]},{"title":"AtCoder Regular Contest 070","slug":"AtCoder-Regular-Contest-070","date":"2017-03-20T00:16:43.000Z","updated":"2017-05-13T05:22:26.335Z","comments":true,"path":"2017/03/20/AtCoder-Regular-Contest-070/","link":"","permalink":"https://sea96.github.io/2017/03/20/AtCoder-Regular-Contest-070/","excerpt":"C. Go Home题意从0的位置出发，第$i$秒能往前或往后跳$i$步，也可以选择不跳，问跳到$X$位置的最短时间。","text":"C. Go Home题意从0的位置出发，第$i$秒能往前或往后跳$i$步，也可以选择不跳，问跳到$X$位置的最短时间。 数据$1≤X≤10^9$ 题解答案就是满足$\\sum_{i=1}^{n}i \\geq X$的最小的$n$。如果恰好相等那一定最优；如果大于的话，一定可以找到$k$（k&lt;n），使得$(\\sum_{i=1}^{n}i)-k = X$，那么第$k$秒不跳就可以了。 D. No Need题意有$N$个数字，第$i$个数字的值是$a_i$。定义$N$个数字的子集满足子集内的数字和不小于$K$，如果某一个子集里去掉一个数字后依然满足条件，那么去掉的数字是unnecessary。问unnecessary的数字的个数。 数据$1 \\leq N \\leq 5000 $$1 \\leq K \\leq 5000 $$1 \\leq a_i \\leq 10^9 (1≤i≤N)$ 题解如果$a_i$是necessary，那么在其它$N-1$个数字的子集里存在和的区间在$[K-a_i,K)$范围内。那么可以用$O(N^3)$的DP来做。优化： 注意到如果$a_p &lt; a_q$并且$a_q$是unnecessary，那么$a_p$也一定是unnecessary。二分边界可以将复杂度降到$O(N^2logN)$；如果用bitset判断和是否存在的话，复杂度为$O(\\frac{N^2logN}{32})$ 从最大值往最小值遍历，维护一个最大前缀子集和S，S的区间在$[K-a_i,K)$内，如果$S+a_i \\geq K$，那么$a_i$是necessary，否则是unnecessary，并且$S+=a_i$。时间复杂度：$O(N)$ code1code2","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://sea96.github.io/tags/位运算/"},{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"},{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"}]},{"title":"Gym 100676H Capital City","slug":"Gym-100676H-Capital-City","date":"2017-03-16T01:08:02.000Z","updated":"2017-05-13T01:14:22.482Z","comments":true,"path":"2017/03/16/Gym-100676H-Capital-City/","link":"","permalink":"https://sea96.github.io/2017/03/16/Gym-100676H-Capital-City/","excerpt":"题意有$n$个点$m$条边的无向图，每条边上有权值$w$，问一个点的序号，满足从这个点出发到其他点的最大距离最小（在环上走的距离为0），如果有多个，取序号最小的点。","text":"题意有$n$个点$m$条边的无向图，每条边上有权值$w$，问一个点的序号，满足从这个点出发到其他点的最大距离最小（在环上走的距离为0），如果有多个，取序号最小的点。 数据$1 \\leq n \\leq 10^5$$ 0 \\leq m \\leq 2*10^5$$ 1 \\leq w \\leq 10^5$ 题解对无向图求边-双联通分量进行缩环，问题转换为树上找一个点使得到其他点的最大距离最小。可以用dp，两次DFS得到每一个点到其他点的最大距离。但是只需要找一个点，那么这个点一定在树的直径上，处理出每一个点到直径的两个端点的距离即可，时间复杂度：$O(n+m)$ 代码#include &lt;bits/stdc++.h> using namespace std; typedef long long ll; const int N = 1e5 + 5; const int M = 2e5 + 5; struct Edge { int v, w, nex, cut; }edges[M&lt;&lt;2]; int head[N], head2[N]; vector&lt;int> bcc[N]; int dfn[N], bcc_no[N]; int sta[N], top; int id[N]; int dfs_clock, bcc_cnt; int n, m, etot; void init_edge() { memset(head, -1, sizeof(head)); memset(head2, -1, sizeof(head2)); etot = 0; } inline void add_edge(int u, int v, int w, int *head) { edges[etot] = Edge{v, w, head[u], 0}; head[u] = etot++; } int Tarjan(int u, int fa) { int lowu = dfn[u] = ++dfs_clock; sta[top++] = u; for (int i=head[u]; ~i; i=edges[i].nex) { int v = edges[i].v; if (!dfn[v]) { int lowv = Tarjan(v, u); lowu = min(lowu, lowv); } else if (dfn[v] &lt; dfn[u] &amp;&amp; v != fa) { lowu = min(lowu, dfn[v]); } } //桥 if (lowu == dfn[u]) { bcc[++bcc_cnt].clear(); int v; do { v = sta[--top]; bcc[bcc_cnt].push_back(v); bcc_no[v] = bcc_cnt; } while (v != u); } return lowu; } void find_bcc() { memset(dfn, 0, sizeof(dfn)); memset(bcc_no, 0, sizeof(bcc_no)); dfs_clock = top = bcc_cnt = 0; Tarjan(1, -1); } ll d[N], d1[N], d2[N]; void DFS(int u, int fa, ll *dis) { for (int i=head2[u]; ~i; i=edges[i].nex) { int v = edges[i].v, w = edges[i].w; if (v == fa) continue; dis[v] = dis[u] + w; DFS(v, u, dis); } } void solve() { find_bcc(); if (bcc_cnt == 1) { puts(\"1 0\"); return ; } for (int i=1; i&lt;=bcc_cnt; ++i) { id[i] = (int)(1e9); for (int x: bcc[i]) { id[i] = min(id[i], x); for (int j=head[x]; ~j; j=edges[j].nex) { int y = edges[j].v, z = edges[j].w; if (bcc_no[y] == i) continue; add_edge(i, bcc_no[y], z, head2); } } } int x = bcc_no[1]; d[x] = 0; DFS(x, 0, d); x = -1; for (int i=1; i&lt;=n; ++i) { int v = bcc_no[i]; if (x == -1 || d[x] &lt; d[v]) x = v; } d1[x] = 0; DFS(x, 0, d1); int y = -1; for (int i=1; i&lt;=n; ++i) { int v = bcc_no[i]; if (y == -1 || d1[y] &lt; d1[v]) y = v; } d2[y] = 0; DFS(y, 0, d2); int ans = -1; ll len = (ll)(1e18); for (int i=1; i&lt;=n; ++i) { int v = bcc_no[i]; ll md = max(d1[v], d2[v]); if (ans == -1 || len > md) { ans = id[v]; len = md; } else if (md == len &amp;&amp; ans > id[v]) ans = id[v]; } printf(\"%d %I64d\\n\", ans, len); } int main() { int T; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;n, &amp;m); init_edge(); for (int i=1; i&lt;=m; ++i) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); add_edge(u, v, w, head); add_edge(v, u, w, head); } solve(); } return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://sea96.github.io/tags/DFS/"},{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"},{"name":"树的直径","slug":"树的直径","permalink":"https://sea96.github.io/tags/树的直径/"}]},{"title":"Gym 100676G Training Camp","slug":"Gym-100676G-Training-Camp","date":"2017-03-16T00:30:03.000Z","updated":"2017-05-13T05:23:04.626Z","comments":true,"path":"2017/03/16/Gym-100676G-Training-Camp/","link":"","permalink":"https://sea96.github.io/2017/03/16/Gym-100676G-Training-Camp/","excerpt":"题意一个人要读$n$个topic，每天一个topic。在第$k$天读第$x$个topic得到的level是$k*w[x]$，现在有$m$个约束，即读topic的顺序，问得到的最大的level是多少。","text":"题意一个人要读$n$个topic，每天一个topic。在第$k$天读第$x$个topic得到的level是$k*w[x]$，现在有$m$个约束，即读topic的顺序，问得到的最大的level是多少。 数据$1 \\leq n \\leq 18$$ 1 \\leq w \\leq 100$ 题解很容易想到是拓扑排序，如果使用贪心策略每次取出$w$最小的，用优先队列实现，但是这个是错误的，因为只保证了当前的最优解，没有保证全局最优解。所以考虑dp的方法，注意到$n$的数据范围很小，自然想到用状态压缩dp，状态转移的条件和拓扑排序一样，入度为0的时候才能转移。 代码#include &lt;bits/stdc++.h> using namespace std; typedef long long ll; const int N = 20; map&lt;string, int> ID; struct Edge { int u, v; }; vector&lt;Edge> edges; int dp[(1&lt;&lt;18)+5]; bool vis[N]; int w[N]; int deg[N]; int n, m; int solve() { memset(dp, 0, sizeof(dp)); for (int mask=0; mask&lt;(1&lt;&lt;n); ++mask) { memset(vis, false, sizeof(vis)); for (int i=0; i&lt;n; ++i) if (mask &amp; (1&lt;&lt;i)) vis[i] = true; int day = __builtin_popcount(mask); bool flag = true; memset(deg, 0, sizeof(deg)); for (auto e: edges) { if (!vis[e.u] &amp;&amp; vis[e.v]) { flag = false; break; } if (!vis[e.u]) deg[e.v]++; } if (!flag) continue; for (int i=0; i&lt;n; ++i) { if (!vis[i] &amp;&amp; !deg[i]) { dp[mask|(1&lt;&lt;i)] = max(dp[mask|(1&lt;&lt;i)], dp[mask]+(day+1)*w[i]); } } } return dp[(1&lt;&lt;n)-1]; } int main() { int T; cin >> T; while (T--) { cin >> n >> m; edges.clear(); ID.clear(); string topic, topic2, tmp; getline(cin, tmp); for (int i=0; i&lt;n; ++i) { w[i] = 0; topic = \"\"; getline(cin, tmp); for (int j=0; j&lt;tmp.length(); ++j) { if (tmp[j] >= '0' &amp;&amp; tmp[j] &lt;= '9') { w[i] = w[i]*10 + (tmp[j]-'0'); } else topic += tmp[j]; } ID[topic] = i; } edges.clear(); for (int i=1; i&lt;=m; ++i) { getline(cin, tmp); topic = topic2 = \"\"; bool fir = true; for (int j=0; j&lt;tmp.length(); ++j) { if (tmp[j] == '-') { j += 3; fir = false; } else { if (fir) topic += tmp[j]; else topic2 += tmp[j]; } } topic2 += ' '; edges.push_back(Edge{ID[topic], ID[topic2]}); } cout &lt;&lt; solve() &lt;&lt; '\\n'; } return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://sea96.github.io/tags/位运算/"},{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"}]},{"title":" AtCoder Grand Contest 011","slug":"AtCoder-Grand-Contest-011","date":"2017-03-15T03:20:18.000Z","updated":"2017-05-13T01:33:38.971Z","comments":true,"path":"2017/03/15/AtCoder-Grand-Contest-011/","link":"","permalink":"https://sea96.github.io/2017/03/15/AtCoder-Grand-Contest-011/","excerpt":"A. Airport Bus题意有$n$个人在等车，第$i$个人的等车时间为$[t_i,t_i+k]$，每辆车最多能载$c$个人。问所有人都上车最少需要多少辆车。","text":"A. Airport Bus题意有$n$个人在等车，第$i$个人的等车时间为$[t_i,t_i+k]$，每辆车最多能载$c$个人。问所有人都上车最少需要多少辆车。 数据$2≤n≤10^5$$1≤c≤10^9$$1≤k≤10^9$$1≤ti≤10^9$ 题解贪心的策略：凑齐$c$个人或者有人等不了就上车。显然上车时间在$t_i$或者$t_i+k$端点上更优。对$t_i$从小到大排序，双指针扫描一遍即可，时间复杂度：$O(nlogn)$code B. Colorful Creatures题意有$n$个生物，每个生物的大小为$a_i$。一个生物$i$能吸收另一个生物$j$的条件是：$2a_i\\geq a_j$，吸收后生物$i$的大小变成$a_i+a_j$，问有多少个生物可以吸收其他所有生物。 数据$2≤n≤10^5$$1≤a_i≤10^9$ 题解对$a_i$从小到大排序，那么也就是要找到最小的$j$，满足第$j$个生物可以吸收其他所有生物（吸收的顺序从小到大最优），符合二分的性质，所以答案就是$n-j+1$，时间复杂度：$O(nlogn)$更好的做法是求最大的$k$满足$2\\sum_{k=1}^{i} a_k &lt; a_{k+1}$，也就是求满足条件的最大的后缀长度，可以在$O(n)$时间复杂度解决。code C. Squared GraphD. Half ReflectorE. Increasing Numbers","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"},{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"},{"name":"组合数学","slug":"组合数学","permalink":"https://sea96.github.io/tags/组合数学/"},{"name":"数学","slug":"数学","permalink":"https://sea96.github.io/tags/数学/"}]},{"title":"2015-2016 ACM ICPC Baltic Selection Contest","slug":"2015-2016-ACM-ICPC-Baltic-Selection-Contest","date":"2017-03-11T01:47:32.000Z","updated":"2017-05-13T05:22:01.854Z","comments":true,"path":"2017/03/11/2015-2016-ACM-ICPC-Baltic-Selection-Contest/","link":"","permalink":"https://sea96.github.io/2017/03/11/2015-2016-ACM-ICPC-Baltic-Selection-Contest/","excerpt":"A. AHB求数位上相减的绝对值，注意0的特殊情况。","text":"A. AHB求数位上相减的绝对值，注意0的特殊情况。 B. Wet Boxes暂时不会，Wannafly Union Goodbye 2016 F C. Minimax Tree题意有$n$个点的一颗树，叶子结点上有权值$a_i$，在非叶子结点上贴取最大或最小标签，最大标签有$k$个，问根节点能获得的最大值和最小值。 数据$2 \\leq n \\leq 10^5$$0 \\leq a_i \\leq 10^9$$k+l \\leq n$ 题解简单的思路是：二分答案，dp求得获得该值最少需要多少个最值标签，判断是否小于给定的数量。另一种贪心思路是：如果某个最大值要传到根节点，那么到根节点的路径上，有分叉处只能贴上max标签，那么其余的地方贴上min标签。 代码dp+binary search #include &lt;bits/stdc++.h> using namespace std; const int N = 1e5 + 5; const int INF = 0x3f3f3f3f; vector&lt;int> edge[N]; int a[N]; int n, k, l; int ans1, ans2; int DFS(int u, int fa, int m, int tp) { if (a[u]) { if (tp) return a[u] >= m ? 0 : INF; else return a[u] &lt;= m ? 0 : INF; } int need = 0, son = 0, tot = 0, mn = INF; for (int v: edge[u]) if (v != fa) { int res = DFS(v, u, m, tp); if (res) need++; son++; mn = min(mn, res); } if (mn == INF) return INF; if (!need) return 0; if (son == 1) return mn; else return mn+1; } bool check(int m, int tp) { return DFS(1, 0, m, tp) &lt;= k; } int main() { scanf(\"%d%d\", &amp;n, &amp;k); for (int i=2; i&lt;=n; ++i) { int p; scanf(\"%d\", &amp;p); edge[p].push_back(i); } l = 0; for (int i=1; i&lt;=n; ++i) { scanf(\"%d\", &amp;a[i]); if (a[i]) l++; } int low = -1, high = (int)(1e9+5); while (low &lt; high) { int mid = low + high >> 1; if (check(mid, 0)) { ans1 = mid; high = mid; } else low = mid+1; } k = n - k - l; low = -1, high = (int)(1e9+5); while (low &lt; high) { int mid = low + high >> 1; if (check(mid, 1)) { ans2 = mid; low = mid+1; } else high = mid; } printf(\"%d %d\\n\", ans1, ans2); return 0; } greedy #include &lt;bits/stdc++.h> using namespace std; const int N = 1e5 + 5; const int INF = 0x3f3f3f3f; vector&lt;int> edge[N]; int n, k, l; int mx[N], mn[N], son[N]; int ans1, ans2; void DFS(int u, int fa, int dep) { // if (edge[u].size() == 1) return ; for (int v: edge[u]) if (v != fa) { if (son[u] == 1) DFS(v, u, dep); else DFS(v, u, dep+1); mx[u] = max(mx[u], mx[v]); mn[u] = min(mn[u], mn[v]); } if (dep-1 &lt;= k) ans1 = min(ans1, mx[u]); if (dep-1 &lt;= n-k-l) ans2 = max(ans2, mn[u]); } int main() { scanf(\"%d%d\", &amp;n, &amp;k); for (int i=2; i&lt;=n; ++i) { int p; scanf(\"%d\", &amp;p); edge[p].push_back(i); son[p]++; } memset(mn, INF, sizeof(mn)); l = 0; for (int i=1; i&lt;=n; ++i) { int x; scanf(\"%d\", &amp;x); if (x) { mx[i] = mn[i] = x; l++; } } ans1 = INF; ans2 = 0; DFS(1, 0, 1); printf(\"%d %d\\n\", ans1, ans2); return 0; } D. Journey简单BFS即可。 E. Permutation Polygon题意有$n$个点的正多边形，每一个顶点i都和另一个顶点$p_i$有线段相连，$p_1，p_2…p_n$是$n$的一个排列。问线段相交点的数量（重叠的算多个）。 数据$3\\leq n \\leq 10^5$$i \\neq p_i$ 题解定义一条线段为：$(x,y)$，并且$x&lt;y$。线段相交的条件是：若$x_1&lt;x_2$，则$y_1&lt;y2$按照线段的$x$从小到大排序，对于当前的线段(x,y)，只要统计y’的数量，满足条件：$x&lt;y’&lt;y$，就能知道有多少个相交点，可以用树状数组维护。 代码#include &lt;bits/stdc++.h> using namespace std; typedef pair&lt;int, int> pii; const int N = 1e5 + 5; int C[N]; vector&lt;pii> vec; int n; void modify(int i) { for (; i&lt;=n; i+=i&amp;-i) C[i] += 1; } int query(int i) { int ret = 0; for (; i; i-=i&amp;-i) ret += C[i]; return ret; } int sum(int l, int r) { return query(r) - query(l-1); } int main() { scanf(\"%d\", &amp;n); for (int i=1; i&lt;=n; ++i) { int p, q = i; scanf(\"%d\", &amp;p); if (p > q) swap(p, q); if (q - p &lt;= 1 || (p==1 &amp;&amp; q==n)) continue; vec.push_back(pii(p, q)); } sort(vec.begin(), vec.end()); // vec.erase(unique(vec.begin(), vec.end()), vec.end()); int m = vec.size(); int ans = 0; for (int i=0; i&lt;m; ++i) { ans += sum(vec[i].first+1, vec[i].second-1); vector&lt;int> tmp; tmp.push_back(vec[i].second); ++i; while (i &lt; m &amp;&amp; vec[i].first == vec[i-1].first) { ans += sum(vec[i].first+1, vec[i].second-1); tmp.push_back(vec[i].second); i++; } for (auto p: tmp) modify(p); i--; } printf(\"%d\\n\", ans); return 0; } F. Unusual Sum定义$s(n)=\\sum \\limits_{k=1}^{n}\\frac{1}{k^2+k}=\\frac{n-1}{n}$$\\sum \\limits_{k=l_i}^{r_i}\\frac{1}{k^2+k}=s(r_i)-s(l_i-1)$ G. Robot Walk简单模拟 H. Game of Corners$ans=n*m+min(n,m)$智商题？ I. Shell Game问杯子里放球的最大半径。二分答案或者推公式。 J. Narrow Bus题意模拟公交车的乘客上下车过程，$n$个操作： “F”：一个乘客从前门上车 ”B“：一个乘客从后门上车 ”O i”：第i个乘客从人数少的门下车，被挤出去的乘客顺序不改变地从另一个重新上车。 数据$1\\leq n \\leq 10^5$ 题解用Splay的序列分裂和合并模拟这个过程。 代码#include &lt;bits/stdc++.h> using namespace std; const int N = 1e5 + 5; struct Node { Node *ch[2], *fa; //儿子，父亲 int s; Node() { s = 0; } //给null初始化 int d() { return fa->ch[1]==this; //判断自己是哪个儿子 } void setc(Node* c, int d) { ch[d] = c; c->fa = this; //指定儿子 } void up() { s = ch[0]->s + ch[1]->s + 1; //向上更新 } }Tnull, *null = &amp;Tnull; Node pool[N], *node = pool; Node* new_node() { Node *o = node++; o->ch[0] = o->ch[1] = o->fa = null; o->s = 1; return o; } //将节点o向上旋转 void rotate(Node* o) { Node* p = o->fa; int d = o->d(); p->fa->setc(o, p->d()); p->setc(o->ch[d^1], d); o->setc(p, d^1); p->up(); } //将节点o伸展到p的儿子的位置 void splay(Node* o, Node *p = null) { while (o->fa != p) { if (o->fa->fa == p) rotate(o); else { //三点共线：先旋转父亲，再旋转o；不共线：o旋转两次 if (o->d() == o->fa->d()) rotate(o->fa), rotate(o); else rotate(o), rotate(o); } } o->up(); } //找到以o为根的树上第k小 Node* kth(Node* o, int k) { while (1) { int c = 1 + o->ch[0]->s; if (k == c) return o; if (k > c) { k -= c; o = o->ch[1]; } else o = o->ch[0]; } return null; } //将前k小放到左子树，其它的放到右子树 void split(Node* o, int k, Node* &amp;left, Node* &amp;right) { if (k == 0) { left = null; right = o; } else if (k == o->s) { left = o; right = null; } else { //先找到分裂节点，伸展到根再分裂 right = kth(o, k+1); splay(right); left = right->ch[0]; right->ch[0] = right->fa = null; right->up(); } } void merge(Node* &amp;o, Node* left, Node* right) { if (left == null) o = right; else if (right == null) o = left; else { o = kth(left, left->s); splay(o); o->setc(right, 1); o->up(); } } int n, m; Node* id[N]; int main() { scanf(\"%d\", &amp;m); Node* root = null; while (m--) { char str[10]; scanf(\"%s\", str); if (str[0] == 'O') { int x; scanf(\"%d\", &amp;x); splay(id[x]); id[x]->ch[0]->fa = id[x]->ch[1]->fa = null; int d = id[x]->ch[0]->s &lt;= id[x]->ch[1]->s ? 0 : 1; printf(\"%d\\n\", id[x]->ch[d]->s); merge(root, id[x]->ch[1], id[x]->ch[0]); } else { id[++n] = new_node(); if (str[0] == 'F') merge(root, id[n], root); else merge(root, root, id[n]); } } return 0; } K. Profact判断一个数是否为一个或若干个数的阶乘的乘积。注意到 $20！&gt; 10^{18} $，预处理出所有符合情况的答案，用set保存和查询即可。 L. Emoticons相邻两项判断即可。","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"},{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"伸展树","slug":"伸展树","permalink":"https://sea96.github.io/tags/伸展树/"}]},{"title":"HackRank Lena Sort","slug":"HackRank-Lena-Sort","date":"2017-03-04T00:58:03.000Z","updated":"2017-05-13T01:11:25.379Z","comments":true,"path":"2017/03/04/HackRank-Lena-Sort/","link":"","permalink":"https://sea96.github.io/2017/03/04/HackRank-Lena-Sort/","excerpt":"题意有一个排序算法伪码如下：","text":"题意有一个排序算法伪码如下： lena_sort(array nums) { if (nums.size &lt;= 1) { return nums; } pivot = nums[0]; array less; array more; for (i = 1; i &lt; nums.size; ++i) { // Comparison if (nums[i] &lt; pivot) { less.append(nums[i]); } else { more.append(nums[i]); } } sorted_less = lena_sort(less); sorted_more = lena_sort(more); ans = sorted_less + pivot + sorted_more; return ans; } 有$q$次询问，构造一组长度为$len$的序列，使其排序完成后恰好与pivot比较$c$次，无解输出 -1。 数据$1 \\leq q\\leq 10^5$$1 \\leq len \\leq 10^5$$1\\leq a_i \\leq 10^9$$0 \\leq c \\leq 10^9$ 题解官方题解官方题解说得很详细了，把每个数字看成一个节点，节点的左儿子比它小，右儿子比它大，变成一棵二叉树，那么比较次数总和为所有节点在树的深度和。那么次数总和的上界情况是树退化成一条链（序列是单调序列），下界情况是完全二叉树。预处理出所有长度对应比较次数的上下界，如果在范围内，总能构造出一棵比较次数为$c$的二叉树。 代码#include &lt;bits/stdc++.h> using namespace std; //#define DEBUG(x) cout &lt;&lt; #x &lt;&lt; \" = \" &lt;&lt; x &lt;&lt; endl typedef long long ll; const int N = 1e5 + 5; ll mn[N], mx[N]; int q, n; ll c; void solve(int st, int len, ll tot) { if (len &lt; 3) { for (int i=0; i&lt;len; ++i) { printf(\"%d \", st+i); } return ; } tot -= (len-1); for (int i=0; i&lt;len; ++i) { if (tot &lt; mn[i]+mn[len-1-i] || tot > mx[i]+mx[len-1-i]) continue; printf(\"%d \", st+i); ll tot_l = max(mn[i], tot-mx[len-1-i]); solve(st, i, tot_l); solve(st+i+1, len-1-i, tot-tot_l); return ; } } int main() { mn[2] = mx[2] = 1; for (int i=3; i&lt;=100000; ++i) { mx[i] = (ll)i*(i-1)/2; mn[i] = mn[i/2]+mn[(i-1)/2]+(i-1); } scanf(\"%d\", &amp;q); while (q--) { scanf(\"%d%lld\", &amp;n, &amp;c); if (c &lt; mn[n] || c > mx[n]) puts(\"-1\"); else { solve(1, n, c); puts(\"\"); } } return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://sea96.github.io/tags/组合数学/"},{"name":"二叉树","slug":"二叉树","permalink":"https://sea96.github.io/tags/二叉树/"}]},{"title":"Codeforces 468C Hack it!","slug":"Codeforces-468C-Hack-it","date":"2017-03-03T08:42:28.000Z","updated":"2017-05-13T01:30:28.380Z","comments":true,"path":"2017/03/03/Codeforces-468C-Hack-it/","link":"","permalink":"https://sea96.github.io/2017/03/03/Codeforces-468C-Hack-it/","excerpt":"题意定义$f(n)$表示$n$的数位和，求一组$[l,r]$$(1 \\leq l,r &lt; 10^{200})$，使得$\\sum\\limits_{i=l}^rf(i)\\equiv 0\\pmod a$$(1\\leq a\\leq 10^{18})$。","text":"题意定义$f(n)$表示$n$的数位和，求一组$[l,r]$$(1 \\leq l,r &lt; 10^{200})$，使得$\\sum\\limits_{i=l}^rf(i)\\equiv 0\\pmod a$$(1\\leq a\\leq 10^{18})$。 题解记$s(n)=\\sum\\limits_{i=1}^{n}f(i)$，计算$s(n)$只要把每一个数位对答案的贡献加起来即可。 构造：注意到$f(x+10^{18})=f(x)+1$，那么$s(x+10^{18})=s(10^{18})+s(x)+x$，即$s(x+10^{18})-s(x)=s(10^{18})+x$。令$s(10^{18})+x=a$，即$x=a-s(10^{18})$，构造出一组解：$L=x+1$，$R=x+10^{18}$。 二分方法： 我们只需找到$s(R)%a = s(L-1)%a$就美滋滋了。我们使用二分查询找到最小的且满足$g(R)&gt;=a$的值$R$，接下来令$L=1$，然后跑一个双指针,调整L,R的值即可。 时间复杂度：$O(?)$ 官方题解 代码#include &lt;bits/stdc++.h> using namespace std; typedef long long ll; ll a; int main() { scanf(\"%I64d\", &amp;a); //s(1e18) ll s = ((3*(3*(3*(3*(5*(2*((ll)1e17%a))%a)%a)%a)%a)%a)%a+1)%a; ll x = a - s; ll L = x + 1, R = x + (ll)(1e18); printf(\"%I64d %I64d\\n\", L, R); return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"数学","slug":"数学","permalink":"https://sea96.github.io/tags/数学/"},{"name":"构造","slug":"构造","permalink":"https://sea96.github.io/tags/构造/"}]},{"title":"Codeforces 493E Vasya and Polynomial","slug":"Codeforces-493E-Vasya-and-Polynomial","date":"2017-03-02T12:09:49.000Z","updated":"2017-05-13T01:29:15.351Z","comments":true,"path":"2017/03/02/Codeforces-493E-Vasya-and-Polynomial/","link":"","permalink":"https://sea96.github.io/2017/03/02/Codeforces-493E-Vasya-and-Polynomial/","excerpt":"题意有一个多项式$P(x) = a_0 + a_1x^1 + … + a_nx^n$，$a_i$为非负整数。给定$t$,$a$,$b$ $(0 &lt; t,a,b \\leq 10^{18})$，问存在多少多项式满足$P(t) = a$, $P(P(t)) = b$，对方案数 mod $10^9+7$，如果有无穷多个，那么输出inf。","text":"题意有一个多项式$P(x) = a_0 + a_1x^1 + … + a_nx^n$，$a_i$为非负整数。给定$t$,$a$,$b$ $(0 &lt; t,a,b \\leq 10^{18})$，问存在多少多项式满足$P(t) = a$, $P(P(t)) = b$，对方案数 mod $10^9+7$，如果有无穷多个，那么输出inf。 题解根据$P(t)=a$，并且$t&gt;0$，可知$\\sum_{i=0}^{n}a_i \\leq a$。 当$t&gt;1$时，所有系数$a_i&lt;a$，$P(P(t)) = P(a) = b$，相当于告诉了$b$在$a$进制的表示，且是唯一的，所以可以先求出所有系数$a_i$，然后验证$P(t)=a$是否成立即可。 当$t=1$时，如果存在$a_k=a$，那么$a_j=0$$(j \\neq k)$，那么$$P(t=1)=a_kt^k=a_k=a$$ $$P(a)=a_ka^k=a^{k+1}=b$$ 当且仅当$a=b=1$时对于任意$k$成立，否则只要验证$b$是$a$的正整数次幂即可。如果任意系数$a_{i} &lt; a$，问题在$t&gt;1$时已经解决。 特判$P(x)=a_0$的情况。代码```cpp#include using namespace std; typedef long long ll;ll t, a, b; //t &gt; 1 || another caseint solve() { ll p = 0, x = 1, r = b; int cnt = 0; for (; r; r/=a) { p += r % a x; x = t; cnt++; if (cnt &gt; 100) break; } return (p==a) + (cnt &gt; 1 &amp;&amp; a==b);} int main() { cin &gt;&gt; t &gt;&gt; a &gt;&gt; b; if (t == 1) { if (a == 1) { if (b == 1) cout &lt;&lt; “inf” &lt;&lt; ‘\\n’; else cout &lt;&lt; 0 &lt;&lt; ‘\\n’; } else { bool ok = false; ll p = 1; while (p &lt;= b/a) { p *= a; if (p == b) ok = true; } if (ok) cout &lt;&lt; 1 &lt;&lt; ‘\\n’; else cout &lt;&lt; solve() &lt;&lt; ‘\\n’; } } else cout &lt;&lt; solve() &lt;&lt; ‘\\n’; return 0;}```","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://sea96.github.io/tags/数学/"}]},{"title":"Kattis Boxes","slug":"Kattis-Boxes","date":"2017-03-02T03:02:25.000Z","updated":"2017-05-13T01:10:59.860Z","comments":true,"path":"2017/03/02/Kattis-Boxes/","link":"","permalink":"https://sea96.github.io/2017/03/02/Kattis-Boxes/","excerpt":"题意给出$n$$(n\\leq 2\\times 10^5)$个盒子，其中一些盒子可能会被放进另一些盒子里，$q$$(q \\leq 10^5)$次询问，每次询问给出$m$$(m\\leq 20)$个盒子序号，求这$m$个盒子包含的盒子总数。","text":"题意给出$n$$(n\\leq 2\\times 10^5)$个盒子，其中一些盒子可能会被放进另一些盒子里，$q$$(q \\leq 10^5)$次询问，每次询问给出$m$$(m\\leq 20)$个盒子序号，求这$m$个盒子包含的盒子总数。 题解盒子显然有树的结构（注意：可能不止一棵树），有两种做法： 求森林的DFS序，根据DFS序将子树映射到区间，那么问题就变成了区间染色点记数问题，用线段树（区间更新，lazy标记）解决。 另外一种比较zuo的做法是LCA搞。首先求出所有的树上节点对应的子树的大小sz，节点深度 dep，以及LCA的初始化fa。然后按照节点深度对 M个节点按照节点排序。然后，对于 M 个点，LCA去重，依次加上节点为根节点的子树的大小即可。 代码#include &lt;cstdio> #include &lt;vector> #include &lt;cstring> using namespace std; const int N = 2e5 + 5; vector&lt;int> edge[N]; int L[N], R[N]; bool root[N]; int box[25]; int n, m, q; int dfs_clock; //#define lc o &lt;&lt; 1 //#define rc o &lt;&lt; 1 | 1 int sum[N&lt;&lt;2], lazy[N&lt;&lt;2]; void push_down(int o, int l, int r) { if (lazy[o] != -1) { lazy[lc] = lazy[rc] = lazy[o]; int mid = (l + r) / 2; sum[lc] = (mid-l+1) * lazy[o]; sum[rc] = (r-mid) * lazy[o]; lazy[o] = -1; } } void build(int o, int l, int r) { lazy[o] = -1; if (l == r) return ; int mid = l + r >> 1; build(lc, l, mid); build(rc, mid+1, r); } void modify(int o, int l, int r, int ql, int qr, int col) { if (sum[o] == (r-l+1)*col) return ; if (ql &lt;= l &amp;&amp; r &lt;= qr) { sum[o] = (r-l+1)*col; lazy[o] = col; return ; } push_down(o, l, r); int mid = l + r >> 1; if (ql &lt;= mid) modify(lc, l, mid, ql, qr, col); if (qr > mid) modify(rc, mid+1, r, ql, qr, col); sum[o] = sum[lc] + sum[rc]; } void DFS(int u, int fa) { L[u] = ++dfs_clock; for (int v: edge[u]) if (v != fa) { DFS(v, u); } R[u] = dfs_clock; } int main() { scanf(\"%d\", &amp;n); memset(root, false, sizeof(root)); for (int i=1; i&lt;=n; ++i) { int fa; scanf(\"%d\", &amp;fa); if (fa == 0) { root[i] = true; continue; } edge[fa].push_back(i); } dfs_clock = 0; for (int i=1; i&lt;=n; ++i) { if (root[i]) DFS(i, 0); } build(1, 1, n); scanf(\"%d\", &amp;q); for (int i=1; i&lt;=q; ++i) { scanf(\"%d\", &amp;m); for (int j=1; j&lt;=m; ++j) { scanf(\"%d\", &amp;box[j]); modify(1, 1, n, L[box[j]], R[box[j]], 1); } printf(\"%d\\n\", sum[1]); for (int j=1; j&lt;=m; ++j) { modify(1, 1, n, L[box[j]], R[box[j]], 0); } } return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://sea96.github.io/tags/DFS/"},{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"}]},{"title":"Gym 101020K Clash Of Snakes","slug":"Gym-101020K-Clash-Of-Snakes","date":"2017-03-01T11:57:14.000Z","updated":"2017-05-13T01:12:18.937Z","comments":true,"path":"2017/03/01/Gym-101020K-Clash-Of-Snakes/","link":"","permalink":"https://sea96.github.io/2017/03/01/Gym-101020K-Clash-Of-Snakes/","excerpt":"题意有$n\\times m$$(2\\leq n,m \\leq 10^5)$的格子，有两条蛇长度分别为$k$和$s$$(2\\leq k,s \\leq min(n,m))$垂直或者水平地放置在格子里，要求两蛇不重叠，问放置的方案数（mod $10^9+7$）。","text":"题意有$n\\times m$$(2\\leq n,m \\leq 10^5)$的格子，有两条蛇长度分别为$k$和$s$$(2\\leq k,s \\leq min(n,m))$垂直或者水平地放置在格子里，要求两蛇不重叠，问放置的方案数（mod $10^9+7$）。 题解易得长度为$L$的方格放置长度为$k$的蛇的方案数为$L-k+1$。记长度$k$的蛇水平放置的方案数为$tot_k$，则$tot_k=(m-k+1)\\times n$。先考虑长度$k$的蛇水平放置在第$i$行，长度为$s$的蛇也水平放置的方案数$A$： $sum_1=tot_k\\times (n-1)\\times (m-s+1)$，长度为$s$的蛇不在第$i$行 $sum_2=(\\sum_{L=s}^{m-k}(L-s+1)+\\sum_{L=0}^{m-k-s}(m-L-k-s+1))\\times n$，长度为$s$的蛇在第$i$行 $$A=sum_1+sum_2$$ 再考虑长度$k$的蛇水平放置在$[j,j+k-1]$列，长度为$s$的蛇垂直放置的方案数$B$： $sum_3=tot_k\\times (m-k)\\times (n-s+1)$，长度为$s$的蛇不在$[j,j+k-1]$范围内 $sum_4=(\\sum_{L=s}^{n-1}(L-s+1)+\\sum_{L=0}^{n-1-s}(n-L-1-s+1))\\times k \\times (m-k+1)$，长度为$s$的蛇在$[j,j+k-1]$范围内 $$B=sum_3+sum_4$$那么要计算长度$k$的蛇垂直放置以及长度$s$的蛇两种的放置的方案数$A’$和$B’$，只要swap(n,m)后重复上面的计算即可。但是$sum_2$和$sum_4$的计算，用$O(n)$复杂度会TLE，要用求和公式来$O(1)$计算。最后头尾的组合有4种，所以最终答案：$$ans=4\\times (A+B+A’+B’)$$ 代码#include &lt;bits/stdc++.h> using namespace std; typedef long long ll; const int N = 1e5 + 5; const ll MOD = 1000000007; int n, m, k, s; int ans; inline void add_mod(int &amp;a, int b) { a += b; if (a >= MOD) a -= MOD; } int sum(int l, int r) { int x = l + r, y = r - l + 1; if (x % 2 == 0) x >>= 1; else y >>= 1; return (ll)x * y % MOD; } int solve() { if (m &lt; k) return 0; int tot_k = (ll)n*(m-k+1)%MOD; int ret = 0; if (s &lt;= m) add_mod(ret, (ll)tot_k*(n-1)%MOD*(m-s+1)%MOD); if (s &lt;= n) add_mod(ret, (ll)tot_k*(m-k)%MOD*(n-s+1)%MOD); int res = 0; if (s &lt;= m-k) { add_mod(res, sum(s, m-k)); ll sub = (ll)(s-1)*(m-k-s+1) % MOD; res = (res-sub+MOD)%MOD; add_mod(ret, (ll)res*n%MOD); } res = 0; if (m-k-s >= 0) { add_mod(res, (ll)(m-k-s+1)*(m-k-s+1)%MOD); ll sub = sum(0, m-k-s); res = (res-sub+MOD)%MOD; add_mod(ret, (ll)res*n%MOD); } res = 0; if (s &lt;= n-1) { add_mod(res, sum(s, n-1)); ll sub = (ll)(s-1)*(n-1-s+1)%MOD; res = (res-sub+MOD)%MOD; add_mod(ret, (ll)res*k*(m-k+1)%MOD); } res = 0; if (n-1-s >= 0) { add_mod(res, (ll)(n-s)*(n-s)%MOD); ll sub = sum(0, n-1-s); res = (res-sub+MOD)%MOD; add_mod(ret, (ll)res*k*(m-k+1)%MOD); } return ret; } int main() { int T; scanf(\"%d\", &amp;T); for (int cas=1; cas&lt;=T; ++cas) { scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;k, &amp;s); ans = solve(); swap(n, m); add_mod(ans, solve()); ans = (ll)ans * 4 % MOD; printf(\"Case %d: %d\\n\", cas, ans); } return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://sea96.github.io/tags/组合数学/"}]},{"title":"ZOJ 3328 Wu Xing","slug":"ZOJ-3328-Wu-Xing","date":"2017-02-28T10:03:54.000Z","updated":"2017-05-13T01:06:38.860Z","comments":true,"path":"2017/02/28/ZOJ-3328-Wu-Xing/","link":"","permalink":"https://sea96.github.io/2017/02/28/ZOJ-3328-Wu-Xing/","excerpt":"题意给一张完全图，用$k$个$n(\\leq 10^6)$元简单环去覆盖所有边，问$k$的最小值。","text":"题意给一张完全图，用$k$个$n(\\leq 10^6)$元简单环去覆盖所有边，问$k$的最小值。 题解 我们可以看到，他说要是任意两个点都有联系，看到这里，马上可以想到，要满足这个条件， 必须需要$\\frac {n(n-1)}{2}$条边，于是，换一种思考，该题目就可以理解为，在$\\frac {n(n-1)}{2}$条边中可以构成几个环。如果想到这里，你又开始去画点画边，那估计最后结果还是要悲剧。至少我是画不出，就算画出了也不知道到底是否是最小个数的环。 所以我们接着继续分析。。。抛开怎么连线不管， 往整体方向想，要构成一个环， $n$个点必须要$n$条边，可以理解，最终所有环所构成的边，都不会超过$\\frac {n(n-1)}{2}$条边。 所以每条边都在一个或几个环内，（其中不同的环可以共用一条边）。 所以至少有$\\frac {(n-1)}{2}$个环， 如果可以整除，那么商就是答案。如果不能整除呢？ 那么余下的边必定可以再组成一个环（必定的嘛）。所以如果$(n-1)%2 != 0$，那么答案就等于$\\frac {(n-1)}{2}+1$;结果就是和$\\frac {n}{2}$的结果一样，如果有些同学，开玩笑地试了这个公式，恭喜你，你ac了。（踩到狗屎了，呵呵！） 由$kn\\geq \\frac {n(n-1)}{2}$，可以求出 k 的下界，同时可以构造出取得下界的方案 代码略","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"}]},{"title":"Kattis Curious Cupid","slug":"Kattis-Curious-Cupid","date":"2017-02-28T09:48:52.000Z","updated":"2017-05-13T01:10:41.987Z","comments":true,"path":"2017/02/28/Kattis-Curious-Cupid/","link":"","permalink":"https://sea96.github.io/2017/02/28/Kattis-Curious-Cupid/","excerpt":"题意有$k(\\leq 10^6)$种不同的语言，每个人只说一种语言。现在有$n$$(\\leq 5\\times 10^4)$个男性和$n$个女性，每个人都想找一个和自己用同一种语言的异性，第$i$个男性的语言是$a_i$,，第$i$个女性的语言是$b_i$。现在给出$m$$(\\leq 5\\times 10^4)$个区间作为询问，每次需要回答在$[L, R]$区间的男女最多能够配对成多少对情侣。","text":"题意有$k(\\leq 10^6)$种不同的语言，每个人只说一种语言。现在有$n$$(\\leq 5\\times 10^4)$个男性和$n$个女性，每个人都想找一个和自己用同一种语言的异性，第$i$个男性的语言是$a_i$,，第$i$个女性的语言是$b_i$。现在给出$m$$(\\leq 5\\times 10^4)$个区间作为询问，每次需要回答在$[L, R]$区间的男女最多能够配对成多少对情侣。 题解离线处理，使用莫队算法解决，$O(1)$维护相同语言的情侣对数。 代码#include &lt;bits/stdc++.h> using namespace std; const int N = 5e4 + 5; const int M = N; const int K = 1e6 + 5; struct Query { int l, r, b, id; bool operator &lt; (const Query &amp;rhs) const { return b &lt; rhs.b || (b == rhs.b &amp;&amp; r &lt; rhs.r); } }q[M]; int a[N], b[N]; int ans[M]; int cnt[K][2]; int n, m, k; int tot; void add(int i) { if (a[i] == b[i]) { cnt[a[i]][0]++; cnt[b[i]][1]++; tot++; return ; } if (cnt[a[i]][0] &lt; cnt[a[i]][1]) tot++; if (cnt[b[i]][0] > cnt[b[i]][1]) tot++; cnt[a[i]][0]++; cnt[b[i]][1]++; } void sub(int i) { if (a[i] == b[i]) { cnt[a[i]][0]--; cnt[b[i]][1]--; tot--; return ; } if (cnt[a[i]][0] &lt;= cnt[a[i]][1]) tot--; if (cnt[b[i]][0] >= cnt[b[i]][1]) tot--; cnt[a[i]][0]--; cnt[b[i]][1]--; } int main() { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i=1; i&lt;=n; ++i) { scanf(\"%d\", &amp;a[i]); } for (int i=1; i&lt;=n; ++i) { scanf(\"%d\", &amp;b[i]); } int block = (int)sqrt(n); for (int i=1; i&lt;=m; ++i) { scanf(\"%d%d\", &amp;q[i].l, &amp;q[i].r); q[i].l++; q[i].r++; q[i].b = q[i].l / block; q[i].id = i; } sort(q+1, q+m+1); int L = 1, R = 1; tot = 0; cnt[a[1]][0]++; cnt[b[1]][1]++; if (a[1] == b[1]) tot++; for (int i=1; i&lt;=m; ++i) { while (L &lt; q[i].l) sub(L++); while (L > q[i].l) add(--L); while (R &lt; q[i].r) add(++R); while (R > q[i].r) sub(R--); ans[q[i].id] = tot; } for (int i=1; i&lt;=m; ++i) printf(\"%d\\n\", ans[i]); return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://sea96.github.io/tags/数据结构/"},{"name":"莫队算法","slug":"莫队算法","permalink":"https://sea96.github.io/tags/莫队算法/"}]},{"title":"最长公共子序列","slug":"最长公共子序列","date":"2017-02-27T06:38:08.000Z","updated":"2017-05-13T05:23:30.979Z","comments":true,"path":"2017/02/27/最长公共子序列/","link":"","permalink":"https://sea96.github.io/2017/02/27/最长公共子序列/","excerpt":"问题描述求两个字符串的最长公共子序列（Longest Common Subsequence ( LCS )）。","text":"问题描述求两个字符串的最长公共子序列（Longest Common Subsequence ( LCS )）。 算法分别记两个字符串为$S_1$和$S_2$，它们的最长公共子序列为$LCS(S_1,S_2)$。 朴素的做法枚举出$S_1$所有的子序列和$S_2$比较，时间复杂度：$O(2^{|S_1|}|S_2|)$。 动态规划的做法记$S_1$和$S_2$最后的字符分别是$S_1$和$S_2$，即：$$S_1=S_1’+e_1$$ $$S_2=S_2’+e_2$$有四种情况： $LCS$包含$e_1$ 不含$e_2$ $LCS$包含$e_2$ 不含$e_1$ $LCS$不含$e_1$，$e_2$ $LCS$包含$e_1$，$e_2$ 对于第一种情况，$e_2$没有用处，$LCS(S_1,S_2)=LCS(S_1,S_2’)$。对于第二种同理，$LCS(S_1,S_2)=LCS(S_1’,S_2)$对于第三种同理，$LCS(S_1,S_2)=LCS(S_1’,S_2’)$对于第四种同理，$LCS(S_1,S_2)=LCS(S_1’,S_2’)+e_1$如果使用非递归的做法，要保存前缀串的$LCS$，可以用动态规划实现。定义$dp[i][j]$表示$S_1$的前$i$个字符和$S_2$的前$j$个字符的$LCS$的长度，状态转移方程：$$dp[i][j]=max \\left \\{ dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+1 (S_{1_{i}}=S_{2_{j}}) \\right \\}$$如果要求得到一个最长公共子序列，用一个二维数组记录状态是从哪一个转移来的即可，递归打印。时间复杂度：$O(|S_1||S_2|)$ 优化如果用滚动数组优化，空间复杂度降至：$O(2|S|)$ 基于位运算的算法压位最长公共子序列（论文，代码） Hunt-Szymanski Algorithm转换为二维LIS问题 从两序列中找出对应的相同元素，以位置数对表示。这些位置数对可以排出的最长严格递增序列，即是两序列的$LCS $。首先將所有数对排序，规则是第一个维度由小到大排序，当第一个维度相等时，第二个維度由大到小排序。排序之后，第二个维度的$1D$ $LIS$，就对应到原数对们的$2D$ $LIS$。 记数对的总数目为$K$，时间复杂度：$O(Klog |S|)$如果出现类似于：$S_1=aaaa$，$S_2=aaaaaa$，时间复杂度退化成：$O(|S|^2log |S|)$ 代码//DP for (int i=1; i&lt;=n; ++i) { now ^= 1; for (int j=1; j&lt;=m; ++j) { dp[now][j] = max(dp[now^1][j], dp[now][j-1]); if (s[i] == t[j]) dp[now][j] = max(dp[now][j], dp[now^1][j-1]+1); } } //lcs = dp[now][m]; //2D LIS int LCS(char *s, char &amp;t) { int n = strlen(s+1), m = strlen(t+1); vector&lt;int> pos[128]; for (int i=1; i&lt;=m; ++i) { pos[t[i]].push_back(i); } vector&lt;int> lcs; for (int i=1; i&lt;=n; ++i) { for (int j=(int)pos[s[i]].size()-1; j>=0; --j) { int p = pos[s[i]][j]; if (lcs.empty()) lcs.push_back(p); else if (p > lcs.back()) lcs.push_back(p); else *lower_bound(lcs.begin(), lcs.end(), p) = p; } } return lcs.size(); } 习题UVA 111（简单题）POJ 2250（打印LCS）POJ 1159（滚动数组优化）UVA 10635 UVA 10949（2D LIS）玲珑学院OJ 1097 （2D LIS） 拓展最长公共上升子序列最长回文子序列最长公共子串 参考资料演算法笔记 - Longest Common Subsequence","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"},{"name":"LCS","slug":"LCS","permalink":"https://sea96.github.io/tags/LCS/"}]},{"title":"动态规划的各种类型","slug":"动态规划的各种类型","date":"2017-02-27T06:22:00.000Z","updated":"2017-05-13T05:23:24.744Z","comments":true,"path":"2017/02/27/动态规划的各种类型/","link":"","permalink":"https://sea96.github.io/2017/02/27/动态规划的各种类型/","excerpt":"子序列DP最长公共子序列http://m.blog.csdn.net/article/details?id=6918848","text":"子序列DP最长公共子序列http://m.blog.csdn.net/article/details?id=6918848 树形DP区间DP状压DP概率DP数位DP背包DP动态规划总结与题目分类","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"}]},{"title":"Codeforces Round #402 (Div.2)","slug":"Codeforces-Round-402-Div-2","date":"2017-02-26T11:49:06.000Z","updated":"2017-05-13T01:26:27.413Z","comments":true,"path":"2017/02/26/Codeforces-Round-402-Div-2/","link":"","permalink":"https://sea96.github.io/2017/02/26/Codeforces-Round-402-Div-2/","excerpt":"A. Pupils Redistribution题意：有2组学生，问最少交换几次学生，使得2组的各类型学生的人数相等。题解：比赛时先是看错题以为DP，然后又想法有问题调不出来，结果最后时间A掉，题倒不难。记录第一组的每类学生缺多少人以及不要多少人（其实是相等的，否则输出-1），可以在交换中得到一个人以及送出一个人。","text":"A. Pupils Redistribution题意：有2组学生，问最少交换几次学生，使得2组的各类型学生的人数相等。题解：比赛时先是看错题以为DP，然后又想法有问题调不出来，结果最后时间A掉，题倒不难。记录第一组的每类学生缺多少人以及不要多少人（其实是相等的，否则输出-1），可以在交换中得到一个人以及送出一个人。 B. Weird Rounding题意：给定一个数字$n(\\leq 2\\times 10^9)$，问最少删除多少个数位，使得剩余的能被$10^k(1\\leq k\\leq 9)$整除。题解：贪心地从后往前扫即可。如果没有符合的，还要额外考虑0。 C. Dishonest Sellers题意：有$n(\\leq 2\\times 10^5)$个商品，第$i$个商品当前价格为$a_i$，一周后的价格为$b_i$，必须至少现在买$k(\\leq n)$个商品，问最小花费。题解：按照$a_i-b_i$从小到大排序，前$k$个用$a_i$买，后面的用$min(a_i,b_i)$买即可。 D. String Game题意：有两个字符串$t$和$p$$(1 ≤ |p| &lt; |t| ≤ 2\\times 10^5)$，$t$按照一定顺序删除字符，直到和$p$相等或者子序列没有$p$，问最多能删除多少个字符。题解：二分答案$k$，check删除前$k$个指定字符后子序列还有没有$p$，二分找到最大的$k$。code E. Bitwise Formula题意：有$n(\\leq 5\\times 10^3)$个变量，每个变量用$m(\\leq 10^3)$位的二进制表示，给出$n$个变量的递推式，问’?’取何值时，所有变量的和最大以及最小？如果有多个满足题意，’?’取最小值。题解：常量不影响结果不考虑。由于相邻二进制的位运算互不影响，所以从高位到低位枚举’?’的二进制数’0’和’1’，根据所有由’?’决定的变量该位的’0’和’1’的数量和来选择答案。代码实现上处理好映射关系。code","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://sea96.github.io/tags/STL/"},{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"},{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"排序","slug":"排序","permalink":"https://sea96.github.io/tags/排序/"}]},{"title":"Codeforces 711E ZS and The Birthday Paradox","slug":"Codeforces-711E-ZS-and-The-Birthday-Paradox","date":"2017-02-26T07:15:19.000Z","updated":"2017-05-13T01:28:53.907Z","comments":true,"path":"2017/02/26/Codeforces-711E-ZS-and-The-Birthday-Paradox/","link":"","permalink":"https://sea96.github.io/2017/02/26/Codeforces-711E-ZS-and-The-Birthday-Paradox/","excerpt":"题意$k(\\leq 10^{18})$个人的生日在$2^n(n \\leq 10^{18})$天内，问至少有两个人的生日在同一天的概率。","text":"题意$k(\\leq 10^{18})$个人的生日在$2^n(n \\leq 10^{18})$天内，问至少有两个人的生日在同一天的概率。 题解先求所有人的生日都不同的概率$p$，那么答案就是$1-p$。$$p=\\frac {A_{2^n}^{k}}{(2^n)^k}=\\frac {\\prod_{i=0}^{k-1}(2^n-i)}{2^{kn}}$$也就是说第$i$个人的生日不重复的概率为$\\frac {(2^n-i)}{2^n}$。题目要求先约分再取模，根据公式$$GCD(a,b)=GCD(b-a,b),(a&lt;b)$$只要求$GCD((k-1)!,2^{(k-1)n})$，分子分母同除掉它后就可以取模，也就是求$(k-1)!$有多少个2，根据勒让德定理（Legendre’s formula）：在正数$n!$的素因子标准分解式中，素数$p$的指数记作$L_p(n!)$，则$$L_p(n!)=\\sum_{k=1}\\lfloor \\frac {n}{p^k} \\rfloor$$根据抽屉原理，当$k-1\\geq MOD$时，$k-1$个连续整数中必有一个能被$MOD$整除，这就意味着取模之后结果为0，那$k-1$个连续整数的乘积就是0。而当$k-1&lt;MOD$时,因为$MOD$的值不大,所以我们可以暴力循环求出分子，指数很大直接快速幂显然不行，注意到$MOD$是素数，根据费马小定理$$2^{p-1}\\equiv 1(mod p)$$可以降幂后用快速幂。时间复杂度：$O(MOD+log_k+log_n)$ 代码#include &lt;bits/stdc++.h> using namespace std; typedef long long ll; const int MOD = 1e6 + 3; ll pow_mod(ll x, ll n) { ll ret = 1; for (; n; n>>=1) { if (n &amp; 1) ret = ret * x % MOD; x = x * x % MOD; } return ret; } ll n, k; int main() { scanf(\"%I64d%I64d\", &amp;n, &amp;k); if (n&lt;63 &amp;&amp; (1LL&lt;&lt;n) &lt; k) { puts(\"1 1\"); return 0; } ll B = pow_mod(2LL, n%(MOD-1)*((k%(MOD-1)-1+(MOD-1))%(MOD-1))); ll cnt = 0; for (ll i=k-1; i; i>>=1) cnt += (i>>1); ll igcd = pow_mod(2LL, cnt%(MOD-1)*(MOD-2)%(MOD-1)); B = B * igcd % MOD; if (k-1 >= MOD) { printf(\"%I64d %I64d\\n\", B, B); return 0; } ll A = 1; for (int i=1; i&lt;=k-1; ++i) { A = A * ((pow_mod(2LL, n%(MOD-1))-i+MOD)%MOD) % MOD; } A = A * igcd % MOD; printf(\"%I64d %I64d\\n\", (B-A+MOD)%MOD, B); return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"概率","slug":"概率","permalink":"https://sea96.github.io/tags/概率/"},{"name":"数论","slug":"数论","permalink":"https://sea96.github.io/tags/数论/"}]},{"title":"Codeforces 449C Jzzhu and Apples","slug":"Codeforces-449C-Jzzhu-and-Apples","date":"2017-02-26T06:53:58.000Z","updated":"2017-05-13T01:30:42.575Z","comments":true,"path":"2017/02/26/Codeforces-449C-Jzzhu-and-Apples/","link":"","permalink":"https://sea96.github.io/2017/02/26/Codeforces-449C-Jzzhu-and-Apples/","excerpt":"题意给定$n(\\leq 10^5)$个数字，从1到n，问最多能组成多少对不互质的数对（每个数字只用一次，且公约数大于1）。","text":"题意给定$n(\\leq 10^5)$个数字，从1到n，问最多能组成多少对不互质的数对（每个数字只用一次，且公约数大于1）。 题解大于$\\lfloor \\frac {n}{2} \\rfloor $的素数不用考虑。找出小于$\\lfloor \\frac {n}{2} \\rfloor $的所有素数，从大到小，对于每一个素数$p$找出所有没有访问过且是$p$的倍数，如果个数为偶数，两两匹配即可；否则暂时不考虑$2p$，直到$p=2$时一起考虑。不会证明为什么是最优的。 代码#include &lt;bits/stdc++.h> using namespace std; const int N = 1e5 + 5; vector&lt;pair&lt;int, int> > ans; int n; int prime[N/4]; bool is_prime[N/2]; bool vis[N]; void prime_table(int n) { memset(is_prime, true, sizeof(is_prime)); int &amp;p = prime[0] = 0; is_prime[0] = is_prime[1] = false; for (int i=2; i&lt;=n; ++i) { if (is_prime[i]) prime[++p] = i; for (int j=1; j&lt;=p &amp;&amp; i*prime[j]&lt;=n; ++j) { is_prime[i*prime[j]] = false; if (i % prime[j] == 0) break; } } } int main() { scanf(\"%d\", &amp;n); prime_table(n/2); vector&lt;int> last, tmp; for (int i=prime[0]; i>=2; --i) { tmp.clear(); for (int j=prime[i]; j&lt;=n; j+=prime[i]) if (!vis[j]) tmp.push_back(j); int k = 0; if (tmp.size() &amp; 1) { ans.push_back(make_pair(tmp[0], tmp[2])); vis[tmp[0]] = vis[tmp[2]] = true; k = 3; } for (; k&lt;tmp.size(); k+=2) { ans.push_back(make_pair(tmp[k], tmp[k+1])); vis[tmp[k]] = vis[tmp[k+1]] = true; } } for (int i=2; i&lt;=n; i+=2) if (!vis[i]) last.push_back(i); for (int k=0; k&lt;(int)last.size()-1; k+=2) { ans.push_back(make_pair(last[k], last[k+1])); } printf(\"%d\\n\", ans.size()); for (auto p: ans) { printf(\"%d %d\\n\", p.first, p.second); } return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://sea96.github.io/tags/构造/"},{"name":"数论","slug":"数论","permalink":"https://sea96.github.io/tags/数论/"}]},{"title":"BestCoder 92C Girls Love 233","slug":"BestCoder-92C-Girls-Love-233","date":"2017-02-26T02:14:30.000Z","updated":"2017-05-13T05:22:31.507Z","comments":true,"path":"2017/02/26/BestCoder-92C-Girls-Love-233/","link":"","permalink":"https://sea96.github.io/2017/02/26/BestCoder-92C-Girls-Love-233/","excerpt":"题意给定一个长度为$n(\\leq 10^2)$，只包含’2’和’3’的字符串，每次操作可以交换相邻的字符，代价是智商-2。问智商为$m(\\leq 10^2)$不降为负数的情况下，最多能使字符串出现多少个字串“233”。","text":"题意给定一个长度为$n(\\leq 10^2)$，只包含’2’和’3’的字符串，每次操作可以交换相邻的字符，代价是智商-2。问智商为$m(\\leq 10^2)$不降为负数的情况下，最多能使字符串出现多少个字串“233”。 题解定义$dp[i][j][k]$表示使用了前$i$个’2’，第$i$个’2’在j位置，一共有$k$个“233”所需要的最小代价。状态转移方程：$$dp[i][j][k]=min \\left \\{ dp[i-1][j2][k],dp[i-1][j3][k-1] \\right \\} + 2|a[i]-j|$$时间复杂度：$O(n^4)$。 首先，因为字符不是’2’就是’3’，所以我们可以把字符串当做一个全部都是’3’的串，然后有若干的’2’插入到了某些位置。显然，我们交换相邻的’2’与’2’或者相邻的’3’与’3’是没有意义的，我们只会进行相邻’2’与’3’之间的交换。因此，所有’2’的相对前后关系其实是不会变化的。 利用偏移量来确定状态，优化内存时间。定义$dp[i][j][k][s]$表示考虑了i个’2’和j个’3’，花费k代价，后缀为s状态（0：前面没有’2’或者有足够多’3’；1：前一个’2’后面跟着1个’3’：2：跟着2个’3’）最多获得的”233”个数，状态转移方程：放一个’2’：$$Max(dp[i+1][j][k2][1],dp[i][j][k][s]),k2=k+|i+j+1-a[i+1]|$$放一个’3’：$$Max(dp[i][j+1][k][s2],dp[i][j][k][s]+add)$$放3时不增加代价，我的理解是移动’2’的同时相当于移动了’3’，如果原来的位置放了’2’，那么放’3’的代价会在放’2’的时候计算。 代码$O(n^4)$ #include &lt;bits/stdc++.h> using namespace std; const int N = 1e2 + 5; const int INF = 0x3f3f3f3f; char str[N]; int dp[N][N][N]; int a[N], cnt; int n, m; inline void Min(int &amp;a, int b) { if (a > b) a = b; } int main() { int T; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;n, &amp;m); scanf(\"%s\", str+1); cnt = 0; for (int i=1; i&lt;=n; ++i) if (str[i] == '2') a[++cnt] = i; for (int i=0; i&lt;=cnt; ++i) for (int j=1; j&lt;=n; ++j) for (int k=0; k&lt;=cnt; ++k) dp[i][j][k] = INF; for (int j=1; j&lt;=n; ++j) { dp[1][j][0] = 2*abs(a[1]-j); } for (int i=2; i&lt;=cnt; ++i) { for (int j=i; j&lt;=n; ++j) { for (int k=0; k&lt;=i; ++k) { for (int j2=max(i-1,j-2); j2&lt;=j-1; ++j2) Min(dp[i][j][k], dp[i-1][j2][k]); if (k) for (int j2=i-1; j2&lt;=j-3; ++j2) Min(dp[i][j][k], dp[i-1][j2][k-1]); dp[i][j][k] += 2*abs(a[i]-j); } } } int ans = 0; for (int j=1; j&lt;=n; ++j) for (int k=0; k&lt;=cnt; ++k) if (dp[cnt][j][k] &lt;= m) { ans = max(ans, k+(j&lt;=n-2)); } printf(\"%d\\n\", ans); } return 0; } $O(n^3)$ #include &lt;bits/stdc++.h> using namespace std; const int N = 1e2 + 5; const int INF = 0x3f3f3f3f; char str[N]; int dp[N][N][N>>1][3]; int a[N]; int c2, c3; int n, m; inline void Max(int &amp;a, int b) { if (a &lt; b) a = b; } int main() { int T; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;n, &amp;m); scanf(\"%s\", str+1); m /= 2; c2 = 0; for (int i=1; i&lt;=n; ++i) if (str[i] == '2') a[++c2] = i; c3 = n - c2; for (int i=0; i&lt;=c2; ++i) for (int j=0; j&lt;=c3; ++j) for (int k=0; k&lt;=m; ++k) for (int s=0; s&lt;3; ++s) dp[i][j][k][s] = -1; dp[0][0][0][0] = 0; for (int i=0; i&lt;=c2; ++i) { for (int j=0; j&lt;=c3; ++j) { for (int k=0; k&lt;=m; ++k) { for (int s=0; s&lt;3; ++s) if (~dp[i][j][k][s]) { if (i &lt; c2) { int k2 = k + abs(i+j+1-a[i+1]); if (k2 &lt;= m) Max(dp[i+1][j][k2][1], dp[i][j][k][s]); } if (j &lt; c3) { int s2 = s, add = 0; if (s) { if (s == 1) s2++; else s2 = 0, add++; } Max(dp[i][j+1][k][s2], dp[i][j][k][s]+add); } } } } } int ans = 0; for (int k=0; k&lt;=m; ++k) for (int s=0; s&lt;3; ++s) { Max(ans, dp[c2][c3][k][s]); } printf(\"%d\\n\", ans); } return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"}]},{"title":"动态规划的各种优化","slug":"动态规划的各种优化","date":"2017-02-25T07:03:05.000Z","updated":"2017-05-13T05:23:21.213Z","comments":true,"path":"2017/02/25/动态规划的各种优化/","link":"","permalink":"https://sea96.github.io/2017/02/25/动态规划的各种优化/","excerpt":"用单调性优化动态规划 单调性优化","text":"用单调性优化动态规划 单调性优化 Vijos 1243 生产产品题意：产品的生产需要$m(\\leq 10^5)$个步骤，每个步骤可以在$n(\\leq 5)$个机器中任何一台完成，机器$i$完成第$j$个步骤的时间为$a_{i,j}$。把半成品从一台机器上搬到另一台机器上也需要一定的时间$k$，每台机器最多只能连续完成产品的$l(\\leq 5*10^4)$个步骤，问最短需要多长时间。 题解：朴素的动态规划的算法：定义$dp[i][j]$表示前i个步骤，最后一段步骤用第$j$个机器完成，$sum[i][j]$表示前$i$个步骤用第$j$个机器完成的时间。状态转移方程：$$dp[i][j]=min\\left \\{ dp[t][p]+(sum[i][j]-sum[t][j])+k \\right \\},(j\\neq p,i-t\\leq l)$$时间复杂度：$O(n^2ml)$。把方程式变形得：$$dp[i][j]=min\\left \\{ dp[t][p]-sum[t][j] \\right \\}+sum[i][j]+k,(j\\neq p,i-t\\leq l)$$发现括号内的式子是根据$t$决定的（枚举$p$和$j$），所以可以用单调队列维护一个单调递增的序列进行优化，时间复杂度：$O(n^2m)$。code POJ 3017 Cut the Sequence题意：给定一个有$n$个非负整数的数列$a(a_i\\leq 10^5)$，要求将其划分为若干个部分，使得每部分的和不超过给定的常数$m$，并且所有部分的最大值的和最小。 题解：朴素的动态规划的算法：定义$dp[i]$表示前$i$个数字划分后所有部分最大值的和，$m(l,r)$表示区间$[l,r]$的最大值，$sum(l,r)$表示区间$[l,r]$的和，状态转移方程：$$dp[i]=min\\left \\{ dp[t]+m(t+1,i) \\right \\},sum(t+1,i)\\leq m$$因为是非负整数，dp的值显然是递增的，但是并没有可维护单调的序列，决策点也没有单调性，需要挖掘出单调性，引用kuangbin的做法： 首先假如不考虑m的限制，那么最优决策的$j$点，一定满足$a[j] &gt; max(a[j+1~i])$就是$j$点的值要大于$j+1$到$j$点的值。很明显的结论，因为假如不成立，那么可以把$j$点也划分到后面去，得到更优的所以用单调队列维护一个递减数列，这样的话最优决策点只能出现在这些点中。现在加了$m$的限制，假如上面那个递减数列只有后面一部分是满足$m$限制的。那么决策点就是上面这些点再加上满足$m$条件的那个边界，所以可以用平衡二叉树维护二叉树里面的值只要随着队列进行维护就好了，可以用multiset实现。 code 斜率优化BZOJ 1010 玩具装箱toy题意：$n$个玩具装到若干个容器内，问制作容器费用的最小值。题解：一份写的不错的题解 这里面详细的证明了决策点的单调性，在这前提下利用斜率的单调性，维护单调队列，侧重于“数”。 POJ 1180 Batch Scheduling（批量任务）题意：有$n(n\\leq 10^4)$个任务，要求依次执行，从时刻$0$开始，任务被分批加工。在每批任务开始前，机器需要启动时间$s$。每个任务有相应的执行时间T和影响因素F。一批任务完成时间就是各个任务的完成时间总和，每个任务完成的费用是任务完成时刻*该任务费用系数。确定一个方案使得总费用最小。 题解：这题要倒推，只有后面任务的分配确定后才有意义。$f(i)$表示完成$i$~$n$任务的最小费用，$T[i,j]$，$F[i,j]$分别表示完成任务$i$~任务$j$所需要的时间和费用。假设新增批次任务$i$~任务$j-1$，那么在$f(j)$的基础上，新增加的完成$i$~$j-1$任务的费用：$(s+T[i,j-1])F[i,j-1]$，延时造成的费用：$(s+T[i,j-1])F[i,j-1]$。所以$f(i)=min(f(j)+(s+T[i,j-1])*F[i,n])$，时间复杂度$O(n^2)$。 利用最优决策点的凸性优化（侧重“形”）：记$x(i)=T[i,n]，y(i)=f(i)，a[i]=s+T[i,n]，b[i]=F[i,n]$。上面的状态转移方程式等价于：$f(i)=min(y(j)+(a[i]-x[j])b[i])$，即$minp=f(i)=-b[i]x(j)+y(j)+a[i]b[i]$，即$y(j)=b[i]x(j)+(p-a[i]*b[i])$。随着$i$递减，$x(i)$递增，斜率$b[i]$递增，所以用单调队列维护一个下凸壳，时间复杂度降为$O(n)$。code HDOJ 5956 The Elder（长者的王国）题意：给出一个n个点的有根树，每条边上有权值，两个点的距离定义为路上边权和，给出另一个参数p。令$f_i=max(f_j+dis(i,j)^2+p)$，求f_i的最大值。 题解：树上的斜率优化DP，DFS遍历时，记录下当前单调队列的两个指针，以及队尾哪些被pop掉，递归结束后恢复即可。code 斜率单调暴力移指针斜率不单调二分找答案x坐标单调开单调队列x坐标不单调开平衡树|cdq分治 四边形不等式优化百度文库CSDNchino瀚清Aireen Ye 滚动数组优化（空间）二进制优化（时间）矩阵优化（时间）数据结构优化（时间）斜率优化四边形优化[dp优化]个人对dp优化的理解 夜深人静写算法（二） - 动态规划","categories":[{"name":"算法总结","slug":"算法总结","permalink":"https://sea96.github.io/categories/算法总结/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://sea96.github.io/tags/动态规划/"}]},{"title":"Codeforces 396B On Sum of Fractions","slug":"Codeforces-396B-On-Sum-of-Fractions","date":"2017-02-24T02:33:59.000Z","updated":"2017-05-13T01:31:04.066Z","comments":true,"path":"2017/02/24/Codeforces-396B-On-Sum-of-Fractions/","link":"","permalink":"https://sea96.github.io/2017/02/24/Codeforces-396B-On-Sum-of-Fractions/","excerpt":"题意定义$v(n)$是不大于$n$的最大素数，$u(n)$是大于$n$的最小素数，求$\\sum_{i=2}^{n}\\frac {1}{v(i)u(i)}$。","text":"题意定义$v(n)$是不大于$n$的最大素数，$u(n)$是大于$n$的最小素数，求$\\sum_{i=2}^{n}\\frac {1}{v(i)u(i)}$。 题解$$ans=\\sum_{k=2}^{p_{k}\\leq n}(\\frac {p_k-p_{k-1}}{p_k p_{k-1}})+\\frac {n-p_k+1}{p_{k+1}p_k}=\\frac {1}{p_1}-\\frac {1}{p_{k}}+\\frac {n-p_k+1}{p_{k+1}p_{k}}=\\frac {p_{k+1}(p_{k}-2)+2(n-p_{k}+1)}{2p_{k}p_{k+1}}$$再用GCD约分即可。 代码#include &lt;bits/stdc++.h> using namespace std; typedef long long ll; ll GCD(ll a, ll b) { return b ? GCD(b, a%b) : a; } bool is_prime(int n) { for (int i=2; i*i&lt;=n; ++i) { if (n % i == 0) return false; } return true; } int main() { int T; scanf(\"%d\", &amp;T); while (T--) { int n; scanf(\"%d\", &amp;n); int p1 = n, p2 = n+1; while (!is_prime(p1)) p1--; while (!is_prime(p2)) p2++; ll a = (ll)p2*(p1-2) + 2LL*(n-p1+1); ll b = 2LL * p1 * p2; ll c = GCD(a, b); printf(\"%I64d/%I64d\\n\", a/c, b/c); } return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://sea96.github.io/tags/数论/"}]},{"title":"Codeforces 287D Shifting","slug":"Codeforces-287D-Shifting","date":"2017-02-24T00:59:06.000Z","updated":"2017-05-13T01:31:20.094Z","comments":true,"path":"2017/02/24/Codeforces-287D-Shifting/","link":"","permalink":"https://sea96.github.io/2017/02/24/Codeforces-287D-Shifting/","excerpt":"题意定义排列$p=p_1,p_2,…,p_n$。定义函数$f(p, k)$用来转换$p$排列，$k$是转换参数。假设排列$p$的长度为$n(\\leq 10^6)$，首先把$p$按长度$k(&gt;1)$进行分块，若最后一块长度不足$k$，则其长度为$n%k$，然后分别对每一块循环左移一位，得到一个新的排列。","text":"题意定义排列$p=p_1,p_2,…,p_n$。定义函数$f(p, k)$用来转换$p$排列，$k$是转换参数。假设排列$p$的长度为$n(\\leq 10^6)$，首先把$p$按长度$k(&gt;1)$进行分块，若最后一块长度不足$k$，则其长度为$n%k$，然后分别对每一块循环左移一位，得到一个新的排列。 给定$n$，请输出$f(f(…f(p = [1,2,…,n],2)…,n-1,),n)$的结果。例如$n=5$的变化过程如下：$1,2,3,4,5 \\rightarrow 2,1,4,3,5 \\rightarrow 1,4,2,5,3 \\rightarrow 4,2,5,1,3 \\rightarrow 2,5,1,3,4$ 题解$f(9,3)$变化如下：$1,2,3,4,5,6,7,8,9 \\rightarrow 2,3,1,5,6,4,8,9,7$把左移过程看成往右jump的过程：$a,2,3,b,5,6,c,8,9 \\rightarrow 2,3,a,5,6,b,8,9,c$可以用一个双端队列维护，第$k$次操作需要操作$\\frac {n}{k}$个元素，总时间复杂度：$O(nlogn)$。 代码#include &lt;bits/stdc++.h> using namespace std; const int N = 1e6 + 5; deque&lt;int> dque; int n; int main() { scanf(\"%d\", &amp;n); for (int i=1; i&lt;=n; ++i) dque.push_back(i); for (int k=2; k&lt;=n; ++k) { int p = (n-1)/k*k; dque.push_back(dque[p]); for (; p-k>=0; p-=k) { dque[p] = dque[p-k]; } dque.pop_front(); } for (int i=0; i&lt;dque.size(); ++i) { printf(\"%d \", dque[i]); } return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://sea96.github.io/tags/构造/"}]},{"title":"Codeforces 21D Traveling Graph","slug":"Codeforces-21D-Traveling-Graph","date":"2017-02-24T00:31:41.000Z","updated":"2017-05-13T01:31:42.578Z","comments":true,"path":"2017/02/24/Codeforces-21D-Traveling-Graph/","link":"","permalink":"https://sea96.github.io/2017/02/24/Codeforces-21D-Traveling-Graph/","excerpt":"题意给出一个$n(1\\leq n \\leq5)$个点，$m(0\\leq m \\leq2000)$条边的无向带权图，问从$1$号点出发，通过所有的边至少一次，再回到$1$号点，需要花费的最少代价是多少。存在自环和重边。如果无法满足上述要求，那么输出$-1$。","text":"题意给出一个$n(1\\leq n \\leq5)$个点，$m(0\\leq m \\leq2000)$条边的无向带权图，问从$1$号点出发，通过所有的边至少一次，再回到$1$号点，需要花费的最少代价是多少。存在自环和重边。如果无法满足上述要求，那么输出$-1$。 题解用Floyd求出全源最短路，如果1号点到某个点的最短路不存在，并且该点有边相连，则直接输出$-1$。如果所有点的度数为偶数，则存在一条欧拉回路，$ans=\\sum w_i$。否则有偶数个点的度数是奇数，尝试用一些路径连接这些点。问题其实转变为：加上若干条边构造出一条欧拉回路，求花费的最小代价。可以发现度数已经是偶数的点作为某条路径的端点是不优的（因为会产生新的奇数度数的点），于是考虑对度数是奇数的点进行状态压缩，$dp[S]$表示已经相连的点集为$S$时的最小代价。转移枚举选出两个集合内的点，用一条路连起来，这两个点的度数都会变成偶数，时间复杂度：$O(n^22^n)$。一个trick是由于最后所有点度数都要是偶数，也就是每个度数是奇数的点都要作为某条路径的端点，那么每次考虑选出集合内标号最小的点，枚举这个点和另一个点用一条路径连起来，时间复杂度：$O(n2^n)$。 代码#include &lt;bits/stdc++.h> using namespace std; const int N = 15; const int S = 1&lt;&lt;N; const int INF = 0x3f3f3f3f; int d[N][N], deg[N]; int a[N]; int dp[S]; int n, m; int main() { scanf(\"%d%d\", &amp;n, &amp;m); memset(d, INF, sizeof(d)); for (int i=0; i&lt;n; ++i) d[i][i] = 0; int sum = 0; for (int i=0; i&lt;m; ++i) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); sum += w; deg[--u]++; deg[--v]++; d[u][v] = min(d[u][v], w); d[v][u] = min(d[v][u], w); } for (int k=0; k&lt;n; ++k) for (int i=0; i&lt;n; ++i) for (int j=0; j&lt;n; ++j) d[i][j] = min(d[i][j], d[i][k]+d[k][j]); for (int i=0; i&lt;n; ++i) { if (deg[i] > 0 &amp;&amp; d[0][i] == INF) { puts(\"-1\"); return 0; } } memset(dp, INF, sizeof(dp)); int c = 0; for (int i=0; i&lt;n; ++i) { if (deg[i] &amp; 1) a[c++] = i; } dp[0] = 0; for (int mask=0; mask&lt;(1&lt;&lt;c); ++mask) { for (int i=0; i&lt;c; ++i) if (!(mask &amp; (1&lt;&lt;i))) { for (int j=i+1; j&lt;c; ++j) if (!(mask &amp; (1&lt;&lt;j))) { dp[mask|(1&lt;&lt;i)|(1&lt;&lt;j)] = min(dp[mask|(1&lt;&lt;i)|(1&lt;&lt;j)], dp[mask]+d[a[i]][a[j]]); } break; } } printf(\"%d\\n\", sum+dp[(1&lt;&lt;c)-1]); return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://sea96.github.io/tags/位运算/"},{"name":"图论","slug":"图论","permalink":"https://sea96.github.io/tags/图论/"}]},{"title":"Codeforces 732D Exams","slug":"Codeforces-732D-Exams","date":"2017-02-24T00:22:31.000Z","updated":"2017-05-13T01:27:43.750Z","comments":true,"path":"2017/02/24/Codeforces-732D-Exams/","link":"","permalink":"https://sea96.github.io/2017/02/24/Codeforces-732D-Exams/","excerpt":"题意你需要在$n$天内通过$m$门课程(n,m \\leq 10^5)，每天可以考完一科科目，或者准备一门科目，或者休息。第$i$天可以考的科目为$d_i$，$d_i=0$表示这天不能考试，复习第$i$门课需要花费的时间为$a_i$。问复习完所有课程需要花费的最小天数是多少天，如果复习不完，输出$-1$。","text":"题意你需要在$n$天内通过$m$门课程(n,m \\leq 10^5)，每天可以考完一科科目，或者准备一门科目，或者休息。第$i$天可以考的科目为$d_i$，$d_i=0$表示这天不能考试，复习第$i$门课需要花费的时间为$a_i$。问复习完所有课程需要花费的最小天数是多少天，如果复习不完，输出$-1$。 题解二分枚举出可行的天数，贪心地将每门课程复习时间放在考试的前几天，check下是否能复习完。 代码#include &lt;bits/stdc++.h> using namespace std; const int N = 1e5 + 5; int d[N], a[N]; bool vis[N]; int n, m; bool check(int x) { memset(vis, false, sizeof(vis)); int need = 0, cnt = 0; for (int i=x; i>=1; --i) { if (d[i] &amp;&amp; !vis[d[i]]) { need += a[d[i]]; vis[d[i]] = true; cnt++; } else if (need > 0) need--; } if (need || cnt &lt; m) return false; else return true; } int main() { scanf(\"%d%d\", &amp;n, &amp;m); for (int i=1; i&lt;=n; ++i) { scanf(\"%d\", &amp;d[i]); } for (int i=1; i&lt;=m; ++i) { scanf(\"%d\", &amp;a[i]); } int low = 1, high = n, ans = -1; while (low &lt; high) { int mid = low + high >> 1; if (check(mid)) { ans = high = mid; } else low = mid + 1; } if (check(high)) ans = high; printf(\"%d\\n\", ans); return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"},{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"}]},{"title":"Codeforces 3D Least Cost Bracket Sequence","slug":"Codeforces-3D-Least-Cost-Bracket-Sequence","date":"2017-02-21T14:00:32.000Z","updated":"2017-05-13T01:31:57.930Z","comments":true,"path":"2017/02/21/Codeforces-3D-Least-Cost-Bracket-Sequence/","link":"","permalink":"https://sea96.github.io/2017/02/21/Codeforces-3D-Least-Cost-Bracket-Sequence/","excerpt":"题意给出一个字符串$(|S|\\leq 5*10^4)$，包含’(‘, ‘)’, ‘?’三种字符，将一个’?’变为左括号的代价为$a_i$，变为右括号的代价为$b_i$$(1≤a_i,b_i≤10^6)$。问将字符串变为合法括号序列的最小代价和此时的合法序列，无解输出$-1$。","text":"题意给出一个字符串$(|S|\\leq 5*10^4)$，包含’(‘, ‘)’, ‘?’三种字符，将一个’?’变为左括号的代价为$a_i$，变为右括号的代价为$b_i$$(1≤a_i,b_i≤10^6)$。问将字符串变为合法括号序列的最小代价和此时的合法序列，无解输出$-1$。 题解先尝试将所有’?’变成’)’，从左到右看，如果某个时刻’)’比’(‘多，那么从前面选取一个转变代价（$a_i$-&gt;$b_i$）最小的。选取位置任意，所以用set维护即可，时间复杂度$O(nlogn)$。 代码#include &lt;bits/stdc++.h> using namespace std; typedef pair&lt;int, int> pii; const int N = 5e4 + 5; char str[N]; set&lt;pii> st; int main() { scanf(\"%s\", str); int a, b; int x = 0; long long ans = 0; for (int i=0; str[i]; ++i) { if (str[i] == '(') x--; else if (str[i] == ')') x++; else { scanf(\"%d%d\", &amp;a, &amp;b); str[i] = ')'; x++; ans += b; st.insert(pii(a-b, i)); } while (x > 0) { if (st.empty()) { puts(\"-1\"); return 0; } pii p = *st.begin(); ans += p.first; str[p.second] = '('; st.erase(p); x -= 2; } } if (x != 0) { puts(\"-1\"); return 0; } printf(\"%I64d\\n\", ans); puts(str); return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://sea96.github.io/tags/贪心/"}]},{"title":"SPOJ ODDDIV Odd Numbers of Divisors","slug":"SPOJ-ODDDIV-Odd-Numbers-of-Divisors","date":"2017-02-21T13:54:00.000Z","updated":"2017-05-13T01:10:18.907Z","comments":true,"path":"2017/02/21/SPOJ-ODDDIV-Odd-Numbers-of-Divisors/","link":"","permalink":"https://sea96.github.io/2017/02/21/SPOJ-ODDDIV-Odd-Numbers-of-Divisors/","excerpt":"题意给出一个正奇数$K(\\leq 1o^4)$，两个正整数$low$, $high(0&lt; low \\leq high &lt; 10^{10})$。问有多少个整数属于$[low, high]$，且包含$K$个因子。","text":"题意给出一个正奇数$K(\\leq 1o^4)$，两个正整数$low$, $high(0&lt; low \\leq high &lt; 10^{10})$。问有多少个整数属于$[low, high]$，且包含$K$个因子。 题解满足条件的数字一定是完全平方数。假设$n=p_1^{m_1}p_2^{m_2}…p_k^{m_k}$，那么$n$的约数个数为$(m_1+1)(m_2+1)…(m_k+1)$，那么$n^2$的约数个数为$(2m_1+1)(2m_2+1)…(2m_k+1)$。所以我们只要预处理将$[1,10^5]$所有数字分解质因数，用vec[k]从小到大，存下所有的，有k个约数的完全平方数，询问时二分即可。 代码#include &lt;bits/stdc++.h> using namespace std; typedef long long ll; const int N = 1e5 + 5; int prime[N/2]; bool is_prime[N]; vector&lt;ll> vec[1500]; void prime_table(int n) { memset (is_prime, true, sizeof (is_prime)); is_prime[0] = is_prime[1] = false; int &amp;p = prime[0] = 0; for (int i=2; i&lt;=n; ++i) { if (is_prime[i]) prime[++p] = i; for (int j=1; j&lt;=p &amp;&amp; i*prime[j]&lt;=n; ++j) { is_prime[i*prime[j]] = false; if (i % prime[j] == 0) break; } } } int count_factors(int n) { //return cnt(n*n); int ret = 1; for (int i=1; i&lt;=prime[0]; ++i) { if (n % prime[i] == 0) { int p = prime[i], c = 0; while (n % p == 0) { n /= p; c++; } ret *= (2*c + 1); } if (n &lt;= 1 || (n &lt;= 100000 &amp;&amp; is_prime[n])) break; } if (n > 1) ret *= (2*1+1); return ret; } void init() { prime_table(100000); for (int i=1; i&lt;=100000; ++i) { int cnt = count_factors(i); vec[cnt].push_back((ll)i*i); } } int k; ll low, high; int main() { init(); int T; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%lld%lld\", &amp;k, &amp;low, &amp;high); if (k >= 1500 || vec[k].size() == 0) puts(\"0\"); else { int p1 = lower_bound(vec[k].begin(), vec[k].end(), low) - vec[k].begin(); int p2 = upper_bound(vec[k].begin(), vec[k].end(), high) - vec[k].begin(); printf(\"%d\\n\", p2-p1); } } return 0; }","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"散题","slug":"ACM解题报告/散题","permalink":"https://sea96.github.io/categories/ACM解题报告/散题/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"数论","slug":"数论","permalink":"https://sea96.github.io/tags/数论/"}]},{"title":"“玲珑杯”ACM比赛 Round #10","slug":"“玲珑杯”ACM比赛-Round-10","date":"2017-02-21T11:42:20.000Z","updated":"2017-05-13T03:11:55.578Z","comments":true,"path":"2017/02/21/“玲珑杯”ACM比赛-Round-10/","link":"","permalink":"https://sea96.github.io/2017/02/21/“玲珑杯”ACM比赛-Round-10/","excerpt":"A. Black and White题意$n(\\leq 10^6)$个格子从左到右排列，每个格子可以填黑色或者白色，但是不能有连续$a(\\leq 10^6)$个黑色或者连续$b(\\leq 10^6)$个白色，问填完$n$个格子的方案数。","text":"A. Black and White题意$n(\\leq 10^6)$个格子从左到右排列，每个格子可以填黑色或者白色，但是不能有连续$a(\\leq 10^6)$个黑色或者连续$b(\\leq 10^6)$个白色，问填完$n$个格子的方案数。 题解一下子联想到BestCoder Round #75 1003 King’s Order（不超过$3$个连续相同的），那题的做法：定义$f[i]$表示前$i$个满足条件的方案数，则$$f[i]=\\sum_{j=1}^{3}f[i-j]*25$$意思是使得最后$j$个连续相同。但是这题$a$和$b$范围太大，显然不是这么做的，但是思想可以借鉴。定义$f[i][0/1]$表示前$i$个最后一个是$0$（白色）或$1$（黑色）的方案数。状态转移方程：$$f[i][1]=f[i-1][0]+f[i-1][1]-f[i-1-(b-1)][0]$$意思是如果第$i$块填黑色，第$i-1$块当然可以填白色，但是如果填黑色的话，去掉连续$b$个相同的方案数。 代码#include using namespace std; typedef long long ll; const int N = 1e6 + 5; const int MOD = 1e9 + 7; ll f[N][2]; int n, a, b; ll pow_mod(ll x, int n) { ll ret = 1; for (; n; n>>=1) { if (n & 1) ret = ret * x % MOD; x = x * x % MOD; } return ret; } int main() { int T; scanf(\"%d\", &T); while (T--) { scanf(\"%d%d%d\", &a, &b, &n); if (a > b) swap(a, b); if (b == 1) { puts(\"0\"); continue; } if (a > n) { printf(\"%lld\\n\", pow_mod(2LL, n)); continue; } else if (a == 1) { if (b (ll)(1e10)) return ; else if (x != 0) a.push_back(x); DFS(x*10+1); DFS(x*10+6); } void DFS2(int i, ll x) { a.push_back(x); for (int j=i; j","categories":[{"name":"ACM解题报告","slug":"ACM解题报告","permalink":"https://sea96.github.io/categories/ACM解题报告/"},{"name":"套题","slug":"ACM解题报告/套题","permalink":"https://sea96.github.io/categories/ACM解题报告/套题/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://sea96.github.io/tags/二分/"},{"name":"组合数学","slug":"组合数学","permalink":"https://sea96.github.io/tags/组合数学/"}]}]}